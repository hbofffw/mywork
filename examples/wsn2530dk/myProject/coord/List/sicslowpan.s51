///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.20.2.41139 for 8051            03/Apr/2014  10:45:40 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  D:\myWork\myWork\core\net\sicslowpan.c            /
//    Command line       =  D:\myWork\myWork\core\net\sicslowpan.c -D         /
//                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC            /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\List\ -lA D:\myWork\myWork\examples\wsn2530dk\ /
//                          myProject\coord\List\ --diag_suppress             /
//                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o         /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\Obj\ -e --no_cse --no_unroll --no_inline       /
//                          --no_code_motion --no_tbaa --debug --core=plain   /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          16 --preinclude D:\myWork\myWork\examples\wsn2530 /
//                          dk\myProject\..\..\..\cpu\cc253x\cc253x.h -I      /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\ /
//                          ..\..\cpu\cc253x\ -I D:\myWork\myWork\examples\ws /
//                          n2530dk\myProject\..\..\..\platform\wsn2530dk\    /
//                          -I D:\myWork\myWork\examples\wsn2530dk\myProject\ /
//                          ..\..\..\core\ -I D:\myWork\myWork\examples\wsn25 /
//                          30dk\myProject\..\..\..\apps\ -I                  /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\    /
//                          -Ol                                               /
//    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\List\sicslowpan.s51                            /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME sicslowpan

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?CALL_IND
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?MOVE_LONG8_XDATA_XDATA
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?US_SHR
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        FUNCTION ??addr_context_lookup_by_number?relay,0203H
        FUNCTION ??addr_context_lookup_by_prefix?relay,0203H
        FUNCTION ??compress_addr_64?relay,0203H
        FUNCTION ??compress_hdr_hc06?relay,0203H
        FUNCTION ??input?relay,0203H
        FUNCTION ??output?relay,0203H
        FUNCTION ??packet_sent?relay,0203H
        PUBLIC ??rime_sniffer_add?relay
        FUNCTION ??rime_sniffer_add?relay,0203H
        PUBLIC ??rime_sniffer_remove?relay
        FUNCTION ??rime_sniffer_remove?relay,0203H
        FUNCTION ??send_packet?relay,0203H
        FUNCTION ??set_packet_attrs?relay,0203H
        PUBLIC ??sicslowpan_init?relay
        FUNCTION ??sicslowpan_init?relay,0203H
        FUNCTION ??uncompress_addr?relay,0203H
        FUNCTION ??uncompress_hdr_hc06?relay,0203H
        FUNCTION addr_context_lookup_by_number,0203H
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION addr_context_lookup_by_prefix,021203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        FUNCTION compress_addr_64,021203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 12, STACK
        FUNCTION compress_hdr_hc06,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 16, STACK
        FUNCTION input,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        PUBLIC llprefix
        FUNCTION output,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 14, STACK
        FUNCTION packet_sent,021603H
        ARGFRAME XSTACK, 2, STACK
        LOCFRAME XSTACK, 9, STACK
        PUBLIC rime_sniffer_add
        FUNCTION rime_sniffer_add,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC rime_sniffer_remove
        FUNCTION rime_sniffer_remove,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        FUNCTION send_packet,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION set_packet_attrs,021201H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 9, STACK
        PUBLIC sicslowpan_driver
        PUBLIC sicslowpan_init
        FUNCTION sicslowpan_init,021603H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC unc_ctxconf
        PUBLIC unc_llconf
        PUBLIC unc_mxconf
        FUNCTION uncompress_addr,021203H
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 22, STACK
        FUNCTION uncompress_hdr_hc06,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 22, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
memcmp              SYMBOL "memcmp"
??memcmp?relay      SYMBOL "?relay", memcmp
memcpy              SYMBOL "memcpy"
??memcpy?relay      SYMBOL "?relay", memcpy
memset              SYMBOL "memset"
??memset?relay      SYMBOL "?relay", memset
packetbuf_addr      SYMBOL "packetbuf_addr"
??packetbuf_addr?relay SYMBOL "?relay", packetbuf_addr
packetbuf_clear     SYMBOL "packetbuf_clear"
??packetbuf_clear?relay SYMBOL "?relay", packetbuf_clear
packetbuf_datalen   SYMBOL "packetbuf_datalen"
??packetbuf_datalen?relay SYMBOL "?relay", packetbuf_datalen
packetbuf_dataptr   SYMBOL "packetbuf_dataptr"
??packetbuf_dataptr?relay SYMBOL "?relay", packetbuf_dataptr
packetbuf_set_addr  SYMBOL "packetbuf_set_addr"
??packetbuf_set_addr?relay SYMBOL "?relay", packetbuf_set_addr
packetbuf_set_attr  SYMBOL "packetbuf_set_attr"
??packetbuf_set_attr?relay SYMBOL "?relay", packetbuf_set_attr
packetbuf_set_datalen SYMBOL "packetbuf_set_datalen"
??packetbuf_set_datalen?relay SYMBOL "?relay", packetbuf_set_datalen
rimeaddr_copy       SYMBOL "rimeaddr_copy"
??rimeaddr_copy?relay SYMBOL "?relay", rimeaddr_copy
tcpip_input         SYMBOL "tcpip_input"
??tcpip_input?relay SYMBOL "?relay", tcpip_input
tcpip_set_outputfunc SYMBOL "tcpip_set_outputfunc"
??tcpip_set_outputfunc?relay SYMBOL "?relay", tcpip_set_outputfunc
uip_ds6_link_neighbor_callback SYMBOL "uip_ds6_link_neighbor_callback"
??uip_ds6_link_neighbor_callback?relay SYMBOL "?relay", uip_ds6_link_neighbor_callback
uip_ds6_set_addr_iid SYMBOL "uip_ds6_set_addr_iid"
??uip_ds6_set_addr_iid?relay SYMBOL "?relay", uip_ds6_set_addr_iid
watchdog_periodic   SYMBOL "watchdog_periodic"
??watchdog_periodic?relay SYMBOL "?relay", watchdog_periodic
rime_sniffer_add    SYMBOL "rime_sniffer_add"
??rime_sniffer_add?relay SYMBOL "?relay", rime_sniffer_add
rime_sniffer_remove SYMBOL "rime_sniffer_remove"
??rime_sniffer_remove?relay SYMBOL "?relay", rime_sniffer_remove
sicslowpan_init     SYMBOL "sicslowpan_init"
??sicslowpan_init?relay SYMBOL "?relay", sicslowpan_init

        EXTERN ??memcmp?relay
        FUNCTION ??memcmp?relay,00H
        EXTERN ??memcpy?relay
        FUNCTION ??memcpy?relay,00H
        EXTERN ??memset?relay
        FUNCTION ??memset?relay,00H
        EXTERN ??packetbuf_addr?relay
        FUNCTION ??packetbuf_addr?relay,00H
        EXTERN ??packetbuf_clear?relay
        FUNCTION ??packetbuf_clear?relay,00H
        EXTERN ??packetbuf_datalen?relay
        FUNCTION ??packetbuf_datalen?relay,00H
        EXTERN ??packetbuf_dataptr?relay
        FUNCTION ??packetbuf_dataptr?relay,00H
        EXTERN ??packetbuf_set_addr?relay
        FUNCTION ??packetbuf_set_addr?relay,00H
        EXTERN ??packetbuf_set_attr?relay
        FUNCTION ??packetbuf_set_attr?relay,00H
        EXTERN ??packetbuf_set_datalen?relay
        FUNCTION ??packetbuf_set_datalen?relay,00H
        EXTERN ??rimeaddr_copy?relay
        FUNCTION ??rimeaddr_copy?relay,00H
        EXTERN ??tcpip_input?relay
        FUNCTION ??tcpip_input?relay,00H
        EXTERN ??tcpip_set_outputfunc?relay
        FUNCTION ??tcpip_set_outputfunc?relay,00H
        EXTERN ??uip_ds6_link_neighbor_callback?relay
        FUNCTION ??uip_ds6_link_neighbor_callback?relay,00H
        EXTERN ??uip_ds6_set_addr_iid?relay
        FUNCTION ??uip_ds6_set_addr_iid?relay,00H
        EXTERN ??watchdog_periodic?relay
        FUNCTION ??watchdog_periodic?relay,00H
        EXTERN framer_802154
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcpy
        FUNCTION memcpy,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memset
        FUNCTION memset,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN nullmac_driver
        EXTERN packetbuf_addr
        FUNCTION packetbuf_addr,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN packetbuf_clear
        FUNCTION packetbuf_clear,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN packetbuf_datalen
        FUNCTION packetbuf_datalen,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN packetbuf_dataptr
        FUNCTION packetbuf_dataptr,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN packetbuf_set_addr
        FUNCTION packetbuf_set_addr,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN packetbuf_set_attr
        FUNCTION packetbuf_set_attr,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN packetbuf_set_datalen
        FUNCTION packetbuf_set_datalen,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN rimeaddr_copy
        FUNCTION rimeaddr_copy,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN rimeaddr_null
        EXTERN tcpip_input
        FUNCTION tcpip_input,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN tcpip_set_outputfunc
        FUNCTION tcpip_set_outputfunc,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_aligned_buf
        EXTERN uip_ds6_link_neighbor_callback
        FUNCTION uip_ds6_link_neighbor_callback,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_ds6_set_addr_iid
        FUNCTION uip_ds6_set_addr_iid,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_len
        EXTERN uip_lladdr
        EXTERN watchdog_periodic
        FUNCTION watchdog_periodic,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// D:\myWork\myWork\core\net\sicslowpan.c
//    1 /**
//    2  * \addtogroup sicslowpan
//    3  * @{
//    4  */
//    5 /*
//    6  * Copyright (c) 2008, Swedish Institute of Computer Science.
//    7  * All rights reserved.
//    8  *
//    9  * Redistribution and use in source and binary forms, with or without
//   10  * modification, are permitted provided that the following conditions
//   11  * are met:
//   12  * 1. Redistributions of source code must retain the above copyright
//   13  *    notice, this list of conditions and the following disclaimer.
//   14  * 2. Redistributions in binary form must reproduce the above copyright
//   15  *    notice, this list of conditions and the following disclaimer in the
//   16  *    documentation and/or other materials provided with the distribution.
//   17  * 3. Neither the name of the Institute nor the names of its contributors
//   18  *    may be used to endorse or promote products derived from this software
//   19  *    without specific prior written permission.
//   20  *
//   21  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
//   22  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   23  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//   24  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
//   25  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   26  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
//   27  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//   28  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//   29  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
//   30  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
//   31  * SUCH DAMAGE.
//   32  *
//   33  * This file is part of the Contiki operating system.
//   34  *
//   35  */
//   36 /**
//   37  * \file
//   38  *         6lowpan implementation (RFC4944 and draft-ietf-6lowpan-hc-06)
//   39  *
//   40  * \author Adam Dunkels <adam@sics.se>
//   41  * \author Nicolas Tsiftes <nvt@sics.se>
//   42  * \author Niclas Finne <nfi@sics.se>
//   43  * \author Mathilde Durvy <mdurvy@cisco.com>
//   44  * \author Julien Abeille <jabeille@cisco.com>
//   45  * \author Joakim Eriksson <joakime@sics.se>
//   46  * \author Joel Hoglund <joel@sics.se>
//   47  */
//   48 
//   49 /**
//   50  * FOR HC-06 COMPLIANCE TODO:
//   51  * -Add compression options to UDP, currently only supports
//   52  *  both ports compressed or both ports elided
//   53  *  
//   54  * -Verify TC/FL compression works
//   55  *  
//   56  * -Add stateless multicast option
//   57  */
//   58 
//   59 #include <string.h>
//   60 
//   61 #include "contiki.h"
//   62 #include "dev/watchdog.h"
//   63 #include "net/tcpip.h"
//   64 #include "net/uip.h"
//   65 #include "net/uip-ds6.h"
//   66 #include "net/rime.h"
//   67 #include "net/sicslowpan.h"
//   68 #include "net/netstack.h"
//   69 
//   70 #if UIP_CONF_IPV6
//   71 
//   72 #include <stdio.h>
//   73 
//   74 #define DEBUG DEBUG_NONE
//   75 #include "net/uip-debug.h"
//   76 #if DEBUG
//   77 /* PRINTFI and PRINTFO are defined for input and output to debug one without changing the timing of the other */
//   78 uint8_t p;
//   79 #include <stdio.h>
//   80 #define PRINTFI(...) PRINTF(__VA_ARGS__)
//   81 #define PRINTFO(...) PRINTF(__VA_ARGS__)
//   82 #define PRINTPACKETBUF() PRINTF("RIME buffer: "); for(p = 0; p < packetbuf_datalen(); p++){PRINTF("%.2X", *(rime_ptr + p));} PRINTF("\n")
//   83 #define PRINTUIPBUF() PRINTF("UIP buffer: "); for(p = 0; p < uip_len; p++){PRINTF("%.2X", uip_buf[p]);}PRINTF("\n")
//   84 #define PRINTSICSLOWPANBUF() PRINTF("SICSLOWPAN buffer: "); for(p = 0; p < sicslowpan_len; p++){PRINTF("%.2X", sicslowpan_buf[p]);}PRINTF("\n")
//   85 #else
//   86 #define PRINTFI(...)
//   87 #define PRINTFO(...)
//   88 #define PRINTPACKETBUF()
//   89 #define PRINTUIPBUF()
//   90 #define PRINTSICSLOWPANBUF()
//   91 #endif /* DEBUG == 1*/
//   92 
//   93 #if UIP_LOGGING
//   94 #include <stdio.h>
//   95 void uip_log(char *msg);
//   96 #define UIP_LOG(m) uip_log(m)
//   97 #else
//   98 #define UIP_LOG(m)
//   99 #endif /* UIP_LOGGING == 1 */
//  100 
//  101 #ifdef SICSLOWPAN_CONF_MAX_MAC_TRANSMISSIONS
//  102 #define SICSLOWPAN_MAX_MAC_TRANSMISSIONS SICSLOWPAN_CONF_MAX_MAC_TRANSMISSIONS
//  103 #else
//  104 #define SICSLOWPAN_MAX_MAC_TRANSMISSIONS 4
//  105 #endif
//  106 
//  107 #ifndef SICSLOWPAN_COMPRESSION
//  108 #ifdef SICSLOWPAN_CONF_COMPRESSION
//  109 #define SICSLOWPAN_COMPRESSION SICSLOWPAN_CONF_COMPRESSION
//  110 #else
//  111 #define SICSLOWPAN_COMPRESSION SICSLOWPAN_COMPRESSION_IPV6
//  112 #endif /* SICSLOWPAN_CONF_COMPRESSION */
//  113 #endif /* SICSLOWPAN_COMPRESSION */
//  114 
//  115 #define GET16(ptr,index) (((uint16_t)((ptr)[index] << 8)) | ((ptr)[(index) + 1]))
//  116 #define SET16(ptr,index,value) do {     \ 
//  117   (ptr)[index] = ((value) >> 8) & 0xff; \ 
//  118   (ptr)[index + 1] = (value) & 0xff;    \ 
//  119 } while(0)
//  120 
//  121 /** \name Pointers in the rime buffer
//  122  *  @{
//  123  */
//  124 #define RIME_FRAG_PTR           (rime_ptr)
//  125 #define RIME_FRAG_DISPATCH_SIZE 0   /* 16 bit */
//  126 #define RIME_FRAG_TAG           2   /* 16 bit */
//  127 #define RIME_FRAG_OFFSET        4   /* 8 bit */
//  128 
//  129 /* define the buffer as a byte array */
//  130 #define RIME_IPHC_BUF              ((uint8_t *)(rime_ptr + rime_hdr_len))
//  131 
//  132 #define RIME_HC1_PTR            (rime_ptr + rime_hdr_len)
//  133 #define RIME_HC1_DISPATCH       0 /* 8 bit */
//  134 #define RIME_HC1_ENCODING       1 /* 8 bit */
//  135 #define RIME_HC1_TTL            2 /* 8 bit */
//  136 
//  137 #define RIME_HC1_HC_UDP_PTR           (rime_ptr + rime_hdr_len)
//  138 #define RIME_HC1_HC_UDP_DISPATCH      0 /* 8 bit */
//  139 #define RIME_HC1_HC_UDP_HC1_ENCODING  1 /* 8 bit */
//  140 #define RIME_HC1_HC_UDP_UDP_ENCODING  2 /* 8 bit */
//  141 #define RIME_HC1_HC_UDP_TTL           3 /* 8 bit */
//  142 #define RIME_HC1_HC_UDP_PORTS         4 /* 8 bit */
//  143 #define RIME_HC1_HC_UDP_CHKSUM        5 /* 16 bit */
//  144 
//  145 /** \name Pointers in the sicslowpan and uip buffer
//  146  *  @{
//  147  */
//  148 #define SICSLOWPAN_IP_BUF   ((struct uip_ip_hdr *)&sicslowpan_buf[UIP_LLH_LEN])
//  149 #define SICSLOWPAN_UDP_BUF ((struct uip_udp_hdr *)&sicslowpan_buf[UIP_LLIPH_LEN])
//  150 
//  151 #define UIP_IP_BUF          ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
//  152 #define UIP_UDP_BUF          ((struct uip_udp_hdr *)&uip_buf[UIP_LLIPH_LEN])
//  153 #define UIP_TCP_BUF          ((struct uip_tcp_hdr *)&uip_buf[UIP_LLIPH_LEN])
//  154 #define UIP_ICMP_BUF          ((struct uip_icmp_hdr *)&uip_buf[UIP_LLIPH_LEN])
//  155 /** @} */
//  156 
//  157 
//  158 /** \brief Size of the 802.15.4 payload (127byte - 25 for MAC header) */
//  159 #ifdef SICSLOWPAN_CONF_MAC_MAX_PAYLOAD
//  160 #define MAC_MAX_PAYLOAD SICSLOWPAN_CONF_MAC_MAX_PAYLOAD
//  161 #else /* SICSLOWPAN_CONF_MAC_MAX_PAYLOAD */
//  162 #define MAC_MAX_PAYLOAD 102
//  163 #endif /* SICSLOWPAN_CONF_MAC_MAX_PAYLOAD */
//  164 
//  165 
//  166 /** \brief Some MAC layers need a minimum payload, which is
//  167     configurable through the SICSLOWPAN_CONF_MIN_MAC_PAYLOAD
//  168     option. */
//  169 #ifdef SICSLOWPAN_CONF_COMPRESSION_THRESHOLD
//  170 #define COMPRESSION_THRESHOLD SICSLOWPAN_CONF_COMPRESSION_THRESHOLD
//  171 #else
//  172 #define COMPRESSION_THRESHOLD 0
//  173 #endif
//  174 
//  175 /** \name General variables
//  176  *  @{
//  177  */
//  178 #ifdef SICSLOWPAN_NH_COMPRESSOR
//  179 /** A pointer to the additional compressor */
//  180 extern struct sicslowpan_nh_compressor SICSLOWPAN_NH_COMPRESSOR;
//  181 #endif
//  182 
//  183 /**
//  184  * A pointer to the rime buffer.
//  185  * We initialize it to the beginning of the rime buffer, then
//  186  * access different fields by updating the offset rime_hdr_len.
//  187  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  188 static uint8_t *rime_ptr;
rime_ptr:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  189 
//  190 /**
//  191  * rime_hdr_len is the total length of (the processed) 6lowpan headers
//  192  * (fragment headers, IPV6 or HC1, HC2, and HC1 and HC2 non compressed
//  193  * fields).
//  194  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  195 static uint8_t rime_hdr_len;
rime_hdr_len:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  196 
//  197 /**
//  198  * The length of the payload in the Rime buffer.
//  199  * The payload is what comes after the compressed or uncompressed
//  200  * headers (can be the IP payload if the IP header only is compressed
//  201  * or the UDP payload if the UDP header is also compressed)
//  202  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  203 static uint8_t rime_payload_len;
rime_payload_len:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  204 
//  205 /**
//  206  * uncomp_hdr_len is the length of the headers before compression (if HC2
//  207  * is used this includes the UDP header in addition to the IP header).
//  208  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  209 static uint8_t uncomp_hdr_len;
uncomp_hdr_len:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  210 
//  211 /**
//  212  * the result of the last transmitted fragment
//  213  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  214 static int last_tx_status;
last_tx_status:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  215 /** @} */
//  216 
//  217 #if SICSLOWPAN_CONF_FRAG
//  218 /** \name Fragmentation related variables
//  219  *  @{
//  220  */
//  221 
//  222 static uint16_t sicslowpan_len;
//  223 
//  224 /**
//  225  * The buffer used for the 6lowpan reassembly.
//  226  * This buffer contains only the IPv6 packet (no MAC header, 6lowpan, etc).
//  227  * It has a fix size as we do not use dynamic memory allocation.
//  228  */
//  229 static uip_buf_t sicslowpan_aligned_buf;
//  230 #define sicslowpan_buf (sicslowpan_aligned_buf.u8)
//  231 
//  232 /** The total length of the IPv6 packet in the sicslowpan_buf. */
//  233 
//  234 /**
//  235  * length of the ip packet already sent / received.
//  236  * It includes IP and transport headers.
//  237  */
//  238 static uint16_t processed_ip_in_len;
//  239 
//  240 /** Datagram tag to be put in the fragments I send. */
//  241 static uint16_t my_tag;
//  242 
//  243 /** When reassembling, the tag in the fragments being merged. */
//  244 static uint16_t reass_tag;
//  245 
//  246 /** When reassembling, the source address of the fragments being merged */
//  247 rimeaddr_t frag_sender;
//  248 
//  249 /** Reassembly %process %timer. */
//  250 static struct timer reass_timer;
//  251 
//  252 /** @} */
//  253 #else /* SICSLOWPAN_CONF_FRAG */
//  254 /** The buffer used for the 6lowpan processing is uip_buf.
//  255     We do not use any additional buffer.*/
//  256 #define sicslowpan_buf uip_buf
//  257 #define sicslowpan_len uip_len
//  258 #endif /* SICSLOWPAN_CONF_FRAG */
//  259 
//  260 /*-------------------------------------------------------------------------*/
//  261 /* Rime Sniffer support for one single listener to enable powertrace of IP */
//  262 /*-------------------------------------------------------------------------*/

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  263 static struct rime_sniffer *callback = NULL;
callback:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  264 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  265 void
//  266 rime_sniffer_add(struct rime_sniffer *s)
rime_sniffer_add:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function rime_sniffer_add
        CODE
//  267 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  268   callback = s;
        MOV     DPTR,#callback
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  269 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock0
//  270 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  271 void
//  272 rime_sniffer_remove(struct rime_sniffer *s)
rime_sniffer_remove:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function rime_sniffer_remove
        CODE
//  273 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  274   callback = NULL;
        MOV     DPTR,#callback
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  275 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock1
//  276 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  277 static void
//  278 set_packet_attrs()
set_packet_attrs:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function set_packet_attrs
        CODE
//  279 {
        FUNCALL set_packet_attrs, packetbuf_set_attr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL set_packet_attrs, packetbuf_set_attr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
//  280   int c = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
//  281   /* set protocol in NETWORK_ID */
//  282   packetbuf_set_attr(PACKETBUF_ATTR_NETWORK_ID, UIP_IP_BUF->proto);
        ; Setup parameters for call to function packetbuf_set_attr
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     R1,#0x2
        LCALL   ??packetbuf_set_attr?relay
//  283 
//  284   /* assign values to the channel attribute (port or type + code) */
//  285   if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x11
        JNZ     ??set_packet_attrs_0
//  286     c = UIP_UDP_BUF->srcport;
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  287     if(UIP_UDP_BUF->destport < c) {
        MOV     DPTR,#uip_aligned_buf + 42
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R6
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R7
        JNC     ??set_packet_attrs_1
//  288       c = UIP_UDP_BUF->destport;
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        SJMP    ??set_packet_attrs_1
//  289     }
//  290   } else if(UIP_IP_BUF->proto == UIP_PROTO_TCP) {
??set_packet_attrs_0:
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x6
        JNZ     ??set_packet_attrs_2
//  291     c = UIP_TCP_BUF->srcport;
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  292     if(UIP_TCP_BUF->destport < c) {
        MOV     DPTR,#uip_aligned_buf + 42
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R6
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R7
        JNC     ??set_packet_attrs_1
//  293       c = UIP_TCP_BUF->destport;
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
        SJMP    ??set_packet_attrs_1
//  294     }
//  295   } else if(UIP_IP_BUF->proto == UIP_PROTO_ICMP6) {
??set_packet_attrs_2:
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x3a
        JNZ     ??set_packet_attrs_1
//  296     c = UIP_ICMP_BUF->type << 8 | UIP_ICMP_BUF->icode;
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 41
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ORL     A,R2
        MOV     R6,A
        MOV     A,R1
        ORL     A,R3
        MOV     R7,A
//  297   }
//  298 
//  299   packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c);
??set_packet_attrs_1:
        ; Setup parameters for call to function packetbuf_set_attr
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     R1,#0x1
        LCALL   ??packetbuf_set_attr?relay
//  300 
//  301 /*   if(uip_ds6_is_my_addr(&UIP_IP_BUF->srcipaddr)) { */
//  302 /*     own = 1; */
//  303 /*   } */
//  304 
//  305 }
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock2
//  306 
//  307 
//  308 
//  309 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
//  310 /** \name HC06 specific variables
//  311  *  @{
//  312  */
//  313 
//  314 /** Addresses contexts for IPHC. */
//  315 #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0
//  316 static struct sicslowpan_addr_context 

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  317 addr_contexts[SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS];
addr_contexts:
        DS 10
        REQUIRE __INIT_XDATA_Z
//  318 #endif
//  319 
//  320 /** pointer to an address context. */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  321 static struct sicslowpan_addr_context *context;
context:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  322 
//  323 /** pointer to the byte where to write next inline field. */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  324 static uint8_t *hc06_ptr;
hc06_ptr:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
`?<Constant "sicslowpan">`:
        DS 11
        REQUIRE `?<Initializer for <Constant "sicslowpan">>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA16
`?<Constant {255, 2}>`:
        DS 2
        REQUIRE `?<Initializer for <Constant {255, 2}>>`
        REQUIRE __INIT_XDATA_I
//  325 
//  326 /* Uncompression of linklocal */
//  327 /*   0 -> 16 bytes from packet  */
//  328 /*   1 -> 2 bytes from prefix - bunch of zeroes and 8 from packet */
//  329 /*   2 -> 2 bytes from prefix - 0000::00ff:fe00:XXXX from packet */
//  330 /*   3 -> 2 bytes from prefix - infer 8 bytes from lladdr */
//  331 /*   NOTE: => the uncompress function does change 0xf to 0x10 */
//  332 /*   NOTE: 0x00 => no-autoconfig => unspecified */

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
//  333 const uint8_t unc_llconf[] = {0x0f,0x28,0x22,0x20};
unc_llconf:
        DS 4
        REQUIRE `?<Initializer for unc_llconf>`
        REQUIRE __INIT_XDATA_I
//  334 
//  335 /* Uncompression of ctx-based */
//  336 /*   0 -> 0 bits from packet [unspecified / reserved] */
//  337 /*   1 -> 8 bytes from prefix - bunch of zeroes and 8 from packet */
//  338 /*   2 -> 8 bytes from prefix - 0000::00ff:fe00:XXXX + 2 from packet */
//  339 /*   3 -> 8 bytes from prefix - infer 8 bytes from lladdr */

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
//  340 const uint8_t unc_ctxconf[] = {0x00,0x88,0x82,0x80};
unc_ctxconf:
        DS 4
        REQUIRE `?<Initializer for unc_ctxconf>`
        REQUIRE __INIT_XDATA_I
//  341 
//  342 /* Uncompression of ctx-based */
//  343 /*   0 -> 0 bits from packet  */
//  344 /*   1 -> 2 bytes from prefix - bunch of zeroes 5 from packet */
//  345 /*   2 -> 2 bytes from prefix - zeroes + 3 from packet */
//  346 /*   3 -> 2 bytes from prefix - infer 1 bytes from lladdr */

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
//  347 const uint8_t unc_mxconf[] = {0x0f, 0x25, 0x23, 0x21};
unc_mxconf:
        DS 4
        REQUIRE `?<Initializer for unc_mxconf>`
        REQUIRE __INIT_XDATA_I
//  348 
//  349 /* Link local prefix */

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA16
//  350 const uint8_t llprefix[] = {0xfe, 0x80};
llprefix:
        DS 2
        REQUIRE `?<Initializer for llprefix>`
        REQUIRE __INIT_XDATA_I
//  351 
//  352 /* TTL uncompression values */

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
//  353 static const uint8_t ttl_values[] = {0, 1, 64, 255};
ttl_values:
        DS 4
        REQUIRE `?<Initializer for ttl_values>`
        REQUIRE __INIT_XDATA_I
//  354 
//  355 /*--------------------------------------------------------------------*/
//  356 /** \name HC06 related functions
//  357  * @{                                                                 */
//  358 /*--------------------------------------------------------------------*/
//  359 /** \brief find the context corresponding to prefix ipaddr */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  360 static struct sicslowpan_addr_context*
//  361 addr_context_lookup_by_prefix(uip_ipaddr_t *ipaddr)
addr_context_lookup_by_prefix:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function addr_context_lookup_by_prefix
        CODE
//  362 {
        FUNCALL addr_context_lookup_by_prefix, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  363 /* Remove code to avoid warnings and save flash if no context is used */
//  364 #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0
//  365   int i;
//  366   for(i = 0; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
        MOV     ?V0 + 0,#0x0
        MOV     ?V0 + 1,#0x0
        SJMP    ??addr_context_lookup_by_prefix_0
??addr_context_lookup_by_prefix_1:
        MOV     A,?V0 + 0
        ADD     A,#0x1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
??addr_context_lookup_by_prefix_0:
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,#0x1
        MOV     A,?V0 + 1
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      $+5
        LJMP    ??addr_context_lookup_by_prefix_2 & 0xFFFF
//  367     if((addr_contexts[i].used == 1) &&
//  368        uip_ipaddr_prefixcmp(&addr_contexts[i].prefix, ipaddr, 64)) {
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     A,R0
        MOV     B,#0xa
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xa
        MOV     A,?V0 + 1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#addr_contexts & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(addr_contexts >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??addr_context_lookup_by_prefix_1
        ; Setup parameters for call to function memcmp
        MOV     ?V0 + 2,#0x8
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R0,?V0 + 0
        MOV     R1,?V0 + 1
        MOV     A,R0
        MOV     B,#0xa
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0xa
        MOV     A,?V0 + 1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#(addr_contexts + 2) & 0xff
        ADD     A,R0
        MOV     R2,A
        MOV     A,#((addr_contexts + 2) >> 8) & 0xff
        ADDC    A,R1
        MOV     R3,A
        LCALL   ??memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JZ      $+5
        LJMP    ??addr_context_lookup_by_prefix_1 & 0xFFFF
//  369       return &addr_contexts[i];
        MOV     A,?V0 + 0
        MOV     B,#0xa
        MUL     AB
        XCH     A,?V0 + 0
        MOV     R0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R0
        MOV     R0,A
        MOV     B,#0xa
        MOV     A,?V0 + 1
        MUL     AB
        ADD     A,R0
        MOV     ?V0 + 1,A
        MOV     A,#addr_contexts & 0xff
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,#(addr_contexts >> 8) & 0xff
        ADDC    A,?V0 + 1
        MOV     R3,A
        SJMP    ??addr_context_lookup_by_prefix_3
//  370     }
//  371   }
//  372 #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 */
//  373   return NULL;
??addr_context_lookup_by_prefix_2:
        MOV     R2,#0x0
        MOV     R3,#0x0
??addr_context_lookup_by_prefix_3:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock3
//  374 }
//  375 /*--------------------------------------------------------------------*/
//  376 /** \brief find the context with the given number */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  377 static struct sicslowpan_addr_context*
//  378 addr_context_lookup_by_number(uint8_t number)
addr_context_lookup_by_number:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function addr_context_lookup_by_number
        CODE
//  379 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  380 /* Remove code to avoid warnings and save flash if no context is used */ 
//  381 #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0
//  382   int i;
//  383   for(i = 0; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
        MOV     R2,#0x0
        MOV     R3,#0x0
        SJMP    ??addr_context_lookup_by_number_0
??addr_context_lookup_by_number_1:
        MOV     A,R2
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R3,A
??addr_context_lookup_by_number_0:
        CLR     C
        MOV     A,R2
        SUBB    A,#0x1
        MOV     A,R3
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??addr_context_lookup_by_number_2
//  384     if((addr_contexts[i].used == 1) &&
//  385        addr_contexts[i].number == number) {
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     A,R4
        MOV     B,#0xa
        MUL     AB
        XCH     A,R4
        MOV     R0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R0
        MOV     R0,A
        MOV     B,#0xa
        MOV     A,R5
        MUL     AB
        ADD     A,R0
        MOV     R5,A
        MOV     A,#addr_contexts & 0xff
        ADD     A,R4
        MOV     DPL,A
        MOV     A,#(addr_contexts >> 8) & 0xff
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??addr_context_lookup_by_number_1
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     A,R4
        MOV     B,#0xa
        MUL     AB
        XCH     A,R4
        MOV     R0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R0
        MOV     R0,A
        MOV     B,#0xa
        MOV     A,R5
        MUL     AB
        ADD     A,R0
        MOV     R5,A
        MOV     A,#(addr_contexts + 1) & 0xff
        ADD     A,R4
        MOV     DPL,A
        MOV     A,#((addr_contexts + 1) >> 8) & 0xff
        ADDC    A,R5
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R1
        JNZ     ??addr_context_lookup_by_number_1
//  386       return &addr_contexts[i];
        MOV     A,R2
        MOV     B,#0xa
        MUL     AB
        XCH     A,R2
        MOV     R0,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R0
        MOV     R0,A
        MOV     B,#0xa
        MOV     A,R3
        MUL     AB
        ADD     A,R0
        MOV     R3,A
        MOV     A,#addr_contexts & 0xff
        ADD     A,R2
        MOV     R2,A
        MOV     A,#(addr_contexts >> 8) & 0xff
        ADDC    A,R3
        MOV     R3,A
        SJMP    ??addr_context_lookup_by_number_3
//  387     }
//  388   }
//  389 #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 */
//  390   return NULL;
??addr_context_lookup_by_number_2:
        MOV     R2,#0x0
        MOV     R3,#0x0
??addr_context_lookup_by_number_3:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock4
//  391 }
//  392 /*--------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  393 static uint8_t
//  394 compress_addr_64(uint8_t bitpos, uip_ipaddr_t *ipaddr, uip_lladdr_t *lladdr)
compress_addr_64:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function compress_addr_64
        CODE
//  395 {
        FUNCALL compress_addr_64, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_addr_64, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
//  396   if(uip_is_addr_mac_addr_based(ipaddr, lladdr)) {
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        MOVX    A,@DPTR
        XRL     A,#0x2
        XRL     A,R0
        JZ      $+5
        LJMP    ??compress_addr_64_0 & 0xFFFF
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JZ      $+5
        LJMP    ??compress_addr_64_0 & 0xFFFF
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JZ      $+5
        LJMP    ??compress_addr_64_0 & 0xFFFF
        MOV     A,R2
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??compress_addr_64_0
        MOV     A,R2
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??compress_addr_64_0
        MOV     A,R2
        ADD     A,#0xd
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??compress_addr_64_0
        MOV     A,R2
        ADD     A,#0xe
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??compress_addr_64_0
        MOV     A,R2
        ADD     A,#0xf
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     DPL,R4
        MOV     DPH,R5
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??compress_addr_64_0
//  397     return 3 << bitpos; /* 0-bits */
        MOV     ?V0 + 0,#0x3
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     R1,?V0 + 0
        LJMP    ??compress_addr_64_1 & 0xFFFF
//  398   } else if(sicslowpan_is_iid_16_bit_compressable(ipaddr)) {
??compress_addr_64_0:
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??compress_addr_64_2 & 0xFFFF
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??compress_addr_64_2
        MOV     A,R2
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??compress_addr_64_2
        MOV     A,R2
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0xfe
        JNZ     ??compress_addr_64_2
        MOV     A,R2
        ADD     A,#0xd
        MOV     DPL,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        JNZ     ??compress_addr_64_2
//  399     /* compress IID to 16 bits xxxx::0000:00ff:fe00:XXXX */
//  400     memcpy(hc06_ptr, &ipaddr->u16[7], 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R2
        ADD     A,#0xe
        MOV     R4,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R5,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
//  401     hc06_ptr += 2;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  402     return 2 << bitpos; /* 16-bits */
        MOV     ?V0 + 0,#0x2
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     R1,?V0 + 0
        SJMP    ??compress_addr_64_1
//  403   } else {
//  404     /* do not compress IID => xxxx::IID */
//  405     memcpy(hc06_ptr, &ipaddr->u16[4], 8);
??compress_addr_64_2:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 0,#0x8
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R2
        ADD     A,#0x8
        MOV     R4,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R5,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
//  406     hc06_ptr += 8;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  407     return 1 << bitpos; /* 64-bits */
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     A,R6
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     R1,?V0 + 0
??compress_addr_64_1:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock5
//  408   }
//  409 }
//  410 
//  411 /*-------------------------------------------------------------------- */
//  412 /* Uncompress addresses based on a prefix and a postfix with zeroes in
//  413  * between. If the postfix is zero in length it will use the link address
//  414  * to configure the IP address (autoconf style).
//  415  * pref_post_count takes a byte where the first nibble specify prefix count
//  416  * and the second postfix count (NOTE: 15/0xf => 16 bytes copy).
//  417  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  418 static void
//  419 uncompress_addr(uip_ipaddr_t *ipaddr, uint8_t const prefix[],
uncompress_addr:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function uncompress_addr
        CODE
//  420                 uint8_t pref_post_count, uip_lladdr_t *lladdr)
//  421 {
        FUNCALL uncompress_addr, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_addr, memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_addr, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_addr, uip_ds6_set_addr_iid
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x14
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 20)
        ; Saved register size: 20
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
        MOV     ?V0 + 4,R1
        MOV     A,#0x14
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 10,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 11,A
//  422   uint8_t prefcount = pref_post_count >> 4;
        MOV     A,?V0 + 4
        SWAP    A
        ANL     A,#0xf
        MOV     ?V0 + 0,A
//  423   uint8_t postcount = pref_post_count & 0x0f;
        MOV     A,#0xf
        ANL     A,?V0 + 4
        MOV     ?V0 + 1,A
//  424   /* full nibble 15 => 16 */
//  425   prefcount = prefcount == 15 ? 16 : prefcount;
        MOV     A,#0xf
        XRL     A,?V0 + 0
        JNZ     ??uncompress_addr_0
        MOV     ?V0 + 2,#0x10
        SJMP    ??uncompress_addr_1
??uncompress_addr_0:
        MOV     ?V0 + 2,?V0 + 0
??uncompress_addr_1:
        MOV     ?V0 + 0,?V0 + 2
//  426   postcount = postcount == 15 ? 16 : postcount;
        MOV     A,#0xf
        XRL     A,?V0 + 1
        JNZ     ??uncompress_addr_2
        MOV     ?V0 + 3,#0x10
        SJMP    ??uncompress_addr_3
??uncompress_addr_2:
        MOV     ?V0 + 3,?V0 + 1
??uncompress_addr_3:
        MOV     ?V0 + 1,?V0 + 3
//  427 
//  428   PRINTF("Uncompressing %d + %d => ", prefcount, postcount);
//  429 
//  430   if(prefcount > 0) {
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0x1
        JC      ??uncompress_addr_4
//  431     memcpy(ipaddr, prefix, prefcount);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 6,?V0 + 0
        MOV     ?V0 + 7,#0x0
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  432   }
//  433   if(prefcount + postcount < 16) {
??uncompress_addr_4:
        MOV     ?V0 + 8,?V0 + 0
        MOV     ?V0 + 9,#0x0
        MOV     ?V0 + 6,?V0 + 1
        MOV     ?V0 + 7,#0x0
        MOV     A,?V0 + 8
        ADD     A,?V0 + 6
        MOV     R0,A
        MOV     A,?V0 + 9
        ADDC    A,?V0 + 7
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,#0x10
        MOV     A,R1
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??uncompress_addr_5
//  434     memset(&ipaddr->u8[prefcount], 0, 16 - (prefcount + postcount));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 6,?V0 + 0
        MOV     ?V0 + 7,#0x0
        MOV     A,#0x10
        CLR     C
        SUBB    A,?V0 + 6
        MOV     R0,A
        MOV     A,#0x0
        SUBB    A,?V0 + 7
        MOV     R1,A
        MOV     ?V0 + 6,?V0 + 1
        MOV     ?V0 + 7,#0x0
        MOV     A,R0
        CLR     C
        SUBB    A,?V0 + 6
        MOV     ?V0 + 6,A
        MOV     A,R1
        SUBB    A,?V0 + 7
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     ?V0 + 6,?V0 + 0
        MOV     ?V0 + 7,#0x0
        MOV     A,R6
        ADD     A,?V0 + 6
        MOV     R2,A
        MOV     A,R7
        ADDC    A,?V0 + 7
        MOV     R3,A
        LCALL   ??memset?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  435   }
//  436   if(postcount > 0) {
??uncompress_addr_5:
        MOV     A,?V0 + 1
        CLR     C
        SUBB    A,#0x1
        JC      ??uncompress_addr_6
//  437     memcpy(&ipaddr->u8[16 - postcount], hc06_ptr, postcount);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 6,?V0 + 1
        MOV     ?V0 + 7,#0x0
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,?V0 + 1
        MOV     R0,?V0 + 1
        MOV     R1,#0x0
        CLR     C
        CLR     A
        SUBB    A,R0
        MOV     R0,A
        CLR     A
        SUBB    A,R1
        MOV     R1,A
        MOV     A,R6
        ADD     A,R0
        MOV     R0,A
        MOV     A,R7
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x10
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  438     if(postcount == 2 && prefcount < 11) {
        MOV     A,#0x2
        XRL     A,?V0 + 1
        JNZ     ??uncompress_addr_7
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0xb
        JNC     ??uncompress_addr_7
//  439       /* 16 bits uncompression => 0000:00ff:fe00:XXXX */
//  440       ipaddr->u8[11] = 0xff;
        MOV     A,R6
        ADD     A,#0xb
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,#-0x1
        MOVX    @DPTR,A
//  441       ipaddr->u8[12] = 0xfe;
        MOV     A,R6
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,#-0x2
        MOVX    @DPTR,A
//  442     }
//  443     hc06_ptr += postcount;
??uncompress_addr_7:
        MOV     A,?V0 + 1
        MOV     R0,?V0 + 1
        MOV     R1,#0x0
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??uncompress_addr_8
//  444   } else if (prefcount > 0) {
??uncompress_addr_6:
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0x1
        JC      ??uncompress_addr_8
//  445     /* no IID based configuration if no prefix and no data => unspec */
//  446     uip_ds6_set_addr_iid(ipaddr, lladdr);
        ; Setup parameters for call to function uip_ds6_set_addr_iid
        MOV     R4,?V0 + 10
        MOV     R5,?V0 + 11
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??uip_ds6_set_addr_iid?relay
//  447   }
//  448 
//  449   PRINT6ADDR(ipaddr);
//  450   PRINTF("\n");
//  451 }
??uncompress_addr_8:
        MOV     R7,#0xc
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock6
//  452 
//  453 /*--------------------------------------------------------------------*/
//  454 /**
//  455  * \brief Compress IP/UDP header
//  456  *
//  457  * This function is called by the 6lowpan code to create a compressed
//  458  * 6lowpan packet in the packetbuf buffer from a full IPv6 packet in the
//  459  * uip_buf buffer.
//  460  *
//  461  *
//  462  * HC-06 (draft-ietf-6lowpan-hc, version 6)\n
//  463  * http://tools.ietf.org/html/draft-ietf-6lowpan-hc-06
//  464  *
//  465  * \note We do not support ISA100_UDP header compression
//  466  *
//  467  * For LOWPAN_UDP compression, we either compress both ports or none.
//  468  * General format with LOWPAN_UDP compression is
//  469  * \verbatim
//  470  *                      1                   2                   3
//  471  *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//  472  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  473  * |0|1|1|TF |N|HLI|C|S|SAM|M|D|DAM| SCI   | DCI   | comp. IPv6 hdr|
//  474  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  475  * | compressed IPv6 fields .....                                  |
//  476  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  477  * | LOWPAN_UDP    | non compressed UDP fields ...                 |
//  478  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  479  * | L4 data ...                                                   |
//  480  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//  481  * \endverbatim
//  482  * \note The context number 00 is reserved for the link local prefix.
//  483  * For unicast addresses, if we cannot compress the prefix, we neither
//  484  * compress the IID.
//  485  * \param rime_destaddr L2 destination address, needed to compress IP
//  486  * dest
//  487  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  488 static void
//  489 compress_hdr_hc06(rimeaddr_t *rime_destaddr)
compress_hdr_hc06:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function compress_hdr_hc06
        CODE
//  490 {
        FUNCALL compress_hdr_hc06, addr_context_lookup_by_prefix
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, addr_context_lookup_by_prefix
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, addr_context_lookup_by_prefix
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, compress_addr_64
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, compress_addr_64
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, addr_context_lookup_by_prefix
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, compress_addr_64
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, compress_addr_64
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL compress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  491   uint8_t tmp, iphc0, iphc1;
//  492 #if DEBUG
//  493   { uint16_t ndx;
//  494     PRINTF("before compression (%d): ", UIP_IP_BUF->len[1]);
//  495     for(ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {
//  496       uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];
//  497       PRINTF("%02x", data);
//  498     }
//  499     PRINTF("\n");
//  500   }
//  501 #endif
//  502 
//  503   hc06_ptr = rime_ptr + 2;
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  504   /*
//  505    * As we copy some bit-length fields, in the IPHC encoding bytes,
//  506    * we sometimes use |=
//  507    * If the field is 0, and the current bit value in memory is 1,
//  508    * this does not work. We therefore reset the IPHC encoding here
//  509    */
//  510 
//  511   iphc0 = SICSLOWPAN_DISPATCH_IPHC;
        MOV     ?V0 + 1,#0x60
//  512   iphc1 = 0;
        MOV     ?V0 + 0,#0x0
//  513   RIME_IPHC_BUF[2] = 0; /* might not be used - but needs to be cleared */
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  514 
//  515   /*
//  516    * Address handling needs to be made first since it might
//  517    * cause an extra byte with [ SCI | DCI ]
//  518    *
//  519    */
//  520 
//  521 
//  522   /* check if dest context exists (for allocating third byte) */
//  523   /* TODO: fix this so that it remembers the looked up values for
//  524      avoiding two lookups - or set the lookup values immediately */
//  525   if(addr_context_lookup_by_prefix(&UIP_IP_BUF->destipaddr) != NULL ||
//  526      addr_context_lookup_by_prefix(&UIP_IP_BUF->srcipaddr) != NULL) {
        ; Setup parameters for call to function addr_context_lookup_by_prefix
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??addr_context_lookup_by_prefix?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JNZ     ??compress_hdr_hc06_0
        ; Setup parameters for call to function addr_context_lookup_by_prefix
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??addr_context_lookup_by_prefix?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JZ      ??compress_hdr_hc06_1
//  527     /* set context flag and increase hc06_ptr */
//  528     PRINTF("IPHC: compressing dest or src ipaddr - setting CID\n");
//  529     iphc1 |= SICSLOWPAN_IPHC_CID;
??compress_hdr_hc06_0:
        SETB    C
        MOV     A,?V0 + 0
        MOV     0xE0 /* A   */.7,C
        MOV     ?V0 + 0,A
//  530     hc06_ptr++;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  531   }
//  532 
//  533   /*
//  534    * Traffic class, flow label
//  535    * If flow label is 0, compress it. If traffic class is 0, compress it
//  536    * We have to process both in the same time as the offset of traffic class
//  537    * depends on the presence of version and flow label
//  538    */
//  539  
//  540   /* hc06 format of tc is ECN | DSCP , original is DSCP | ECN */
//  541   tmp = (UIP_IP_BUF->vtc << 4) | (UIP_IP_BUF->tcflow >> 4);
??compress_hdr_hc06_1:
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf0
        ORL     A,R0
        MOV     ?V0 + 2,A
//  542   tmp = ((tmp & 0x03) << 6) | (tmp >> 2);
        MOV     A,?V0 + 2
        RRC     A
        RRC     A
        ANL     A,#0x3f
        MOV     R0,A
        MOV     A,?V0 + 2
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        ORL     A,R0
        MOV     ?V0 + 2,A
//  543   
//  544   if(((UIP_IP_BUF->tcflow & 0x0F) == 0) &&
//  545      (UIP_IP_BUF->flow == 0)) {
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    A,@DPTR
        ANL     A,#0xf
        JNZ     ??compress_hdr_hc06_2
        MOV     DPTR,#uip_aligned_buf + 2
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_2
//  546     /* flow label can be compressed */
//  547     iphc0 |= SICSLOWPAN_IPHC_FL_C;
        SETB    C
        MOV     A,?V0 + 1
        MOV     0xE0 /* A   */.4,C
        MOV     ?V0 + 1,A
//  548     if(((UIP_IP_BUF->vtc & 0x0F) == 0) &&
//  549        ((UIP_IP_BUF->tcflow & 0xF0) == 0)) {
        MOV     DPTR,#uip_aligned_buf
        MOVX    A,@DPTR
        ANL     A,#0xf
        JNZ     ??compress_hdr_hc06_3
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    A,@DPTR
        ANL     A,#0xf0
        JNZ     ??compress_hdr_hc06_3
//  550       /* compress (elide) all */
//  551       iphc0 |= SICSLOWPAN_IPHC_TC_C;
        SETB    C
        MOV     A,?V0 + 1
        MOV     0xE0 /* A   */.3,C
        MOV     ?V0 + 1,A
        LJMP    ??compress_hdr_hc06_4 & 0xFFFF
//  552     } else {
//  553       /* compress only the flow label */
//  554      *hc06_ptr = tmp;
??compress_hdr_hc06_3:
        MOV     A,?V0 + 2
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
//  555       hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_4 & 0xFFFF
//  556     }
//  557   } else {
//  558     /* Flow label cannot be compressed */
//  559     if(((UIP_IP_BUF->vtc & 0x0F) == 0) &&
//  560        ((UIP_IP_BUF->tcflow & 0xF0) == 0)) {
??compress_hdr_hc06_2:
        MOV     DPTR,#uip_aligned_buf
        MOVX    A,@DPTR
        ANL     A,#0xf
        JNZ     ??compress_hdr_hc06_5
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    A,@DPTR
        ANL     A,#0xf0
        JNZ     ??compress_hdr_hc06_5
//  561       /* compress only traffic class */
//  562       iphc0 |= SICSLOWPAN_IPHC_TC_C;
        SETB    C
        MOV     A,?V0 + 1
        MOV     0xE0 /* A   */.3,C
        MOV     ?V0 + 1,A
//  563       *hc06_ptr = (tmp & 0xc0) |
//  564         (UIP_IP_BUF->tcflow & 0x0F);
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    A,@DPTR
        ANL     A,#0xf
        MOV     R0,A
        MOV     A,#-0x40
        ANL     A,?V0 + 2
        ORL     A,R0
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  565       memcpy(hc06_ptr + 1, &UIP_IP_BUF->flow, 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x2
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 2) & 0xff
        MOV     R5,#((uip_aligned_buf + 2) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  566       hc06_ptr += 3;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??compress_hdr_hc06_4
//  567     } else {
//  568       /* compress nothing */
//  569       memcpy(hc06_ptr, &UIP_IP_BUF->vtc, 4);
??compress_hdr_hc06_5:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x4
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#uip_aligned_buf & 0xff
        MOV     R5,#(uip_aligned_buf >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  570       /* but replace the top byte with the new ECN | DSCP format*/
//  571       *hc06_ptr = tmp;
        MOV     A,?V0 + 2
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
//  572       hc06_ptr += 4;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  573    }
//  574   }
//  575 
//  576   /* Note that the payload length is always compressed */
//  577 
//  578   /* Next header. We compress it if UDP */
//  579 #if UIP_CONF_UDP || UIP_CONF_ROUTER
//  580   if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
??compress_hdr_hc06_4:
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x11
        JNZ     ??compress_hdr_hc06_6
//  581     iphc0 |= SICSLOWPAN_IPHC_NH_C;
        SETB    C
        MOV     A,?V0 + 1
        MOV     0xE0 /* A   */.2,C
        MOV     ?V0 + 1,A
//  582   }
//  583 #endif /*UIP_CONF_UDP*/
//  584 #ifdef SICSLOWPAN_NH_COMPRESSOR 
//  585   if(SICSLOWPAN_NH_COMPRESSOR.is_compressable(UIP_IP_BUF->proto)) {
//  586     iphc0 |= SICSLOWPAN_IPHC_NH_C;
//  587   }
//  588 #endif
//  589   if ((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {
??compress_hdr_hc06_6:
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.2
        JC      ??compress_hdr_hc06_7
//  590     *hc06_ptr = UIP_IP_BUF->proto;
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  591     hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  592   }
//  593 
//  594   /*
//  595    * Hop limit
//  596    * if 1: compress, encoding is 01
//  597    * if 64: compress, encoding is 10
//  598    * if 255: compress, encoding is 11
//  599    * else do not compress
//  600    */
//  601   switch(UIP_IP_BUF->ttl) {
??compress_hdr_hc06_7:
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    A,@DPTR
        DEC     A
        JZ      ??compress_hdr_hc06_8
        ADD     A,#-0x3f
        JZ      ??compress_hdr_hc06_9
        ADD     A,#0x41
        JZ      ??compress_hdr_hc06_10
        SJMP    ??compress_hdr_hc06_11
//  602     case 1:
//  603       iphc0 |= SICSLOWPAN_IPHC_TTL_1;
??compress_hdr_hc06_8:
        SETB    C
        MOV     A,?V0 + 1
        MOV     0xE0 /* A   */.0,C
        MOV     ?V0 + 1,A
//  604       break;
        SJMP    ??compress_hdr_hc06_12
//  605     case 64:
//  606       iphc0 |= SICSLOWPAN_IPHC_TTL_64;
??compress_hdr_hc06_9:
        SETB    C
        MOV     A,?V0 + 1
        MOV     0xE0 /* A   */.1,C
        MOV     ?V0 + 1,A
//  607       break;
        SJMP    ??compress_hdr_hc06_12
//  608     case 255:
//  609       iphc0 |= SICSLOWPAN_IPHC_TTL_255;
??compress_hdr_hc06_10:
        ORL     ?V0 + 1,#0x3
//  610       break;
        SJMP    ??compress_hdr_hc06_12
//  611     default:
//  612       *hc06_ptr = UIP_IP_BUF->ttl;
??compress_hdr_hc06_11:
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  613       hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  614       break;
//  615   }
//  616 
//  617   /* source address - cannot be multicast */
//  618   if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
??compress_hdr_hc06_12:
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 10
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 12
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 14
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 16
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 18
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 20
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
        MOV     DPTR,#uip_aligned_buf + 22
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_13
//  619     PRINTF("IPHC: compressing unspecified - setting SAC\n");
//  620     iphc1 |= SICSLOWPAN_IPHC_SAC;
        SETB    C
        MOV     A,?V0 + 0
        MOV     0xE0 /* A   */.6,C
        MOV     ?V0 + 0,A
//  621     iphc1 |= SICSLOWPAN_IPHC_SAM_00;
        LJMP    ??compress_hdr_hc06_14 & 0xFFFF
//  622   } else if((context = addr_context_lookup_by_prefix(&UIP_IP_BUF->srcipaddr))
//  623      != NULL) {
??compress_hdr_hc06_13:
        ; Setup parameters for call to function addr_context_lookup_by_prefix
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??addr_context_lookup_by_prefix?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
        MOV     DPTR,#context
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??compress_hdr_hc06_15
//  624     /* elide the prefix - indicate by CID and set context + SAC */
//  625     PRINTF("IPHC: compressing src with context - setting CID & SAC ctx: %d\n",
//  626 	   context->number);
//  627     iphc1 |= SICSLOWPAN_IPHC_CID | SICSLOWPAN_IPHC_SAC;
        ORL     ?V0 + 0,#0xc0
//  628     RIME_IPHC_BUF[2] |= context->number << 4;
        MOV     DPTR,#context
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf0
        MOV     R3,A
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,R3
        MOVX    @DPTR,A
//  629     /* compession compare with this nodes address (source) */
//  630 
//  631     iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_SAM_BIT,
//  632                               &UIP_IP_BUF->srcipaddr, &uip_lladdr);
        ; Setup parameters for call to function compress_addr_64
        MOV     R4,#uip_lladdr & 0xff
        MOV     R5,#(uip_lladdr >> 8) & 0xff
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        MOV     R1,#0x4
        LCALL   ??compress_addr_64?relay
        MOV     A,R1
        ORL     ?V0 + 0,A
        SJMP    ??compress_hdr_hc06_14
//  633     /* No context found for this address */
//  634   } else if(uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr) &&
//  635 	    UIP_IP_BUF->destipaddr.u16[1] == 0 &&
//  636 	    UIP_IP_BUF->destipaddr.u16[2] == 0 &&
//  637 	    UIP_IP_BUF->destipaddr.u16[3] == 0) {
??compress_hdr_hc06_15:
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        XRL     A,#0xfe
        JNZ     ??compress_hdr_hc06_16
        MOV     DPTR,#uip_aligned_buf + 9
        MOVX    A,@DPTR
        XRL     A,#0x80
        JNZ     ??compress_hdr_hc06_16
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_16
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_16
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_16
//  638     iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_SAM_BIT,
//  639                               &UIP_IP_BUF->srcipaddr, &uip_lladdr);
        ; Setup parameters for call to function compress_addr_64
        MOV     R4,#uip_lladdr & 0xff
        MOV     R5,#(uip_lladdr >> 8) & 0xff
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        MOV     R1,#0x4
        LCALL   ??compress_addr_64?relay
        MOV     A,R1
        ORL     ?V0 + 0,A
        SJMP    ??compress_hdr_hc06_14
//  640   } else {
//  641     /* send the full address => SAC = 0, SAM = 00 */
//  642     iphc1 |= SICSLOWPAN_IPHC_SAM_00; /* 128-bits */
//  643     memcpy(hc06_ptr, &UIP_IP_BUF->srcipaddr.u16[0], 16);
??compress_hdr_hc06_16:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x10
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 8) & 0xff
        MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  644     hc06_ptr += 16;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x10
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  645   }
//  646 
//  647   /* dest address*/
//  648   if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
??compress_hdr_hc06_14:
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        XRL     A,#0xff
        JZ      $+5
        LJMP    ??compress_hdr_hc06_17 & 0xFFFF
//  649     /* Address is multicast, try to compress */
//  650     iphc1 |= SICSLOWPAN_IPHC_M;
        SETB    C
        MOV     A,?V0 + 0
        MOV     0xE0 /* A   */.3,C
        MOV     ?V0 + 0,A
//  651     if(sicslowpan_is_mcast_addr_compressable8(&UIP_IP_BUF->destipaddr)) {
        MOV     DPTR,#uip_aligned_buf + 25
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 32
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 34
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 36
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_18
        MOV     DPTR,#uip_aligned_buf + 38
        MOVX    A,@DPTR
        JNZ     ??compress_hdr_hc06_18
//  652       iphc1 |= SICSLOWPAN_IPHC_DAM_11;
        ORL     ?V0 + 0,#0x3
//  653       /* use last byte */
//  654       *hc06_ptr = UIP_IP_BUF->destipaddr.u8[15];
        MOV     DPTR,#uip_aligned_buf + 39
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  655       hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_19 & 0xFFFF
//  656     } else if(sicslowpan_is_mcast_addr_compressable32(&UIP_IP_BUF->destipaddr)) {
??compress_hdr_hc06_18:
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??compress_hdr_hc06_20 & 0xFFFF
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_20
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_20
        MOV     DPTR,#uip_aligned_buf + 32
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_20
        MOV     DPTR,#uip_aligned_buf + 34
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_20
        MOV     DPTR,#uip_aligned_buf + 36
        MOVX    A,@DPTR
        JNZ     ??compress_hdr_hc06_20
//  657       iphc1 |= SICSLOWPAN_IPHC_DAM_10;
        SETB    C
        MOV     A,?V0 + 0
        MOV     0xE0 /* A   */.1,C
        MOV     ?V0 + 0,A
//  658       /* second byte + the last three */
//  659       *hc06_ptr = UIP_IP_BUF->destipaddr.u8[1];
        MOV     DPTR,#uip_aligned_buf + 25
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  660       memcpy(hc06_ptr + 1, &UIP_IP_BUF->destipaddr.u8[13], 3);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x3
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 37) & 0xff
        MOV     R5,#((uip_aligned_buf + 37) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  661       hc06_ptr += 4;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_19 & 0xFFFF
//  662     } else if(sicslowpan_is_mcast_addr_compressable48(&UIP_IP_BUF->destipaddr)) {
??compress_hdr_hc06_20:
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_21
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_21
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_21
        MOV     DPTR,#uip_aligned_buf + 32
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_21
        MOV     DPTR,#uip_aligned_buf + 34
        MOVX    A,@DPTR
        JNZ     ??compress_hdr_hc06_21
//  663       iphc1 |= SICSLOWPAN_IPHC_DAM_01;
        SETB    C
        MOV     A,?V0 + 0
        MOV     0xE0 /* A   */.0,C
        MOV     ?V0 + 0,A
//  664       /* second byte + the last five */
//  665       *hc06_ptr = UIP_IP_BUF->destipaddr.u8[1];
        MOV     DPTR,#uip_aligned_buf + 25
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  666       memcpy(hc06_ptr + 1, &UIP_IP_BUF->destipaddr.u8[11], 5);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x5
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 35) & 0xff
        MOV     R5,#((uip_aligned_buf + 35) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  667       hc06_ptr += 6;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x6
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_19 & 0xFFFF
//  668     } else {
//  669       iphc1 |= SICSLOWPAN_IPHC_DAM_00;
//  670       /* full address */
//  671       memcpy(hc06_ptr, &UIP_IP_BUF->destipaddr.u8[0], 16);
??compress_hdr_hc06_21:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x10
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 24) & 0xff
        MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  672       hc06_ptr += 16;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x10
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_19 & 0xFFFF
//  673     }
//  674   } else {
//  675     /* Address is unicast, try to compress */
//  676     if((context = addr_context_lookup_by_prefix(&UIP_IP_BUF->destipaddr)) != NULL) {
??compress_hdr_hc06_17:
        ; Setup parameters for call to function addr_context_lookup_by_prefix
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??addr_context_lookup_by_prefix?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
        MOV     DPTR,#context
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??compress_hdr_hc06_22
//  677       /* elide the prefix */
//  678       iphc1 |= SICSLOWPAN_IPHC_DAC;
        SETB    C
        MOV     A,?V0 + 0
        MOV     0xE0 /* A   */.2,C
        MOV     ?V0 + 0,A
//  679       RIME_IPHC_BUF[2] |= context->number;
        MOV     DPTR,#context
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ORL     A,R3
        MOVX    @DPTR,A
//  680       /* compession compare with link adress (destination) */
//  681 
//  682       iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_DAM_BIT,
//  683 	       &UIP_IP_BUF->destipaddr, (uip_lladdr_t *)rime_destaddr);
        ; Setup parameters for call to function compress_addr_64
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        MOV     R1,#0x0
        LCALL   ??compress_addr_64?relay
        MOV     A,R1
        ORL     ?V0 + 0,A
        SJMP    ??compress_hdr_hc06_19
//  684       /* No context found for this address */
//  685     } else if(uip_is_addr_link_local(&UIP_IP_BUF->destipaddr) &&
//  686 	      UIP_IP_BUF->destipaddr.u16[1] == 0 &&
//  687 	      UIP_IP_BUF->destipaddr.u16[2] == 0 &&
//  688 	      UIP_IP_BUF->destipaddr.u16[3] == 0) {
??compress_hdr_hc06_22:
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        XRL     A,#0xfe
        JNZ     ??compress_hdr_hc06_23
        MOV     DPTR,#uip_aligned_buf + 25
        MOVX    A,@DPTR
        XRL     A,#0x80
        JNZ     ??compress_hdr_hc06_23
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_23
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_23
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??compress_hdr_hc06_23
//  689       iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_DAM_BIT,
//  690                &UIP_IP_BUF->destipaddr, (uip_lladdr_t *)rime_destaddr);
        ; Setup parameters for call to function compress_addr_64
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        MOV     R1,#0x0
        LCALL   ??compress_addr_64?relay
        MOV     A,R1
        ORL     ?V0 + 0,A
        SJMP    ??compress_hdr_hc06_19
//  691     } else {
//  692       /* send the full address */
//  693       iphc1 |= SICSLOWPAN_IPHC_DAM_00; /* 128-bits */
//  694       memcpy(hc06_ptr, &UIP_IP_BUF->destipaddr.u16[0], 16);
??compress_hdr_hc06_23:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x10
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 24) & 0xff
        MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  695       hc06_ptr += 16;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x10
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  696     }
//  697   }
//  698 
//  699   uncomp_hdr_len = UIP_IPH_LEN;
??compress_hdr_hc06_19:
        MOV     DPTR,#uncomp_hdr_len
        MOV     A,#0x28
        MOVX    @DPTR,A
//  700 
//  701 #if UIP_CONF_UDP || UIP_CONF_ROUTER
//  702   /* UDP header compression */
//  703   if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x11
        JZ      $+5
        LJMP    ??compress_hdr_hc06_24 & 0xFFFF
//  704     PRINTF("IPHC: Uncompressed UDP ports on send side: %x, %x\n",
//  705 	   UIP_HTONS(UIP_UDP_BUF->srcport), UIP_HTONS(UIP_UDP_BUF->destport));
//  706     /* Mask out the last 4 bits can be used as a mask */
//  707     if(((UIP_HTONS(UIP_UDP_BUF->srcport) & 0xfff0) == SICSLOWPAN_UDP_4_BIT_PORT_MIN) &&
//  708        ((UIP_HTONS(UIP_UDP_BUF->destport) & 0xfff0) == SICSLOWPAN_UDP_4_BIT_PORT_MIN)) {
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     A
        XCH     A,R2
        MOV     R3,A
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        XCH     A,R1
        MOV     R0,A
        MOV     A,R2
        ORL     A,R0
        MOV     R0,A
        MOV     A,R3
        ORL     A,R1
        MOV     R1,A
        MOV     A,R0
        ANL     A,#0xf0
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0xff
        MOV     R1,A
        MOV     A,#-0x50
        XRL     A,R0
        JNZ     ??compress_hdr_hc06_25
        MOV     A,#-0x10
        XRL     A,R1
??compress_hdr_hc06_25:
        JZ      $+5
        LJMP    ??compress_hdr_hc06_26 & 0xFFFF
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     A
        XCH     A,R2
        MOV     R3,A
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        XCH     A,R1
        MOV     R0,A
        MOV     A,R2
        ORL     A,R0
        MOV     R0,A
        MOV     A,R3
        ORL     A,R1
        MOV     R1,A
        MOV     A,R0
        ANL     A,#0xf0
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0xff
        MOV     R1,A
        MOV     A,#-0x50
        XRL     A,R0
        JNZ     ??compress_hdr_hc06_27
        MOV     A,#-0x10
        XRL     A,R1
??compress_hdr_hc06_27:
        JNZ     ??compress_hdr_hc06_26
//  709       /* we can compress 12 bits of both source and dest */
//  710       *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_11;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0xd
        MOVX    @DPTR,A
//  711       PRINTF("IPHC: remove 12 b of both source & dest with prefix 0xFOB\n");
//  712       *(hc06_ptr + 1) =
//  713 	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->srcport) -
//  714 		SICSLOWPAN_UDP_4_BIT_PORT_MIN) << 4) +
//  715 	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->destport) -
//  716 		SICSLOWPAN_UDP_4_BIT_PORT_MIN));
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        CLR     A
        ORL     A,R0
        ADD     A,#0x50
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
        MOV     A,#0x4
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        MOV     A,?V0 + 2
        ANL     A,#0xf0
        ADD     A,R1
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  717       hc06_ptr += 2;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_28 & 0xFFFF
//  718     } else if((UIP_HTONS(UIP_UDP_BUF->destport) & 0xff00) == SICSLOWPAN_UDP_8_BIT_PORT_MIN) {
??compress_hdr_hc06_26:
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ANL     A,#0xff
        XRL     A,#0xf0
        JNZ     ??compress_hdr_hc06_29
//  719       /* we can compress 8 bits of dest, leave source. */
//  720       *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_01;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0xf
        MOVX    @DPTR,A
//  721       PRINTF("IPHC: leave source, remove 8 bits of dest with prefix 0xF0\n");
//  722       memcpy(hc06_ptr + 1, &UIP_UDP_BUF->srcport, 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x2
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 40) & 0xff
        MOV     R5,#((uip_aligned_buf + 40) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  723       *(hc06_ptr + 3) =
//  724 	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->destport) -
//  725 		SICSLOWPAN_UDP_8_BIT_PORT_MIN));
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        CLR     A
        ORL     A,R0
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  726       hc06_ptr += 4;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??compress_hdr_hc06_28 & 0xFFFF
//  727     } else if((UIP_HTONS(UIP_UDP_BUF->srcport) & 0xff00) == SICSLOWPAN_UDP_8_BIT_PORT_MIN) {
??compress_hdr_hc06_29:
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ANL     A,#0xff
        XRL     A,#0xf0
        JNZ     ??compress_hdr_hc06_30
//  728       /* we can compress 8 bits of src, leave dest. Copy compressed port */
//  729       *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_10;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0xe
        MOVX    @DPTR,A
//  730       PRINTF("IPHC: remove 8 bits of source with prefix 0xF0, leave dest. hch: %i\n", *hc06_ptr);
//  731       *(hc06_ptr + 1) =
//  732 	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->srcport) -
//  733 		SICSLOWPAN_UDP_8_BIT_PORT_MIN));
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        CLR     A
        ORL     A,R0
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  734       memcpy(hc06_ptr + 2, &UIP_UDP_BUF->destport, 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x2
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 42) & 0xff
        MOV     R5,#((uip_aligned_buf + 42) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  735       hc06_ptr += 4;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??compress_hdr_hc06_28
//  736     } else {
//  737       /* we cannot compress. Copy uncompressed ports, full checksum  */
//  738       *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_00;
??compress_hdr_hc06_30:
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOV     A,#-0x10
        MOVX    @DPTR,A
//  739       PRINTF("IPHC: cannot compress headers\n");
//  740       memcpy(hc06_ptr + 1, &UIP_UDP_BUF->srcport, 4);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x4
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 40) & 0xff
        MOV     R5,#((uip_aligned_buf + 40) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  741       hc06_ptr += 5;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x5
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  742     }
//  743     /* always inline the checksum  */
//  744     if(1) {
//  745       memcpy(hc06_ptr, &UIP_UDP_BUF->udpchksum, 2);
??compress_hdr_hc06_28:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x2
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#(uip_aligned_buf + 46) & 0xff
        MOV     R5,#((uip_aligned_buf + 46) >> 8) & 0xff
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  746       hc06_ptr += 2;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  747     }
//  748     uncomp_hdr_len += UIP_UDPH_LEN;
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOVX    @DPTR,A
//  749   }
//  750 #endif /*UIP_CONF_UDP*/
//  751 
//  752 #ifdef SICSLOWPAN_NH_COMPRESSOR
//  753   /* if nothing to compress just return zero  */
//  754   hc06_ptr += SICSLOWPAN_NH_COMPRESSOR.compress(hc06_ptr, &uncomp_hdr_len);
//  755 #endif
//  756 
//  757   /* before the rime_hdr_len operation */
//  758   RIME_IPHC_BUF[0] = iphc0;
??compress_hdr_hc06_24:
        MOV     A,?V0 + 1
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
//  759   RIME_IPHC_BUF[1] = iphc1;
        MOV     A,?V0 + 0
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
//  760 
//  761   rime_hdr_len = hc06_ptr - rime_ptr;
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     DPTR,#rime_hdr_len
        MOVX    @DPTR,A
//  762   return;
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock7
//  763 }
//  764 
//  765 /*--------------------------------------------------------------------*/
//  766 /**
//  767  * \brief Uncompress HC06 (i.e., IPHC and LOWPAN_UDP) headers and put
//  768  * them in sicslowpan_buf
//  769  *
//  770  * This function is called by the input function when the dispatch is
//  771  * HC06.
//  772  * We %process the packet in the rime buffer, uncompress the header
//  773  * fields, and copy the result in the sicslowpan buffer.
//  774  * At the end of the decompression, rime_hdr_len and uncompressed_hdr_len
//  775  * are set to the appropriate values
//  776  *
//  777  * \param ip_len Equal to 0 if the packet is not a fragment (IP length
//  778  * is then inferred from the L2 length), non 0 if the packet is a 1st
//  779  * fragment.
//  780  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  781 static void
//  782 uncompress_hdr_hc06(uint16_t ip_len)
uncompress_hdr_hc06:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function uncompress_hdr_hc06
        CODE
//  783 {
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, addr_context_lookup_by_number
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, packetbuf_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, uncompress_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, packetbuf_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, uncompress_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, uncompress_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, addr_context_lookup_by_number
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, packetbuf_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, uncompress_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, packetbuf_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, uncompress_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, packetbuf_datalen
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uncompress_hdr_hc06, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 22, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 22, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  784   uint8_t tmp, iphc0, iphc1;
//  785   /* at least two byte will be used for the encoding */
//  786   hc06_ptr = rime_ptr + rime_hdr_len + 2;
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOV     R0,DPL
        MOV     R1,DPH
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  787 
//  788   iphc0 = RIME_IPHC_BUF[0];
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0 + 1,A
//  789   iphc1 = RIME_IPHC_BUF[1];
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
//  790 
//  791   /* another if the CID flag is set */
//  792   if(iphc1 & SICSLOWPAN_IPHC_CID) {
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.7
        JNC     ??uncompress_hdr_hc06_0
//  793     PRINTF("IPHC: CID flag set - increase header with one\n");
//  794     hc06_ptr++;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  795   }
//  796 
//  797   /* Traffic class and flow label */
//  798     if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {
??uncompress_hdr_hc06_0:
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.4
        JNC     $+5
        LJMP    ??uncompress_hdr_hc06_1 & 0xFFFF
//  799       /* Flow label are carried inline */
//  800       if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.3
        JC      ??uncompress_hdr_hc06_2
//  801         /* Traffic class is carried inline */
//  802         memcpy(&SICSLOWPAN_IP_BUF->tcflow, hc06_ptr + 1, 3);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x3
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 1) & 0xff
        MOV     R3,#((uip_aligned_buf + 1) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  803         tmp = *hc06_ptr;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
//  804         hc06_ptr += 4;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  805         /* hc06 format of tc is ECN | DSCP , original is DSCP | ECN */
//  806         /* set version, pick highest DSCP bits and set in vtc */
//  807         SICSLOWPAN_IP_BUF->vtc = 0x60 | ((tmp >> 2) & 0x0f);
        MOV     A,?V0 + 4
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0xf
        ORL     A,#0x60
        MOV     DPTR,#uip_aligned_buf
        MOVX    @DPTR,A
//  808         /* ECN rolled down two steps + lowest DSCP bits at top two bits */
//  809         SICSLOWPAN_IP_BUF->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |
//  810   	(SICSLOWPAN_IP_BUF->tcflow & 0x0f);
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    A,@DPTR
        ANL     A,#0xf
        MOV     R1,A
        MOV     A,?V0 + 4
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        MOV     R0,A
        MOV     A,?V0 + 4
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x30
        ORL     A,R0
        ORL     A,R1
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    @DPTR,A
        LJMP    ??uncompress_hdr_hc06_3 & 0xFFFF
//  811       } else {
//  812         /* Traffic class is compressed (set version and no TC)*/
//  813         SICSLOWPAN_IP_BUF->vtc = 0x60;
??uncompress_hdr_hc06_2:
        MOV     DPTR,#uip_aligned_buf
        MOV     A,#0x60
        MOVX    @DPTR,A
//  814         /* highest flow label bits + ECN bits */
//  815         SICSLOWPAN_IP_BUF->tcflow = (*hc06_ptr & 0x0F) |
//  816   	((*hc06_ptr >> 2) & 0x30);
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x30
        MOV     R0,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R1
        MOVX    A,@DPTR
        ANL     A,#0xf
        ORL     A,R0
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    @DPTR,A
//  817         memcpy(&SICSLOWPAN_IP_BUF->flow, hc06_ptr + 1, 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x2
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 2) & 0xff
        MOV     R3,#((uip_aligned_buf + 2) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  818         hc06_ptr += 3;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??uncompress_hdr_hc06_3
//  819       }
//  820     } else {
//  821       /* Version is always 6! */
//  822       /* Version and flow label are compressed */
//  823       if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {
??uncompress_hdr_hc06_1:
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.3
        JC      ??uncompress_hdr_hc06_4
//  824         /* Traffic class is inline */
//  825           SICSLOWPAN_IP_BUF->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0xf
        ORL     A,#0x60
        MOV     DPTR,#uip_aligned_buf
        MOVX    @DPTR,A
//  826           SICSLOWPAN_IP_BUF->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        RRC     A
        RRC     A
        ANL     A,#0x3f
        ANL     A,#0x30
        MOV     R0,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R1
        MOVX    A,@DPTR
        SWAP    A
        RLC     A
        RLC     A
        ANL     A,#0xc0
        ORL     A,R0
        MOV     DPTR,#uip_aligned_buf + 1
        MOVX    @DPTR,A
//  827           SICSLOWPAN_IP_BUF->flow = 0;
        MOV     DPTR,#uip_aligned_buf + 2
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  828           hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        SJMP    ??uncompress_hdr_hc06_3
//  829       } else {
//  830         /* Traffic class is compressed */
//  831         SICSLOWPAN_IP_BUF->vtc = 0x60;
??uncompress_hdr_hc06_4:
        MOV     DPTR,#uip_aligned_buf
        MOV     A,#0x60
        MOVX    @DPTR,A
//  832         SICSLOWPAN_IP_BUF->tcflow = 0;
        MOV     DPTR,#uip_aligned_buf + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
//  833         SICSLOWPAN_IP_BUF->flow = 0;
        MOV     DPTR,#uip_aligned_buf + 2
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  834       }
//  835     }
//  836 
//  837   /* Next Header */
//  838   if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {
??uncompress_hdr_hc06_3:
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.2
        JC      ??uncompress_hdr_hc06_5
//  839     /* Next header is carried inline */
//  840     SICSLOWPAN_IP_BUF->proto = *hc06_ptr;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    @DPTR,A
//  841     PRINTF("IPHC: next header inline: %d\n", SICSLOWPAN_IP_BUF->proto);
//  842     hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  843   }
//  844 
//  845   /* Hop limit */
//  846   if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {
??uncompress_hdr_hc06_5:
        MOV     A,#0x3
        ANL     A,?V0 + 1
        JZ      ??uncompress_hdr_hc06_6
//  847     SICSLOWPAN_IP_BUF->ttl = ttl_values[iphc0 & 0x03];
        MOV     ?V0 + 2,?V0 + 1
        MOV     ?V0 + 3,#0x0
        MOV     A,?V0 + 2
        ANL     A,#0x3
        MOV     R0,A
        MOV     A,?V0 + 3
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,#ttl_values & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#(ttl_values >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    @DPTR,A
        SJMP    ??uncompress_hdr_hc06_7
//  848   } else {
//  849     SICSLOWPAN_IP_BUF->ttl = *hc06_ptr;
??uncompress_hdr_hc06_6:
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    @DPTR,A
//  850     hc06_ptr += 1;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  851   }
//  852 
//  853   /* put the source address compression mode SAM in the tmp var */
//  854   tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;
??uncompress_hdr_hc06_7:
        MOV     A,?V0 + 0
        SWAP    A
        ANL     A,#0xf
        ANL     A,#0x3
        MOV     ?V0 + 4,A
//  855 
//  856   /* context based compression */
//  857   if(iphc1 & SICSLOWPAN_IPHC_SAC) {
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.6
        JC      $+5
        LJMP    ??uncompress_hdr_hc06_8 & 0xFFFF
//  858     uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?
//  859       RIME_IPHC_BUF[2] >> 4 : 0;
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.7
        JNC     ??uncompress_hdr_hc06_9
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        SJMP    ??uncompress_hdr_hc06_10
??uncompress_hdr_hc06_9:
        MOV     A,#0x0
??uncompress_hdr_hc06_10:
        MOV     ?V0 + 2,A
//  860 
//  861     /* Source address - check context != NULL only if SAM bits are != 0*/
//  862     if (tmp != 0) {
        MOV     A,?V0 + 4
        JZ      ??uncompress_hdr_hc06_11
//  863       context = addr_context_lookup_by_number(sci);
        ; Setup parameters for call to function addr_context_lookup_by_number
        MOV     R1,?V0 + 2
        LCALL   ??addr_context_lookup_by_number?relay
        MOV     DPTR,#context
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  864       if(context == NULL) {
        MOV     DPTR,#context
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??uncompress_hdr_hc06_12 & 0xFFFF
//  865         PRINTF("sicslowpan uncompress_hdr: error context not found\n");
//  866         return;
//  867       }
//  868     }
//  869     /* if tmp == 0 we do not have a context and therefore no prefix */
//  870     uncompress_addr(&SICSLOWPAN_IP_BUF->srcipaddr,
//  871                     tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],
//  872                     (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
??uncompress_hdr_hc06_11:
        ; Setup parameters for call to function packetbuf_addr
        MOV     R1,#0x18
        LCALL   ??packetbuf_addr?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 6,?V0 + 8
        MOV     ?V0 + 7,?V0 + 9
        MOV     A,?V0 + 4
        JZ      ??uncompress_hdr_hc06_13
        MOV     DPTR,#context
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        SJMP    ??uncompress_hdr_hc06_14
??uncompress_hdr_hc06_13:
        MOV     R4,#0x0
        MOV     R5,#0x0
??uncompress_hdr_hc06_14:
        ; Setup parameters for call to function uncompress_addr
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 5,#0x0
        MOV     A,#unc_ctxconf & 0xff
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,#(unc_ctxconf >> 8) & 0xff
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??uncompress_addr?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        SJMP    ??uncompress_hdr_hc06_15
//  873   } else {
//  874     /* no compression and link local */
//  875     uncompress_addr(&SICSLOWPAN_IP_BUF->srcipaddr, llprefix, unc_llconf[tmp],
//  876                     (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
??uncompress_hdr_hc06_8:
        ; Setup parameters for call to function packetbuf_addr
        MOV     R1,#0x18
        LCALL   ??packetbuf_addr?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 6,?V0 + 8
        MOV     ?V0 + 7,?V0 + 9
        ; Setup parameters for call to function uncompress_addr
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 5,#0x0
        MOV     A,#unc_llconf & 0xff
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,#(unc_llconf >> 8) & 0xff
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     R4,#llprefix & 0xff
        MOV     R5,#(llprefix >> 8) & 0xff
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??uncompress_addr?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  877   }
//  878 
//  879   /* Destination address */
//  880   /* put the destination address compression mode into tmp */
//  881   tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;
??uncompress_hdr_hc06_15:
        MOV     A,#0x3
        ANL     A,?V0 + 0
        MOV     ?V0 + 4,A
//  882 
//  883   /* multicast compression */
//  884   if(iphc1 & SICSLOWPAN_IPHC_M) {
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.3
        JC      $+5
        LJMP    ??uncompress_hdr_hc06_16 & 0xFFFF
//  885     /* context based multicast compression */
//  886     if(iphc1 & SICSLOWPAN_IPHC_DAC) {
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.2
        JNC     $+5
        LJMP    ??uncompress_hdr_hc06_17 & 0xFFFF
//  887       /* TODO: implement this */
//  888     } else {
//  889       /* non-context based multicast compression - */
//  890       /* DAM_00: 128 bits  */
//  891       /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */
//  892       /* DAM_10:  32 bits FFXX::00XX:XXXX */
//  893       /* DAM_11:   8 bits FF02::00XX */
//  894       uint8_t prefix[] = {0xff, 0x02};
        MOV     DPTR,#`?<Constant {255, 2}>`
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R4,DPL
        MOV     R5,DPH
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        MOV     A,#0x2
        LCALL   ?MOVE_LONG8_XDATA_XDATA
//  895       if(tmp > 0 && tmp < 3) {
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,#0x1
        CLR     C
        SUBB    A,#0x2
        JNC     ??uncompress_hdr_hc06_18
//  896         prefix[1] = *hc06_ptr;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,#0x1
        LCALL   ?XSTACK_DISP0_8
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  897         hc06_ptr++;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  898       }
//  899 
//  900       uncompress_addr(&SICSLOWPAN_IP_BUF->destipaddr, prefix,
//  901                       unc_mxconf[tmp], NULL);
??uncompress_hdr_hc06_18:
        ; Setup parameters for call to function uncompress_addr
        CLR     A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 5,#0x0
        MOV     A,#unc_mxconf & 0xff
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,#(unc_mxconf >> 8) & 0xff
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,#0x2
        LCALL   ?XSTACK_DISP0_8
        MOV     R4,DPL
        MOV     R5,DPH
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??uncompress_addr?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        LJMP    ??uncompress_hdr_hc06_17 & 0xFFFF
//  902     }
//  903   } else {
//  904     /* no multicast */
//  905     /* Context based */
//  906     if(iphc1 & SICSLOWPAN_IPHC_DAC) {
??uncompress_hdr_hc06_16:
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.2
        JC      $+5
        LJMP    ??uncompress_hdr_hc06_19 & 0xFFFF
//  907       uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ?
//  908 	RIME_IPHC_BUF[2] & 0x0f : 0;
        MOV     A,?V0 + 0
        MOV     C,0xE0 /* A   */.7
        JNC     ??uncompress_hdr_hc06_20
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        ANL     A,#0xf
        SJMP    ??uncompress_hdr_hc06_21
??uncompress_hdr_hc06_20:
        MOV     A,#0x0
??uncompress_hdr_hc06_21:
        MOV     ?V0 + 0,A
//  909       context = addr_context_lookup_by_number(dci);
        ; Setup parameters for call to function addr_context_lookup_by_number
        MOV     R1,?V0 + 0
        LCALL   ??addr_context_lookup_by_number?relay
        MOV     DPTR,#context
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  910 
//  911       /* all valid cases below need the context! */
//  912       if(context == NULL) {
        MOV     DPTR,#context
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??uncompress_hdr_hc06_12 & 0xFFFF
//  913 	PRINTF("sicslowpan uncompress_hdr: error context not found\n");
//  914 	return;
//  915       }
//  916       uncompress_addr(&SICSLOWPAN_IP_BUF->destipaddr, context->prefix,
//  917                       unc_ctxconf[tmp],
//  918                       (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
        ; Setup parameters for call to function packetbuf_addr
        MOV     R1,#0x19
        LCALL   ??packetbuf_addr?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 6,?V0 + 8
        MOV     ?V0 + 7,?V0 + 9
        ; Setup parameters for call to function uncompress_addr
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 5,#0x0
        MOV     A,#unc_ctxconf & 0xff
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,#(unc_ctxconf >> 8) & 0xff
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#context
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??uncompress_addr?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        SJMP    ??uncompress_hdr_hc06_17
//  919     } else {
//  920       /* not context based => link local M = 0, DAC = 0 - same as SAC */
//  921       uncompress_addr(&SICSLOWPAN_IP_BUF->destipaddr, llprefix,
//  922                       unc_llconf[tmp],
//  923                       (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
??uncompress_hdr_hc06_19:
        ; Setup parameters for call to function packetbuf_addr
        MOV     R1,#0x19
        LCALL   ??packetbuf_addr?relay
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 6,?V0 + 8
        MOV     ?V0 + 7,?V0 + 9
        ; Setup parameters for call to function uncompress_addr
        MOV     R0,#?V0 + 6
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     ?V0 + 5,#0x0
        MOV     A,#unc_llconf & 0xff
        ADD     A,?V0 + 4
        MOV     DPL,A
        MOV     A,#(unc_llconf >> 8) & 0xff
        ADDC    A,?V0 + 5
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     R4,#llprefix & 0xff
        MOV     R5,#(llprefix >> 8) & 0xff
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??uncompress_addr?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  924     }
//  925   }
//  926   uncomp_hdr_len += UIP_IPH_LEN;
??uncompress_hdr_hc06_17:
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        ADD     A,#0x28
        MOVX    @DPTR,A
//  927 
//  928   /* Next header processing - continued */
//  929   if((iphc0 & SICSLOWPAN_IPHC_NH_C)) {
        MOV     A,?V0 + 1
        MOV     C,0xE0 /* A   */.2
        JC      $+5
        LJMP    ??uncompress_hdr_hc06_22 & 0xFFFF
//  930     /* The next header is compressed, NHC is following */
//  931     if((*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        ANL     A,#0xf8
        XRL     A,#0xf0
        JZ      $+5
        LJMP    ??uncompress_hdr_hc06_22 & 0xFFFF
//  932       uint8_t checksum_compressed;
//  933       SICSLOWPAN_IP_BUF->proto = UIP_PROTO_UDP;
        MOV     DPTR,#uip_aligned_buf + 6
        MOV     A,#0x11
        MOVX    @DPTR,A
//  934       checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        ANL     A,#0x4
        MOV     ?V0 + 1,A
//  935       PRINTF("IPHC: Incoming header value: %i\n", *hc06_ptr);
//  936       switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0xf3
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x10
        JZ      ??uncompress_hdr_hc06_23
        DEC     A
        JNZ     $+5
        LJMP    ??uncompress_hdr_hc06_24 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uncompress_hdr_hc06_25 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uncompress_hdr_hc06_26 & 0xFFFF
        LJMP    ??uncompress_hdr_hc06_12 & 0xFFFF
//  937       case SICSLOWPAN_NHC_UDP_CS_P_00:
//  938 	/* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */
//  939 	memcpy(&SICSLOWPAN_UDP_BUF->srcport, hc06_ptr + 1, 2);
??uncompress_hdr_hc06_23:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x2
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 40) & 0xff
        MOV     R3,#((uip_aligned_buf + 40) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  940 	memcpy(&SICSLOWPAN_UDP_BUF->destport, hc06_ptr + 3, 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x2
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x3
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 42) & 0xff
        MOV     R3,#((uip_aligned_buf + 42) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  941 	PRINTF("IPHC: Uncompressed UDP ports (ptr+5): %x, %x\n",
//  942 	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
//  943 	hc06_ptr += 5;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x5
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  944 	break;
//  945 
//  946       case SICSLOWPAN_NHC_UDP_CS_P_01:
//  947         /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */
//  948 	PRINTF("IPHC: Decompressing destination\n");
//  949 	memcpy(&SICSLOWPAN_UDP_BUF->srcport, hc06_ptr + 1, 2);
//  950 	SICSLOWPAN_UDP_BUF->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));
//  951 	PRINTF("IPHC: Uncompressed UDP ports (ptr+4): %x, %x\n",
//  952 	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
//  953 	hc06_ptr += 4;
//  954 	break;
//  955 
//  956       case SICSLOWPAN_NHC_UDP_CS_P_10:
//  957         /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/
//  958 	PRINTF("IPHC: Decompressing source\n");
//  959 	SICSLOWPAN_UDP_BUF->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +
//  960 					    (*(hc06_ptr + 1)));
//  961 	memcpy(&SICSLOWPAN_UDP_BUF->destport, hc06_ptr + 2, 2);
//  962 	PRINTF("IPHC: Uncompressed UDP ports (ptr+4): %x, %x\n",
//  963 	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
//  964 	hc06_ptr += 4;
//  965 	break;
//  966 
//  967       case SICSLOWPAN_NHC_UDP_CS_P_11:
//  968 	/* 1 byte for NHC, 1 byte for ports */
//  969 	SICSLOWPAN_UDP_BUF->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +
//  970 					    (*(hc06_ptr + 1) >> 4));
//  971 	SICSLOWPAN_UDP_BUF->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +
//  972 					     ((*(hc06_ptr + 1)) & 0x0F));
//  973 	PRINTF("IPHC: Uncompressed UDP ports (ptr+2): %x, %x\n",
//  974 	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
//  975 	hc06_ptr += 2;
//  976 	break;
//  977 
//  978       default:
//  979 	PRINTF("sicslowpan uncompress_hdr: error unsupported UDP compression\n");
//  980 	return;
//  981       }
//  982       if(!checksum_compressed) { /* has_checksum, default  */
??uncompress_hdr_hc06_27:
        MOV     A,?V0 + 1
        JNZ     ??uncompress_hdr_hc06_28
//  983 	memcpy(&SICSLOWPAN_UDP_BUF->udpchksum, hc06_ptr, 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x2
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 46) & 0xff
        MOV     R3,#((uip_aligned_buf + 46) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
//  984 	hc06_ptr += 2;
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  985 	PRINTF("IPHC: sicslowpan uncompress_hdr: checksum included\n");
//  986       } else {
//  987 	PRINTF("IPHC: sicslowpan uncompress_hdr: checksum *NOT* included\n");
//  988       }
//  989       uncomp_hdr_len += UIP_UDPH_LEN;
??uncompress_hdr_hc06_28:
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOVX    @DPTR,A
//  990     }
//  991 #ifdef SICSLOWPAN_NH_COMPRESSOR
//  992     else {
//  993       hc06_ptr += SICSLOWPAN_NH_COMPRESSOR.uncompress(hc06_ptr, sicslowpan_buf, &uncomp_hdr_len);
//  994     }
//  995 #endif
//  996   }
//  997 
//  998   rime_hdr_len = hc06_ptr - rime_ptr;
??uncompress_hdr_hc06_22:
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     DPTR,#rime_hdr_len
        MOVX    @DPTR,A
//  999   
// 1000   /* IP length field. */
// 1001   if(ip_len == 0) {
        MOV     A,R6
        ORL     A,R7
        JZ      $+5
        LJMP    ??uncompress_hdr_hc06_29 & 0xFFFF
// 1002     /* This is not a fragmented packet */
// 1003     SICSLOWPAN_IP_BUF->len[0] = 0;
        MOV     DPTR,#uip_aligned_buf + 4
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1004     SICSLOWPAN_IP_BUF->len[1] = packetbuf_datalen() - rime_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;
        ; Setup parameters for call to function packetbuf_datalen
        LCALL   ??packetbuf_datalen?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     R0,?V0 + 4
        MOV     R1,?V0 + 5
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R2
        ADD     A,R3
        ADD     A,#-0x28
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    @DPTR,A
        LJMP    ??uncompress_hdr_hc06_30 & 0xFFFF
// 1005   } else {
??uncompress_hdr_hc06_24:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x2
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 40) & 0xff
        MOV     R3,#((uip_aligned_buf + 40) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ORL     A,#0xf0
        MOV     R0,A
        MOV     A,R1
        ORL     A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 42
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??uncompress_hdr_hc06_27 & 0xFFFF
??uncompress_hdr_hc06_25:
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ORL     A,#0xf0
        MOV     R0,A
        MOV     A,R1
        ORL     A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 40
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x2
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 42) & 0xff
        MOV     R3,#((uip_aligned_buf + 42) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x4
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??uncompress_hdr_hc06_27 & 0xFFFF
??uncompress_hdr_hc06_26:
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        SWAP    A
        ANL     A,#0xf
        MOV     R0,A
        MOV     R1,#0x0
        ADD     A,#-0x50
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x10
        MOV     R1,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ORL     A,#0xf0
        MOV     R0,A
        MOV     A,R1
        ORL     A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 40
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0xf
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x50
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#-0x10
        MOV     R1,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R0
        ORL     A,#0xf0
        MOV     R0,A
        MOV     A,R1
        ORL     A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 42
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#hc06_ptr
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#hc06_ptr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        LJMP    ??uncompress_hdr_hc06_27 & 0xFFFF
// 1006     /* This is a 1st fragment */
// 1007     SICSLOWPAN_IP_BUF->len[0] = (ip_len - UIP_IPH_LEN) >> 8;
??uncompress_hdr_hc06_29:
        MOV     A,R6
        ADD     A,#-0x28
        MOV     R0,A
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf + 4
        MOVX    @DPTR,A
// 1008     SICSLOWPAN_IP_BUF->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;
        MOV     A,R6
        ADD     A,#-0x28
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    @DPTR,A
// 1009   }
// 1010   
// 1011   /* length field in UDP header */
// 1012   if(SICSLOWPAN_IP_BUF->proto == UIP_PROTO_UDP) {
??uncompress_hdr_hc06_30:
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x11
        JNZ     ??uncompress_hdr_hc06_12
// 1013     memcpy(&SICSLOWPAN_UDP_BUF->udplen, &SICSLOWPAN_IP_BUF->len[0], 2);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 4,#0x2
        MOV     ?V0 + 5,#0x0
        MOV     R0,#?V0 + 4
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 22)
        MOV     R4,#(uip_aligned_buf + 4) & 0xff
        MOV     R5,#((uip_aligned_buf + 4) >> 8) & 0xff
        MOV     R2,#(uip_aligned_buf + 44) & 0xff
        MOV     R3,#((uip_aligned_buf + 44) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 20)
// 1014   }
// 1015 
// 1016   return;
??uncompress_hdr_hc06_12:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 18)
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock8
// 1017 }
// 1018 /** @} */
// 1019 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
// 1020 
// 1021 
// 1022 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1
// 1023 /*--------------------------------------------------------------------*/
// 1024 /** \name HC1 compression and uncompression functions
// 1025  *  @{                                                                */
// 1026 /*--------------------------------------------------------------------*/
// 1027 /**
// 1028  * \brief Compress IP/UDP header using HC1 and HC_UDP
// 1029  *
// 1030  * This function is called by the 6lowpan code to create a compressed
// 1031  * 6lowpan packet in the packetbuf buffer from a full IPv6 packet in the
// 1032  * uip_buf buffer.
// 1033  *
// 1034  *
// 1035  * If we can compress everything, we use HC1 dispatch, if not we use
// 1036  * IPv6 dispatch.\n
// 1037  * We can compress everything if:
// 1038  *   - IP version is
// 1039  *   - Flow label and traffic class are 0
// 1040  *   - Both src and dest ip addresses are link local
// 1041  *   - Both src and dest interface ID are recoverable from lower layer
// 1042  *     header
// 1043  *   - Next header is either ICMP, UDP or TCP
// 1044  * Moreover, if next header is UDP, we try to compress it using HC_UDP.
// 1045  * This is feasible is both ports are between F0B0 and F0B0 + 15\n\n
// 1046  *
// 1047  * Resulting header structure:
// 1048  * - For ICMP, TCP, non compressed UDP\n
// 1049  *   HC1 encoding = 11111010 (UDP) 11111110 (TCP) 11111100 (ICMP)\n
// 1050  * \verbatim
// 1051  *                      1                   2                   3
// 1052  * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
// 1053  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1054  * | LoWPAN HC1 Dsp | HC1 encoding  | IPv6 Hop limit| L4 hdr + data|
// 1055  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1056  * | ...
// 1057  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1058  * \endverbatim
// 1059  *
// 1060  * - For compressed UDP
// 1061  *   HC1 encoding = 11111011, HC_UDP encoding = 11100000\n
// 1062  * \verbatim
// 1063  *                      1                   2                   3
// 1064  * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
// 1065  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1066  * | LoWPAN HC1 Dsp| HC1 encoding  |  HC_UDP encod.| IPv6 Hop limit|
// 1067  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1068  * | src p.| dst p.| UDP checksum                  | L4 data...
// 1069  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1070  * \endverbatim
// 1071  *
// 1072  * \param rime_destaddr L2 destination address, needed to compress the
// 1073  * IP destination field
// 1074  */
// 1075 static void
// 1076 compress_hdr_hc1(rimeaddr_t *rime_destaddr)
// 1077 {
// 1078   /*
// 1079    * Check if all the assumptions for full compression
// 1080    * are valid :
// 1081    */
// 1082   if(UIP_IP_BUF->vtc != 0x60 ||
// 1083      UIP_IP_BUF->tcflow != 0 ||
// 1084      UIP_IP_BUF->flow != 0 ||
// 1085      !uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr) ||
// 1086      !uip_is_addr_mac_addr_based(&UIP_IP_BUF->srcipaddr, &uip_lladdr) ||
// 1087      !uip_is_addr_link_local(&UIP_IP_BUF->destipaddr) ||
// 1088      !uip_is_addr_mac_addr_based(&UIP_IP_BUF->destipaddr,
// 1089                                  (uip_lladdr_t *)rime_destaddr) ||
// 1090      (UIP_IP_BUF->proto != UIP_PROTO_ICMP6 &&
// 1091       UIP_IP_BUF->proto != UIP_PROTO_UDP &&
// 1092       UIP_IP_BUF->proto != UIP_PROTO_TCP))
// 1093   {
// 1094     /*
// 1095      * IPV6 DISPATCH
// 1096      * Something cannot be compressed, use IPV6 DISPATCH,
// 1097      * compress nothing, copy IPv6 header in rime buffer
// 1098      */
// 1099     *rime_ptr = SICSLOWPAN_DISPATCH_IPV6;
// 1100     rime_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
// 1101     memcpy(rime_ptr + rime_hdr_len, UIP_IP_BUF, UIP_IPH_LEN);
// 1102     rime_hdr_len += UIP_IPH_LEN;
// 1103     uncomp_hdr_len += UIP_IPH_LEN;
// 1104   } else {
// 1105     /*
// 1106      * HC1 DISPATCH
// 1107      * maximum compresssion:
// 1108      * All fields in the IP header but Hop Limit are elided
// 1109      * If next header is UDP, we compress UDP header using HC2
// 1110      */
// 1111     RIME_HC1_PTR[RIME_HC1_DISPATCH] = SICSLOWPAN_DISPATCH_HC1;
// 1112     uncomp_hdr_len += UIP_IPH_LEN;
// 1113     switch(UIP_IP_BUF->proto) {
// 1114       case UIP_PROTO_ICMP6:
// 1115         /* HC1 encoding and ttl */
// 1116         RIME_HC1_PTR[RIME_HC1_ENCODING] = 0xFC;
// 1117         RIME_HC1_PTR[RIME_HC1_TTL] = UIP_IP_BUF->ttl;
// 1118         rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
// 1119         break;
// 1120 #if UIP_CONF_TCP
// 1121       case UIP_PROTO_TCP:
// 1122         /* HC1 encoding and ttl */
// 1123         RIME_HC1_PTR[RIME_HC1_ENCODING] = 0xFE;
// 1124         RIME_HC1_PTR[RIME_HC1_TTL] = UIP_IP_BUF->ttl;
// 1125         rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
// 1126         break;
// 1127 #endif /* UIP_CONF_TCP */
// 1128 #if UIP_CONF_UDP
// 1129       case UIP_PROTO_UDP:
// 1130         /*
// 1131          * try to compress UDP header (we do only full compression).
// 1132          * This is feasible if both src and dest ports are between
// 1133          * SICSLOWPAN_UDP_PORT_MIN and SICSLOWPAN_UDP_PORT_MIN + 15
// 1134          */
// 1135         PRINTF("local/remote port %u/%u\n",UIP_UDP_BUF->srcport,UIP_UDP_BUF->destport);
// 1136         if(UIP_HTONS(UIP_UDP_BUF->srcport)  >= SICSLOWPAN_UDP_PORT_MIN &&
// 1137            UIP_HTONS(UIP_UDP_BUF->srcport)  <  SICSLOWPAN_UDP_PORT_MAX &&
// 1138            UIP_HTONS(UIP_UDP_BUF->destport) >= SICSLOWPAN_UDP_PORT_MIN &&
// 1139            UIP_HTONS(UIP_UDP_BUF->destport) <  SICSLOWPAN_UDP_PORT_MAX) {
// 1140           /* HC1 encoding */
// 1141           RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_HC1_ENCODING] = 0xFB;
// 1142         
// 1143           /* HC_UDP encoding, ttl, src and dest ports, checksum */
// 1144           RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_UDP_ENCODING] = 0xE0;
// 1145           RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_TTL] = UIP_IP_BUF->ttl;
// 1146 
// 1147           RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_PORTS] =
// 1148                (uint8_t)((UIP_HTONS(UIP_UDP_BUF->srcport) -
// 1149                        SICSLOWPAN_UDP_PORT_MIN) << 4) +
// 1150                (uint8_t)((UIP_HTONS(UIP_UDP_BUF->destport) - SICSLOWPAN_UDP_PORT_MIN));
// 1151           memcpy(&RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_CHKSUM], &UIP_UDP_BUF->udpchksum, 2);
// 1152           rime_hdr_len += SICSLOWPAN_HC1_HC_UDP_HDR_LEN;
// 1153           uncomp_hdr_len += UIP_UDPH_LEN;
// 1154         } else {
// 1155           /* HC1 encoding and ttl */
// 1156           RIME_HC1_PTR[RIME_HC1_ENCODING] = 0xFA;
// 1157           RIME_HC1_PTR[RIME_HC1_TTL] = UIP_IP_BUF->ttl;
// 1158           rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
// 1159         }
// 1160         break;
// 1161 #endif /*UIP_CONF_UDP*/
// 1162     }
// 1163   }
// 1164   return;
// 1165 }
// 1166 
// 1167 /*--------------------------------------------------------------------*/
// 1168 /**
// 1169  * \brief Uncompress HC1 (and HC_UDP) headers and put them in
// 1170  * sicslowpan_buf
// 1171  *
// 1172  * This function is called by the input function when the dispatch is
// 1173  * HC1.
// 1174  * We %process the packet in the rime buffer, uncompress the header
// 1175  * fields, and copy the result in the sicslowpan buffer.
// 1176  * At the end of the decompression, rime_hdr_len and uncompressed_hdr_len
// 1177  * are set to the appropriate values
// 1178  *
// 1179  * \param ip_len Equal to 0 if the packet is not a fragment (IP length
// 1180  * is then inferred from the L2 length), non 0 if the packet is a 1st
// 1181  * fragment.
// 1182  */
// 1183 static void
// 1184 uncompress_hdr_hc1(uint16_t ip_len)
// 1185 {
// 1186   /* version, traffic class, flow label */
// 1187   SICSLOWPAN_IP_BUF->vtc = 0x60;
// 1188   SICSLOWPAN_IP_BUF->tcflow = 0;
// 1189   SICSLOWPAN_IP_BUF->flow = 0;
// 1190   
// 1191   /* src and dest ip addresses */
// 1192   uip_ip6addr(&SICSLOWPAN_IP_BUF->srcipaddr, 0xfe80, 0, 0, 0, 0, 0, 0, 0);
// 1193   uip_ds6_set_addr_iid(&SICSLOWPAN_IP_BUF->srcipaddr,
// 1194 		       (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
// 1195   uip_ip6addr(&SICSLOWPAN_IP_BUF->destipaddr, 0xfe80, 0, 0, 0, 0, 0, 0, 0);
// 1196   uip_ds6_set_addr_iid(&SICSLOWPAN_IP_BUF->destipaddr,
// 1197 		       (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
// 1198   
// 1199   uncomp_hdr_len += UIP_IPH_LEN;
// 1200   
// 1201   /* Next header field */
// 1202   switch(RIME_HC1_PTR[RIME_HC1_ENCODING] & 0x06) {
// 1203     case SICSLOWPAN_HC1_NH_ICMP6:
// 1204       SICSLOWPAN_IP_BUF->proto = UIP_PROTO_ICMP6;
// 1205       SICSLOWPAN_IP_BUF->ttl = RIME_HC1_PTR[RIME_HC1_TTL];
// 1206       rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
// 1207       break;
// 1208 #if UIP_CONF_TCP
// 1209     case SICSLOWPAN_HC1_NH_TCP:
// 1210       SICSLOWPAN_IP_BUF->proto = UIP_PROTO_TCP;
// 1211       SICSLOWPAN_IP_BUF->ttl = RIME_HC1_PTR[RIME_HC1_TTL];
// 1212       rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
// 1213       break;
// 1214 #endif/* UIP_CONF_TCP */
// 1215 #if UIP_CONF_UDP
// 1216     case SICSLOWPAN_HC1_NH_UDP:
// 1217       SICSLOWPAN_IP_BUF->proto = UIP_PROTO_UDP;
// 1218       if(RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_HC1_ENCODING] & 0x01) {
// 1219         /* UDP header is compressed with HC_UDP */
// 1220         if(RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_UDP_ENCODING] !=
// 1221            SICSLOWPAN_HC_UDP_ALL_C) {
// 1222           PRINTF("sicslowpan (uncompress_hdr), packet not supported");
// 1223           return;
// 1224         }
// 1225         /* IP TTL */
// 1226         SICSLOWPAN_IP_BUF->ttl = RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_TTL];
// 1227         /* UDP ports, len, checksum */
// 1228         SICSLOWPAN_UDP_BUF->srcport =
// 1229           UIP_HTONS(SICSLOWPAN_UDP_PORT_MIN +
// 1230                 (RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_PORTS] >> 4));
// 1231         SICSLOWPAN_UDP_BUF->destport =
// 1232           UIP_HTONS(SICSLOWPAN_UDP_PORT_MIN +
// 1233                 (RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_PORTS] & 0x0F));
// 1234         memcpy(&SICSLOWPAN_UDP_BUF->udpchksum, &RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_CHKSUM], 2);
// 1235         uncomp_hdr_len += UIP_UDPH_LEN;
// 1236         rime_hdr_len += SICSLOWPAN_HC1_HC_UDP_HDR_LEN;
// 1237       } else {
// 1238         rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
// 1239       }
// 1240       break;
// 1241 #endif/* UIP_CONF_UDP */
// 1242     default:
// 1243       /* this shouldn't happen, drop */
// 1244       return;
// 1245   }
// 1246   
// 1247   /* IP length field. */
// 1248   if(ip_len == 0) {
// 1249     /* This is not a fragmented packet */
// 1250     SICSLOWPAN_IP_BUF->len[0] = 0;
// 1251     SICSLOWPAN_IP_BUF->len[1] = packetbuf_datalen() - rime_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;
// 1252   } else {
// 1253     /* This is a 1st fragment */
// 1254     SICSLOWPAN_IP_BUF->len[0] = (ip_len - UIP_IPH_LEN) >> 8;
// 1255     SICSLOWPAN_IP_BUF->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;
// 1256   }
// 1257   /* length field in UDP header */
// 1258   if(SICSLOWPAN_IP_BUF->proto == UIP_PROTO_UDP) {
// 1259     memcpy(&SICSLOWPAN_UDP_BUF->udplen, &SICSLOWPAN_IP_BUF->len[0], 2);
// 1260   }
// 1261   return;
// 1262 }
// 1263 /** @} */
// 1264 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1 */
// 1265 
// 1266 
// 1267 
// 1268 /*--------------------------------------------------------------------*/
// 1269 /** \name IPv6 dispatch "compression" function
// 1270  * @{                                                                 */
// 1271 /*--------------------------------------------------------------------*/
// 1272 /* \brief Packets "Compression" when only IPv6 dispatch is used
// 1273  *
// 1274  * There is no compression in this case, all fields are sent
// 1275  * inline. We just add the IPv6 dispatch byte before the packet.
// 1276  * \verbatim
// 1277  * 0               1                   2                   3
// 1278  * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
// 1279  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1280  * | IPv6 Dsp      | IPv6 header and payload ...
// 1281  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
// 1282  * \endverbatim
// 1283  */
// 1284 static void
// 1285 compress_hdr_ipv6(rimeaddr_t *rime_destaddr)
// 1286 {
// 1287   *rime_ptr = SICSLOWPAN_DISPATCH_IPV6;
// 1288   rime_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
// 1289   memcpy(rime_ptr + rime_hdr_len, UIP_IP_BUF, UIP_IPH_LEN);
// 1290   rime_hdr_len += UIP_IPH_LEN;
// 1291   uncomp_hdr_len += UIP_IPH_LEN;
// 1292   return;
// 1293 }
// 1294 /** @} */
// 1295 
// 1296 /*--------------------------------------------------------------------*/
// 1297 /** \name Input/output functions common to all compression schemes
// 1298  * @{                                                                 */
// 1299 /*--------------------------------------------------------------------*/
// 1300 /**
// 1301  * Callback function for the MAC packet sent callback
// 1302  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1303 static void
// 1304 packet_sent(void *ptr, int status, int transmissions)
packet_sent:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function packet_sent
        CODE
// 1305 {
        FUNCALL packet_sent, uip_ds6_link_neighbor_callback
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 9, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 9, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x9
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 0
        MOV     A,R4
        MOV     R6,A
        MOV     A,R5
        MOV     R7,A
        MOV     A,#0x9
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
// 1306   uip_ds6_link_neighbor_callback(status, transmissions);
        ; Setup parameters for call to function uip_ds6_link_neighbor_callback
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??uip_ds6_link_neighbor_callback?relay
// 1307 
// 1308   if(callback != NULL) {
        MOV     DPTR,#callback
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??packet_sent_0
// 1309     callback->output_callback(status);
        ; Setup parameters for indirect call
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        MOV     DPTR,#callback
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
// 1310   }
// 1311   last_tx_status = status;
??packet_sent_0:
        MOV     DPTR,#last_tx_status
        MOV     A,R6
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R7
        MOVX    @DPTR,A
// 1312 }
        MOV     R7,#0x1
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock9
// 1313 /*--------------------------------------------------------------------*/
// 1314 /**
// 1315  * \brief This function is called by the 6lowpan code to send out a
// 1316  * packet.
// 1317  * \param dest the link layer destination address of the packet
// 1318  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1319 static void
// 1320 send_packet(rimeaddr_t *dest)
send_packet:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function send_packet
        CODE
// 1321 {
        FUNCALL send_packet, packetbuf_set_addr
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL send_packet, watchdog_periodic
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1322   /* Set the link layer destination address for the packet as a
// 1323    * packetbuf attribute. The MAC layer can access the destination
// 1324    * address with the function packetbuf_addr(PACKETBUF_ADDR_RECEIVER).
// 1325    */
// 1326   packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, dest);
        ; Setup parameters for call to function packetbuf_set_addr
        MOV     R1,#0x19
        LCALL   ??packetbuf_set_addr?relay
// 1327 
// 1328 #if NETSTACK_CONF_BRIDGE_MODE
// 1329   /* This needs to be explicitly set here for bridge mode to work */
// 1330   packetbuf_set_addr(PACKETBUF_ADDR_SENDER,(void*)&uip_lladdr);
// 1331 #endif
// 1332 
// 1333   /* Force acknowledge from sender (test hardware autoacks) */
// 1334 #if SICSLOWPAN_CONF_ACK_ALL
// 1335     packetbuf_set_attr(PACKETBUF_ATTR_RELIABLE, 1);
// 1336 #endif
// 1337 
// 1338   /* Provide a callback function to receive the result of
// 1339      a packet transmission. */
// 1340   NETSTACK_MAC.send(&packet_sent, NULL);
        ; Setup parameters for indirect call
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     R2,#??packet_sent?relay & 0xff
        MOV     R3,#(??packet_sent?relay >> 8) & 0xff
        MOV     DPTR,#nullmac_driver + 4
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
// 1341 
// 1342   /* If we are sending multiple packets in a row, we need to let the
// 1343      watchdog know that we are still alive. */
// 1344   watchdog_periodic();
        ; Setup parameters for call to function watchdog_periodic
        LCALL   ??watchdog_periodic?relay
// 1345 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock10
// 1346 /*--------------------------------------------------------------------*/
// 1347 /** \brief Take an IP packet and format it to be sent on an 802.15.4
// 1348  *  network using 6lowpan.
// 1349  *  \param localdest The MAC address of the destination
// 1350  *
// 1351  *  The IP packet is initially in uip_buf. Its header is compressed
// 1352  *  and if necessary it is fragmented. The resulting
// 1353  *  packet/fragments are put in packetbuf and delivered to the 802.15.4
// 1354  *  MAC.
// 1355  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1356 static uint8_t
// 1357 output(uip_lladdr_t *localdest)
output:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function output
        CODE
// 1358 {
        FUNCALL output, packetbuf_clear
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_dataptr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_set_attr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, set_packet_attrs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_set_attr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_set_attr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, rimeaddr_copy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, rimeaddr_copy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, compress_hdr_hc06
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_clear
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_set_addr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_clear
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_set_attr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, packetbuf_set_datalen
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL output, send_packet
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
// 1359   int framer_hdrlen;
// 1360 
// 1361   /* The MAC address of the destination of the packet */
// 1362   rimeaddr_t dest;
// 1363 
// 1364   /* Number of bytes processed. */
// 1365   uint16_t processed_ip_out_len;
// 1366 
// 1367   /* init */
// 1368   uncomp_hdr_len = 0;
        MOV     DPTR,#uncomp_hdr_len
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1369   rime_hdr_len = 0;
        MOV     DPTR,#rime_hdr_len
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1370 
// 1371   /* reset rime buffer */
// 1372   packetbuf_clear();
        ; Setup parameters for call to function packetbuf_clear
        LCALL   ??packetbuf_clear?relay
// 1373   rime_ptr = packetbuf_dataptr();
        ; Setup parameters for call to function packetbuf_dataptr
        LCALL   ??packetbuf_dataptr?relay
        MOV     DPTR,#rime_ptr
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1374 
// 1375   packetbuf_set_attr(PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS,
// 1376                      SICSLOWPAN_MAX_MAC_TRANSMISSIONS);
        ; Setup parameters for call to function packetbuf_set_attr
        MOV     R2,#0x4
        MOV     R3,#0x0
        MOV     R1,#0x9
        LCALL   ??packetbuf_set_attr?relay
// 1377 
// 1378   if(callback) {
        MOV     DPTR,#callback
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??output_0
// 1379     /* call the attribution when the callback comes, but set attributes
// 1380        here ! */
// 1381     set_packet_attrs();
        ; Setup parameters for call to function set_packet_attrs
        LCALL   ??set_packet_attrs?relay
// 1382   }
// 1383 
// 1384 #define TCP_FIN 0x01
// 1385 #define TCP_ACK 0x10
// 1386 #define TCP_CTL 0x3f
// 1387   /* Set stream mode for all TCP packets, except FIN packets. */
// 1388   if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
// 1389      (UIP_TCP_BUF->flags & TCP_FIN) == 0 &&
// 1390      (UIP_TCP_BUF->flags & TCP_CTL) != TCP_ACK) {
??output_0:
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x6
        JNZ     ??output_1
        MOV     DPTR,#uip_aligned_buf + 53
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JC      ??output_1
        MOV     DPTR,#uip_aligned_buf + 53
        MOVX    A,@DPTR
        ANL     A,#0x3f
        XRL     A,#0x10
        JZ      ??output_1
// 1391     packetbuf_set_attr(PACKETBUF_ATTR_PACKET_TYPE,
// 1392                        PACKETBUF_ATTR_PACKET_TYPE_STREAM);
        ; Setup parameters for call to function packetbuf_set_attr
        MOV     R2,#0x2
        MOV     R3,#0x0
        MOV     R1,#0xe
        LCALL   ??packetbuf_set_attr?relay
        SJMP    ??output_2
// 1393   } else if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
// 1394             (UIP_TCP_BUF->flags & TCP_FIN) == TCP_FIN) {
??output_1:
        MOV     DPTR,#uip_aligned_buf + 6
        MOVX    A,@DPTR
        XRL     A,#0x6
        JNZ     ??output_2
        MOV     DPTR,#uip_aligned_buf + 53
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JNC     ??output_2
// 1395     packetbuf_set_attr(PACKETBUF_ATTR_PACKET_TYPE,
// 1396                        PACKETBUF_ATTR_PACKET_TYPE_STREAM_END);
        ; Setup parameters for call to function packetbuf_set_attr
        MOV     R2,#0x3
        MOV     R3,#0x0
        MOV     R1,#0xe
        LCALL   ??packetbuf_set_attr?relay
// 1397   }
// 1398 
// 1399   /*
// 1400    * The destination address will be tagged to each outbound
// 1401    * packet. If the argument localdest is NULL, we are sending a
// 1402    * broadcast packet.
// 1403    */
// 1404   if(localdest == NULL) {
??output_2:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??output_3
// 1405     rimeaddr_copy(&dest, &rimeaddr_null);
        ; Setup parameters for call to function rimeaddr_copy
        MOV     R4,#rimeaddr_null & 0xff
        MOV     R5,#(rimeaddr_null >> 8) & 0xff
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??rimeaddr_copy?relay
        SJMP    ??output_4
// 1406   } else {
// 1407     rimeaddr_copy(&dest, (const rimeaddr_t *)localdest);
??output_3:
        ; Setup parameters for call to function rimeaddr_copy
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??rimeaddr_copy?relay
// 1408   }
// 1409   
// 1410   PRINTFO("sicslowpan output: sending packet len %d\n", uip_len);
// 1411 
// 1412   if(uip_len >= COMPRESSION_THRESHOLD) {
// 1413     /* Try to compress the headers */
// 1414 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1
// 1415     compress_hdr_hc1(&dest);
// 1416 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1 */
// 1417 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_IPV6
// 1418     compress_hdr_ipv6(&dest);
// 1419 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_IPV6 */
// 1420 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
// 1421     compress_hdr_hc06(&dest);
??output_4:
        ; Setup parameters for call to function compress_hdr_hc06
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??compress_hdr_hc06?relay
// 1422 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
// 1423   } else {
// 1424     compress_hdr_ipv6(&dest);
// 1425   }
// 1426   PRINTFO("sicslowpan output: header of len %d\n", rime_hdr_len);
// 1427 
// 1428   /* Calculate NETSTACK_FRAMER's header length, that will be added in the NETSTACK_RDC.
// 1429    * We calculate it here only to make a better decision of whether the outgoing packet
// 1430    * needs to be fragmented or not. */
// 1431 #define USE_FRAMER_HDRLEN 1
// 1432 #if USE_FRAMER_HDRLEN
// 1433   packetbuf_clear();
        ; Setup parameters for call to function packetbuf_clear
        LCALL   ??packetbuf_clear?relay
// 1434   packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &dest);
        ; Setup parameters for call to function packetbuf_set_addr
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        MOV     R1,#0x19
        LCALL   ??packetbuf_set_addr?relay
// 1435   framer_hdrlen = NETSTACK_FRAMER.create();
        ; Setup parameters for indirect call
        MOV     DPTR,#framer_802154
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R6,?V0 + 0
        MOV     R7,?V0 + 1
// 1436   if(framer_hdrlen < 0) {
        CLR     C
        MOV     A,R6
        SUBB    A,#0x0
        MOV     A,R7
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??output_5
// 1437     /* Framing failed, we assume the maximum header length */
// 1438     framer_hdrlen = 21;
        MOV     R6,#0x15
        MOV     R7,#0x0
// 1439   }
// 1440   packetbuf_clear();
??output_5:
        ; Setup parameters for call to function packetbuf_clear
        LCALL   ??packetbuf_clear?relay
// 1441 
// 1442   /* We must set the max transmissions attribute again after clearing
// 1443      the buffer. */
// 1444   packetbuf_set_attr(PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS,
// 1445                      SICSLOWPAN_MAX_MAC_TRANSMISSIONS);
        ; Setup parameters for call to function packetbuf_set_attr
        MOV     R2,#0x4
        MOV     R3,#0x0
        MOV     R1,#0x9
        LCALL   ??packetbuf_set_attr?relay
// 1446 #else /* USE_FRAMER_HDRLEN */
// 1447   framer_hdrlen = 21;
// 1448 #endif /* USE_FRAMER_HDRLEN */
// 1449 
// 1450   if((int)uip_len - (int)uncomp_hdr_len > (int)MAC_MAX_PAYLOAD - framer_hdrlen - (int)rime_hdr_len) {
        MOV     A,#0x66
        CLR     C
        SUBB    A,R6
        MOV     R0,A
        MOV     A,#0x0
        SUBB    A,R7
        MOV     R1,A
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        CLR     C
        SUBB    A,R2
        MOV     R0,A
        MOV     A,R1
        SUBB    A,R3
        MOV     R1,A
        MOV     DPTR,#uip_len
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R2
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R3
        MOV     R3,A
        CLR     C
        MOV     A,R0
        SUBB    A,R2
        MOV     A,R1
        SUBB    A,R3
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??output_6
// 1451 #if SICSLOWPAN_CONF_FRAG
// 1452     struct queuebuf *q;
// 1453     /*
// 1454      * The outbound IPv6 packet is too large to fit into a single 15.4
// 1455      * packet, so we fragment it into multiple packets and send them.
// 1456      * The first fragment contains frag1 dispatch, then
// 1457      * IPv6/HC1/HC06/HC_UDP dispatchs/headers.
// 1458      * The following fragments contain only the fragn dispatch.
// 1459      */
// 1460 
// 1461     PRINTFO("Fragmentation sending packet len %d\n", uip_len);
// 1462 
// 1463     /* Create 1st Fragment */
// 1464     PRINTFO("sicslowpan output: 1rst fragment ");
// 1465 
// 1466     /* move HC1/HC06/IPv6 header */
// 1467     memmove(rime_ptr + SICSLOWPAN_FRAG1_HDR_LEN, rime_ptr, rime_hdr_len);
// 1468 
// 1469     /*
// 1470      * FRAG1 dispatch + header
// 1471      * Note that the length is in units of 8 bytes
// 1472      */
// 1473 /*     RIME_FRAG_BUF->dispatch_size = */
// 1474 /*       uip_htons((SICSLOWPAN_DISPATCH_FRAG1 << 8) | uip_len); */
// 1475     SET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE,
// 1476           ((SICSLOWPAN_DISPATCH_FRAG1 << 8) | uip_len));
// 1477 /*     RIME_FRAG_BUF->tag = uip_htons(my_tag); */
// 1478     SET16(RIME_FRAG_PTR, RIME_FRAG_TAG, my_tag);
// 1479     my_tag++;
// 1480 
// 1481     /* Copy payload and send */
// 1482     rime_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;
// 1483     rime_payload_len = (MAC_MAX_PAYLOAD - framer_hdrlen - rime_hdr_len) & 0xf8;
// 1484     PRINTFO("(len %d, tag %d)\n", rime_payload_len, my_tag);
// 1485     memcpy(rime_ptr + rime_hdr_len,
// 1486            (uint8_t *)UIP_IP_BUF + uncomp_hdr_len, rime_payload_len);
// 1487     packetbuf_set_datalen(rime_payload_len + rime_hdr_len);
// 1488     q = queuebuf_new_from_packetbuf();
// 1489     if(q == NULL) {
// 1490       PRINTFO("could not allocate queuebuf for first fragment, dropping packet\n");
// 1491       return 0;
// 1492     }
// 1493     send_packet(&dest);
// 1494     queuebuf_to_packetbuf(q);
// 1495     queuebuf_free(q);
// 1496     q = NULL;
// 1497 
// 1498     /* Check tx result. */
// 1499     if((last_tx_status == MAC_TX_COLLISION) ||
// 1500        (last_tx_status == MAC_TX_ERR) ||
// 1501        (last_tx_status == MAC_TX_ERR_FATAL)) {
// 1502       PRINTFO("error in fragment tx, dropping subsequent fragments.\n");
// 1503       return 0;
// 1504     }
// 1505 
// 1506     /* set processed_ip_out_len to what we already sent from the IP payload*/
// 1507     processed_ip_out_len = rime_payload_len + uncomp_hdr_len;
// 1508     
// 1509     /*
// 1510      * Create following fragments
// 1511      * Datagram tag is already in the buffer, we need to set the
// 1512      * FRAGN dispatch and for each fragment, the offset
// 1513      */
// 1514     rime_hdr_len = SICSLOWPAN_FRAGN_HDR_LEN;
// 1515 /*     RIME_FRAG_BUF->dispatch_size = */
// 1516 /*       uip_htons((SICSLOWPAN_DISPATCH_FRAGN << 8) | uip_len); */
// 1517     SET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE,
// 1518           ((SICSLOWPAN_DISPATCH_FRAGN << 8) | uip_len));
// 1519     rime_payload_len = (MAC_MAX_PAYLOAD - framer_hdrlen - rime_hdr_len) & 0xf8;
// 1520     while(processed_ip_out_len < uip_len) {
// 1521       PRINTFO("sicslowpan output: fragment ");
// 1522       RIME_FRAG_PTR[RIME_FRAG_OFFSET] = processed_ip_out_len >> 3;
// 1523       
// 1524       /* Copy payload and send */
// 1525       if(uip_len - processed_ip_out_len < rime_payload_len) {
// 1526         /* last fragment */
// 1527         rime_payload_len = uip_len - processed_ip_out_len;
// 1528       }
// 1529       PRINTFO("(offset %d, len %d, tag %d)\n",
// 1530              processed_ip_out_len >> 3, rime_payload_len, my_tag);
// 1531       memcpy(rime_ptr + rime_hdr_len,
// 1532              (uint8_t *)UIP_IP_BUF + processed_ip_out_len, rime_payload_len);
// 1533       packetbuf_set_datalen(rime_payload_len + rime_hdr_len);
// 1534       q = queuebuf_new_from_packetbuf();
// 1535       if(q == NULL) {
// 1536         PRINTFO("could not allocate queuebuf, dropping fragment\n");
// 1537         return 0;
// 1538       }
// 1539       send_packet(&dest);
// 1540       queuebuf_to_packetbuf(q);
// 1541       queuebuf_free(q);
// 1542       q = NULL;
// 1543       processed_ip_out_len += rime_payload_len;
// 1544 
// 1545       /* Check tx result. */
// 1546       if((last_tx_status == MAC_TX_COLLISION) ||
// 1547          (last_tx_status == MAC_TX_ERR) ||
// 1548          (last_tx_status == MAC_TX_ERR_FATAL)) {
// 1549         PRINTFO("error in fragment tx, dropping subsequent fragments.\n");
// 1550         return 0;
// 1551       }
// 1552     }
// 1553 #else /* SICSLOWPAN_CONF_FRAG */
// 1554     PRINTFO("sicslowpan output: Packet too large to be sent without fragmentation support; dropping packet\n");
// 1555     return 0;
        MOV     R1,#0x0
        LJMP    ??output_7 & 0xFFFF
// 1556 #endif /* SICSLOWPAN_CONF_FRAG */
// 1557   } else {
// 1558 
// 1559     /*
// 1560      * The packet does not need to be fragmented
// 1561      * copy "payload" and send
// 1562      */
// 1563     memcpy(rime_ptr + rime_hdr_len, (uint8_t *)UIP_IP_BUF + uncomp_hdr_len,
// 1564            uip_len - uncomp_hdr_len);
??output_6:
        ; Setup parameters for call to function memcpy
        MOV     DPTR,#uip_len
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R4,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R5,A
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
// 1565     packetbuf_set_datalen(uip_len - uncomp_hdr_len + rime_hdr_len);
        ; Setup parameters for call to function packetbuf_set_datalen
        MOV     DPTR,#uip_len
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     R1,A
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R2,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R3,A
        LCALL   ??packetbuf_set_datalen?relay
// 1566     send_packet(&dest);
        ; Setup parameters for call to function send_packet
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   ??send_packet?relay
// 1567   }
// 1568   return 1;
        MOV     R1,#0x1
??output_7:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock11
// 1569 }
// 1570 
// 1571 /*--------------------------------------------------------------------*/
// 1572 /** \brief Process a received 6lowpan packet.
// 1573  *  \param r The MAC layer
// 1574  *
// 1575  *  The 6lowpan packet is put in packetbuf by the MAC. If its a frag1 or
// 1576  *  a non-fragmented packet we first uncompress the IP header. The
// 1577  *  6lowpan payload and possibly the uncompressed IP header are then
// 1578  *  copied in siclowpan_buf. If the IP packet is complete it is copied
// 1579  *  to uip_buf and the IP layer is called.
// 1580  *
// 1581  * \note We do not check for overlapping sicslowpan fragments
// 1582  * (it is a SHALL in the RFC 4944 and should never happen)
// 1583  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1584 static void
// 1585 input(void)
input:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function input
        CODE
// 1586 {
        FUNCALL input, packetbuf_dataptr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, uncompress_hdr_hc06
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, packetbuf_datalen
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, packetbuf_datalen
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, set_packet_attrs
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL input, tcpip_input
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
// 1587   /* size of the IP packet (read from fragment) */
// 1588   uint16_t frag_size = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
// 1589   /* offset of the fragment in the IP packet */
// 1590   uint8_t frag_offset = 0;
        MOV     ?V0 + 1,#0x0
// 1591   uint8_t is_fragment = 0;
        MOV     ?V0 + 0,#0x0
// 1592 #if SICSLOWPAN_CONF_FRAG
// 1593   /* tag of the fragment */
// 1594   uint16_t frag_tag = 0;
// 1595   uint8_t first_fragment = 0, last_fragment = 0;
// 1596 #endif /*SICSLOWPAN_CONF_FRAG*/
// 1597 
// 1598   /* init */
// 1599   uncomp_hdr_len = 0;
        MOV     DPTR,#uncomp_hdr_len
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1600   rime_hdr_len = 0;
        MOV     DPTR,#rime_hdr_len
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1601 
// 1602   /* The MAC puts the 15.4 payload inside the RIME data buffer */
// 1603   rime_ptr = packetbuf_dataptr();
        ; Setup parameters for call to function packetbuf_dataptr
        LCALL   ??packetbuf_dataptr?relay
        MOV     DPTR,#rime_ptr
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
// 1604 
// 1605 #if SICSLOWPAN_CONF_FRAG
// 1606   /* if reassembly timed out, cancel it */
// 1607   if(timer_expired(&reass_timer)) {
// 1608     sicslowpan_len = 0;
// 1609     processed_ip_in_len = 0;
// 1610   }
// 1611   /*
// 1612    * Since we don't support the mesh and broadcast header, the first header
// 1613    * we look for is the fragmentation header
// 1614    */
// 1615   switch((GET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE) & 0xf800) >> 8) {
// 1616     case SICSLOWPAN_DISPATCH_FRAG1:
// 1617       PRINTFI("sicslowpan input: FRAG1 ");
// 1618       frag_offset = 0;
// 1619 /*       frag_size = (uip_ntohs(RIME_FRAG_BUF->dispatch_size) & 0x07ff); */
// 1620       frag_size = GET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE) & 0x07ff;
// 1621 /*       frag_tag = uip_ntohs(RIME_FRAG_BUF->tag); */
// 1622       frag_tag = GET16(RIME_FRAG_PTR, RIME_FRAG_TAG);
// 1623       PRINTFI("size %d, tag %d, offset %d)\n",
// 1624              frag_size, frag_tag, frag_offset);
// 1625       rime_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;
// 1626       /*      printf("frag1 %d %d\n", reass_tag, frag_tag);*/
// 1627       first_fragment = 1;
// 1628       is_fragment = 1;
// 1629       break;
// 1630     case SICSLOWPAN_DISPATCH_FRAGN:
// 1631       /*
// 1632        * set offset, tag, size
// 1633        * Offset is in units of 8 bytes
// 1634        */
// 1635       PRINTFI("sicslowpan input: FRAGN ");
// 1636       frag_offset = RIME_FRAG_PTR[RIME_FRAG_OFFSET];
// 1637       frag_tag = GET16(RIME_FRAG_PTR, RIME_FRAG_TAG);
// 1638       frag_size = GET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE) & 0x07ff;
// 1639       PRINTFI("size %d, tag %d, offset %d)\n",
// 1640              frag_size, frag_tag, frag_offset);
// 1641       rime_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;
// 1642 
// 1643       /* If this is the last fragment, we may shave off any extrenous
// 1644          bytes at the end. We must be liberal in what we accept. */
// 1645       PRINTFI("last_fragment?: processed_ip_in_len %d rime_payload_len %d frag_size %d\n",
// 1646               processed_ip_in_len, packetbuf_datalen() - rime_hdr_len, frag_size);
// 1647 
// 1648       if(processed_ip_in_len + packetbuf_datalen() - rime_hdr_len >= frag_size) {
// 1649         last_fragment = 1;
// 1650       }
// 1651       is_fragment = 1;
// 1652       break;
// 1653     default:
// 1654       break;
// 1655   }
// 1656 
// 1657   /* We are currently reassembling a packet, but have just received the first
// 1658    * fragment of another packet. We can either ignore it and hope to receive
// 1659    * the rest of the under-reassembly packet fragments, or we can discard the
// 1660    * previous packet altogether, and start reassembling the new packet.
// 1661    *
// 1662    * We discard the previous packet, and start reassembling the new packet.
// 1663    * This lessens the negative impacts of too high SICSLOWPAN_REASS_MAXAGE.
// 1664    */
// 1665 #define PRIORITIZE_NEW_PACKETS 1
// 1666 #if PRIORITIZE_NEW_PACKETS
// 1667   if(processed_ip_in_len > 0 && first_fragment
// 1668       && !rimeaddr_cmp(&frag_sender, packetbuf_addr(PACKETBUF_ADDR_SENDER))) {
// 1669     sicslowpan_len = 0;
// 1670     processed_ip_in_len = 0;
// 1671   }
// 1672 #endif /* PRIORITIZE_NEW_PACKETS */
// 1673 
// 1674   if(processed_ip_in_len > 0) {
// 1675     /* reassembly is ongoing */
// 1676     /*    printf("frag %d %d\n", reass_tag, frag_tag);*/
// 1677     if((frag_size > 0 &&
// 1678         (frag_size != sicslowpan_len ||
// 1679          reass_tag  != frag_tag ||
// 1680          !rimeaddr_cmp(&frag_sender, packetbuf_addr(PACKETBUF_ADDR_SENDER))))  ||
// 1681        frag_size == 0) {
// 1682       /*
// 1683        * the packet is a fragment that does not belong to the packet
// 1684        * being reassembled or the packet is not a fragment.
// 1685        */
// 1686       PRINTFI("sicslowpan input: Dropping 6lowpan packet that is not a fragment of the packet currently being reassembled\n");
// 1687       return;
// 1688     }
// 1689   } else {
// 1690     /*
// 1691      * reassembly is off
// 1692      * start it if we received a fragment
// 1693      */
// 1694     if((frag_size > 0) && (frag_size <= UIP_BUFSIZE)) {
// 1695       /* We are currently not reassembling a packet, but have received a packet fragment
// 1696        * that is not the first one. */
// 1697       if(is_fragment && !first_fragment) {
// 1698         return;
// 1699       }
// 1700 
// 1701       sicslowpan_len = frag_size;
// 1702       reass_tag = frag_tag;
// 1703       timer_set(&reass_timer, SICSLOWPAN_REASS_MAXAGE * CLOCK_SECOND / 16);
// 1704       PRINTFI("sicslowpan input: INIT FRAGMENTATION (len %d, tag %d)\n",
// 1705              sicslowpan_len, reass_tag);
// 1706       rimeaddr_copy(&frag_sender, packetbuf_addr(PACKETBUF_ADDR_SENDER));
// 1707     }
// 1708   }
// 1709 
// 1710   if(rime_hdr_len == SICSLOWPAN_FRAGN_HDR_LEN) {
// 1711     /* this is a FRAGN, skip the header compression dispatch section */
// 1712     goto copypayload;
// 1713   }
// 1714 #endif /* SICSLOWPAN_CONF_FRAG */
// 1715 
// 1716   /* Process next dispatch and headers */
// 1717 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
// 1718   if((RIME_HC1_PTR[RIME_HC1_DISPATCH] & 0xe0) == SICSLOWPAN_DISPATCH_IPHC) {
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        MOVX    A,@DPTR
        ANL     A,#0xe0
        XRL     A,#0x60
        JNZ     ??input_0
// 1719     PRINTFI("sicslowpan input: IPHC\n");
// 1720     uncompress_hdr_hc06(frag_size);
        ; Setup parameters for call to function uncompress_hdr_hc06
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??uncompress_hdr_hc06?relay
// 1721   } else
// 1722 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
// 1723     switch(RIME_HC1_PTR[RIME_HC1_DISPATCH]) {
// 1724 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1
// 1725     case SICSLOWPAN_DISPATCH_HC1:
// 1726       PRINTFI("sicslowpan input: HC1\n");
// 1727       uncompress_hdr_hc1(frag_size);
// 1728       break;
// 1729 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1 */
// 1730     case SICSLOWPAN_DISPATCH_IPV6:
// 1731       PRINTFI("sicslowpan input: IPV6\n");
// 1732       rime_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
// 1733 
// 1734       /* Put uncompressed IP header in sicslowpan_buf. */
// 1735       memcpy(SICSLOWPAN_IP_BUF, rime_ptr + rime_hdr_len, UIP_IPH_LEN);
// 1736 
// 1737       /* Update uncomp_hdr_len and rime_hdr_len. */
// 1738       rime_hdr_len += UIP_IPH_LEN;
// 1739       uncomp_hdr_len += UIP_IPH_LEN;
// 1740       break;
// 1741     default:
// 1742       /* unknown header */
// 1743       PRINTFI("sicslowpan input: unknown dispatch: %u\n",
// 1744              RIME_HC1_PTR[RIME_HC1_DISPATCH]);
// 1745       return;
// 1746   }
// 1747    
// 1748     
// 1749 #if SICSLOWPAN_CONF_FRAG
// 1750  copypayload:
// 1751 #endif /*SICSLOWPAN_CONF_FRAG*/
// 1752   /*
// 1753    * copy "payload" from the rime buffer to the sicslowpan_buf
// 1754    * if this is a first fragment or not fragmented packet,
// 1755    * we have already copied the compressed headers, uncomp_hdr_len
// 1756    * and rime_hdr_len are non 0, frag_offset is.
// 1757    * If this is a subsequent fragment, this is the contrary.
// 1758    */
// 1759   if(packetbuf_datalen() < rime_hdr_len) {
??input_1:
        ; Setup parameters for call to function packetbuf_datalen
        LCALL   ??packetbuf_datalen?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        CLR     C
        MOV     A,?V0 + 2
        SUBB    A,R2
        MOV     A,?V0 + 3
        SUBB    A,R3
        JNC     ??input_2
// 1760     PRINTF("SICSLOWPAN: packet dropped due to header > total packet\n");
// 1761     return;
        LJMP    ??input_3 & 0xFFFF
// 1762   }
??input_0:
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     DPL,R2
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,#0x41
        JNZ     ??input_4
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x28
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R5,A
        MOV     R2,#uip_aligned_buf & 0xff
        MOV     R3,#(uip_aligned_buf >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        ADD     A,#0x28
        MOVX    @DPTR,A
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        ADD     A,#0x28
        MOVX    @DPTR,A
        SJMP    ??input_1
??input_4:
        LJMP    ??input_3 & 0xFFFF
// 1763   rime_payload_len = packetbuf_datalen() - rime_hdr_len;
??input_2:
        ; Setup parameters for call to function packetbuf_datalen
        LCALL   ??packetbuf_datalen?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R0,?V0 + 2
        MOV     R1,?V0 + 3
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R2
        MOV     DPTR,#rime_payload_len
        MOVX    @DPTR,A
// 1764 
// 1765   /* Sanity-check size of incoming packet to avoid buffer overflow */
// 1766   {
// 1767     int req_size = UIP_LLH_LEN + uncomp_hdr_len + (uint16_t)(frag_offset << 3)
// 1768         + rime_payload_len;
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     ?V0 + 2,?V0 + 1
        MOV     ?V0 + 3,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     A,R2
        ADD     A,?V0 + 2
        MOV     R0,A
        MOV     A,R3
        ADDC    A,?V0 + 3
        MOV     R1,A
        MOV     DPTR,#rime_payload_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
// 1769     if(req_size > sizeof(sicslowpan_buf)) {
        CLR     C
        MOV     A,R0
        SUBB    A,#-0xf
        MOV     A,R1
        SUBB    A,#0x0
        JC      $+5
        LJMP    ??input_3 & 0xFFFF
// 1770       PRINTF(
// 1771           "SICSLOWPAN: packet dropped, minimum required SICSLOWPAN_IP_BUF size: %d+%d+%d+%d=%d (current size: %d)\n",
// 1772           UIP_LLH_LEN, uncomp_hdr_len, (uint16_t)(frag_offset << 3),
// 1773           rime_payload_len, req_size, sizeof(sicslowpan_buf));
// 1774       return;
// 1775     }
// 1776   }
// 1777 
// 1778   memcpy((uint8_t *)SICSLOWPAN_IP_BUF + uncomp_hdr_len + (uint16_t)(frag_offset << 3), rime_ptr + rime_hdr_len, rime_payload_len);
        ; Setup parameters for call to function memcpy
        MOV     DPTR,#rime_payload_len
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     ?V0 + 2,?V0 + 0
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#rime_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#rime_ptr
        MOVX    A,@DPTR
        ADD     A,R0
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,R1
        MOV     R5,A
        MOV     ?V0 + 0,?V0 + 1
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,?V0 + 0
        MOV     R2,A
        MOV     A,R1
        ADDC    A,?V0 + 1
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
// 1779   
// 1780   /* update processed_ip_in_len if fragment, sicslowpan_len otherwise */
// 1781 
// 1782 #if SICSLOWPAN_CONF_FRAG
// 1783   if(frag_size > 0) {
// 1784     /* Add the size of the header only for the first fragment. */
// 1785     if(first_fragment != 0) {
// 1786       processed_ip_in_len += uncomp_hdr_len;
// 1787     }
// 1788     /* For the last fragment, we are OK if there is extrenous bytes at
// 1789        the end of the packet. */
// 1790     if(last_fragment != 0) {
// 1791       processed_ip_in_len = frag_size;
// 1792     } else {
// 1793       processed_ip_in_len += rime_payload_len;
// 1794     }
// 1795     PRINTF("processed_ip_in_len %d, rime_payload_len %d\n", processed_ip_in_len, rime_payload_len);
// 1796 
// 1797   } else {
// 1798 #endif /* SICSLOWPAN_CONF_FRAG */
// 1799     sicslowpan_len = rime_payload_len + uncomp_hdr_len;
        MOV     DPTR,#rime_payload_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uncomp_hdr_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     DPTR,#uip_len
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 1800 #if SICSLOWPAN_CONF_FRAG
// 1801   }
// 1802 
// 1803   /*
// 1804    * If we have a full IP packet in sicslowpan_buf, deliver it to
// 1805    * the IP stack
// 1806    */
// 1807   PRINTF("sicslowpan_init processed_ip_in_len %d, sicslowpan_len %d\n",
// 1808          processed_ip_in_len, sicslowpan_len);
// 1809   if(processed_ip_in_len == 0 || (processed_ip_in_len == sicslowpan_len)) {
// 1810     PRINTFI("sicslowpan input: IP packet ready (length %d)\n",
// 1811            sicslowpan_len);
// 1812     memcpy((uint8_t *)UIP_IP_BUF, (uint8_t *)SICSLOWPAN_IP_BUF, sicslowpan_len);
// 1813     uip_len = sicslowpan_len;
// 1814     sicslowpan_len = 0;
// 1815     processed_ip_in_len = 0;
// 1816 #endif /* SICSLOWPAN_CONF_FRAG */
// 1817 
// 1818 #if DEBUG
// 1819     {
// 1820       uint16_t ndx;
// 1821       PRINTF("after decompression %u:", SICSLOWPAN_IP_BUF->len[1]);
// 1822       for (ndx = 0; ndx < SICSLOWPAN_IP_BUF->len[1] + 40; ndx++) {
// 1823         uint8_t data = ((uint8_t *) (SICSLOWPAN_IP_BUF))[ndx];
// 1824         PRINTF("%02x", data);
// 1825       }
// 1826       PRINTF("\n");
// 1827     }
// 1828 #endif
// 1829 
// 1830     /* if callback is set then set attributes and call */
// 1831     if(callback) {
        MOV     DPTR,#callback
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??input_5
// 1832       set_packet_attrs();
        ; Setup parameters for call to function set_packet_attrs
        LCALL   ??set_packet_attrs?relay
// 1833       callback->input_callback();
        ; Setup parameters for indirect call
        MOV     DPTR,#callback
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        LCALL   ?CALL_IND
// 1834     }
// 1835 
// 1836     tcpip_input();
??input_5:
        ; Setup parameters for call to function tcpip_input
        LCALL   ??tcpip_input?relay
// 1837 #if SICSLOWPAN_CONF_FRAG
// 1838   }
// 1839 #endif /* SICSLOWPAN_CONF_FRAG */
// 1840 }
??input_3:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock12
// 1841 /** @} */
// 1842 
// 1843 /*--------------------------------------------------------------------*/
// 1844 /* \brief 6lowpan init function (called by the MAC layer)             */
// 1845 /*--------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 1846 void
// 1847 sicslowpan_init(void)
sicslowpan_init:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function sicslowpan_init
        CODE
// 1848 {
        FUNCALL sicslowpan_init, tcpip_set_outputfunc
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 1849   /*
// 1850    * Set out output function as the function to be called from uIP to
// 1851    * send a packet.
// 1852    */
// 1853   tcpip_set_outputfunc(output);
        ; Setup parameters for call to function tcpip_set_outputfunc
        MOV     R2,#??output?relay & 0xff
        MOV     R3,#(??output?relay >> 8) & 0xff
        LCALL   ??tcpip_set_outputfunc?relay
// 1854 
// 1855 #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
// 1856 /* Preinitialize any address contexts for better header compression
// 1857  * (Saves up to 13 bytes per 6lowpan packet)
// 1858  * The platform contiki-conf.h file can override this using e.g.
// 1859  * #define SICSLOWPAN_CONF_ADDR_CONTEXT_0 {addr_contexts[0].prefix[0]=0xbb;addr_contexts[0].prefix[1]=0xbb;}
// 1860  */
// 1861 #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 
// 1862   addr_contexts[0].used   = 1;
        MOV     DPTR,#addr_contexts
        MOV     A,#0x1
        MOVX    @DPTR,A
// 1863   addr_contexts[0].number = 0;
        MOV     DPTR,#addr_contexts + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
// 1864 #ifdef SICSLOWPAN_CONF_ADDR_CONTEXT_0
// 1865 	SICSLOWPAN_CONF_ADDR_CONTEXT_0;
        MOV     DPTR,#addr_contexts + 2
        MOV     A,#-0x56
        MOVX    @DPTR,A
        MOV     DPTR,#addr_contexts + 3
        MOV     A,#-0x56
        MOVX    @DPTR,A
// 1866 #else
// 1867   addr_contexts[0].prefix[0] = 0xaa; 
// 1868   addr_contexts[0].prefix[1] = 0xaa;
// 1869 #endif
// 1870 #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 */
// 1871 
// 1872 #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 1
// 1873   {
// 1874     int i;
// 1875     for(i = 1; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
// 1876 #ifdef SICSLOWPAN_CONF_ADDR_CONTEXT_1
// 1877 	  if (i==1) {
// 1878 	    addr_contexts[1].used   = 1;
// 1879 		addr_contexts[1].number = 1;
// 1880 		SICSLOWPAN_CONF_ADDR_CONTEXT_1;
// 1881 #ifdef SICSLOWPAN_CONF_ADDR_CONTEXT_2
// 1882       } else if (i==2) {
// 1883 	  	addr_contexts[2].used   = 1;
// 1884 		addr_contexts[2].number = 2;
// 1885 		SICSLOWPAN_CONF_ADDR_CONTEXT_2;
// 1886 #endif
// 1887       } else {
// 1888         addr_contexts[i].used = 0;
// 1889       }	  
// 1890 #else
// 1891       addr_contexts[i].used = 0;
// 1892 #endif /* SICSLOWPAN_CONF_ADDR_CONTEXT_1 */
// 1893 
// 1894     }
// 1895   }
// 1896 #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 1 */
// 1897 
// 1898 #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
// 1899 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock13
// 1900 /*--------------------------------------------------------------------*/

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA8
// 1901 const struct network_driver sicslowpan_driver = {
sicslowpan_driver:
        DS 6
        REQUIRE `?<Initializer for sicslowpan_driver>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant "sicslowpan">>`:
        DB "sicslowpan"

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for <Constant {255, 2}>>`:
        DATA8
        DB 255
        DB 2

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for unc_llconf>`:
        DATA8
        DB 15
        DB 40
        DB 34
        DB 32

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for unc_ctxconf>`:
        DATA8
        DB 0
        DB 136
        DB 130
        DB 128

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for unc_mxconf>`:
        DATA8
        DB 15
        DB 37
        DB 35
        DB 33

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for llprefix>`:
        DATA8
        DB 254
        DB 128

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for ttl_values>`:
        DATA8
        DB 0
        DB 1
        DB 64
        DB 255

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for sicslowpan_driver>`:
        DATA16
        DW `?<Constant "sicslowpan">`
        DW ??sicslowpan_init?relay
        DW ??input?relay

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rime_sniffer_add?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    rime_sniffer_add

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??rime_sniffer_remove?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    rime_sniffer_remove

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??set_packet_attrs?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    set_packet_attrs

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??addr_context_lookup_by_prefix?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    addr_context_lookup_by_prefix

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??addr_context_lookup_by_number?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    addr_context_lookup_by_number

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??compress_addr_64?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    compress_addr_64

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uncompress_addr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uncompress_addr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??compress_hdr_hc06?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    compress_hdr_hc06

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uncompress_hdr_hc06?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uncompress_hdr_hc06

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??packet_sent?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    packet_sent

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??send_packet?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    send_packet

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??output?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    output

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??input?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    input

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??sicslowpan_init?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    sicslowpan_init

        END
// 1902   "sicslowpan",
// 1903   sicslowpan_init,
// 1904   input
// 1905 };
// 1906 /*--------------------------------------------------------------------*/
// 1907 /** @} */
// 1908 #endif /* UIP_CONF_IPV6 */
// 
// 6 507 bytes in segment BANKED_CODE
//    84 bytes in segment BANK_RELAYS
//    37 bytes in segment XDATA_I
//    37 bytes in segment XDATA_ID
//    23 bytes in segment XDATA_Z
// 
// 6 628 bytes of CODE  memory
//    60 bytes of XDATA memory
//
//Errors: none
//Warnings: 3
