///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.20.2.41139 for 8051            03/Apr/2014  10:45:46 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  D:\myWork\myWork\cpu\cc253x\dev\clock.c           /
//    Command line       =  D:\myWork\myWork\cpu\cc253x\dev\clock.c -D        /
//                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC            /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\List\ -lA D:\myWork\myWork\examples\wsn2530dk\ /
//                          myProject\coord\List\ --diag_suppress             /
//                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o         /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\Obj\ -e --no_cse --no_unroll --no_inline       /
//                          --no_code_motion --no_tbaa --debug --core=plain   /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          16 --preinclude D:\myWork\myWork\examples\wsn2530 /
//                          dk\myProject\..\..\..\cpu\cc253x\cc253x.h -I      /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\ /
//                          ..\..\cpu\cc253x\ -I D:\myWork\myWork\examples\ws /
//                          n2530dk\myProject\..\..\..\platform\wsn2530dk\    /
//                          -I D:\myWork\myWork\examples\wsn2530dk\myProject\ /
//                          ..\..\..\core\ -I D:\myWork\myWork\examples\wsn25 /
//                          30dk\myProject\..\..\..\apps\ -I                  /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\    /
//                          -Ol                                               /
//    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\List\clock.s51                                 /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME clock

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?INTERRUPT_ENTER_XSP
        EXTERN ?INTERRUPT_LEAVE_XSP
        EXTERN ?L_ADD
        EXTERN ?L_ADD_TO_X
        EXTERN ?L_ADD_X
        EXTERN ?L_MOV
        EXTERN ?L_SHL
        EXTERN ?UL_SHR
        EXTERN ?US_DIV_MOD
        EXTERN ?V0
        EXTERN __INIT_DATA_Z
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        PUBLIC ??clock_delay_usec?relay
        FUNCTION ??clock_delay_usec?relay,0203H
        PUBLIC ??clock_getSleepState?relay
        FUNCTION ??clock_getSleepState?relay,0203H
        PUBLIC ??clock_init?relay
        FUNCTION ??clock_init?relay,0203H
        PUBWEAK `??clock_isr??INTVEC 43`
        PUBLIC ??clock_seconds?relay
        FUNCTION ??clock_seconds?relay,0203H
        PUBLIC ??clock_setSleepState?relay
        FUNCTION ??clock_setSleepState?relay,0203H
        PUBLIC ??clock_time?relay
        FUNCTION ??clock_time?relay,0203H
        PUBLIC ??clock_wait?relay
        FUNCTION ??clock_wait?relay,0203H
        PUBWEAK CLKCONCMD
        PUBWEAK CLKCONSTA
        PUBWEAK ST0
        PUBWEAK ST1
        PUBWEAK ST2
        PUBWEAK T1CNTH
        PUBWEAK T1CNTL
        PUBWEAK _A_IEN0
        PUBWEAK _A_IRCON
        PUBWEAK __Constant_100
        PUBWEAK __Constant_18000
        PUBLIC clock_delay_usec
        FUNCTION clock_delay_usec,080203H
        ARGFRAME XSTACK, 0, STACK
        PUBLIC clock_getSleepState
        FUNCTION clock_getSleepState,0201H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC clock_init
        FUNCTION clock_init,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC clock_isr
        FUNCTION clock_isr,0233H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        PUBLIC clock_seconds
        FUNCTION clock_seconds,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC clock_setSleepState
        FUNCTION clock_setSleepState,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC clock_time
        FUNCTION clock_time,0203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC clock_wait
        FUNCTION clock_wait,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC sleep_flag
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-2
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B SameValue
          CFI A SameValue
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 SameValue
          CFI R1 SameValue
          CFI R2 SameValue
          CFI R3 SameValue
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT SameValue
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon1
        
clock_delay_usec    SYMBOL "clock_delay_usec"
??clock_delay_usec?relay SYMBOL "?relay", clock_delay_usec
clock_getSleepState SYMBOL "clock_getSleepState"
??clock_getSleepState?relay SYMBOL "?relay", clock_getSleepState
clock_init          SYMBOL "clock_init"
??clock_init?relay  SYMBOL "?relay", clock_init
clock_isr           SYMBOL "clock_isr"
`??clock_isr??INTVEC 43` SYMBOL "??INTVEC 43", clock_isr
clock_seconds       SYMBOL "clock_seconds"
??clock_seconds?relay SYMBOL "?relay", clock_seconds
clock_setSleepState SYMBOL "clock_setSleepState"
??clock_setSleepState?relay SYMBOL "?relay", clock_setSleepState
clock_time          SYMBOL "clock_time"
??clock_time?relay  SYMBOL "?relay", clock_time
clock_wait          SYMBOL "clock_wait"
??clock_wait?relay  SYMBOL "?relay", clock_wait

        EXTERN energest_current_mode
        EXTERN energest_current_time
        EXTERN energest_total_time


        ASEGN SFR_AN:DATA:NOROOT,0a8H
// union <unnamed> volatile __sfr _A_IEN0
_A_IEN0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c0H
// union <unnamed> volatile __sfr _A_IRCON
_A_IRCON:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,095H
// unsigned char volatile __sfr ST0
ST0:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,096H
// unsigned char volatile __sfr ST1
ST1:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,097H
// unsigned char volatile __sfr ST2
ST2:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0c6H
// unsigned char volatile __sfr CLKCONCMD
CLKCONCMD:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,09eH
// unsigned char volatile __sfr CLKCONSTA
CLKCONSTA:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e2H
// unsigned char volatile __sfr T1CNTL
T1CNTL:
        DATA8
        DS 1

        ASEGN SFR_AN:DATA:NOROOT,0e3H
// unsigned char volatile __sfr T1CNTH
T1CNTH:
        DATA8
        DS 1
// D:\myWork\myWork\cpu\cc253x\dev\clock.c
//    1 /*
//    2  * Copyright (c) 2009, Swedish Institute of Computer Science.
//    3  * All rights reserved.
//    4  *
//    5  * Redistribution and use in source and binary forms, with or without
//    6  * modification, are permitted provided that the following conditions
//    7  * are met:
//    8  * 1. Redistributions of source code must retain the above copyright
//    9  *    notice, this list of conditions and the following disclaimer.
//   10  * 2. Redistributions in binary form must reproduce the above copyright
//   11  *    notice, this list of conditions and the following disclaimer in the
//   12  *    documentation and/or other materials provided with the distribution.
//   13  * 3. Neither the name of the Institute nor the names of its contributors
//   14  *    may be used to endorse or promote products derived from this software
//   15  *    without specific prior written permission.
//   16  *
//   17  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
//   18  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   19  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//   20  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
//   21  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
//   23  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//   24  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
//   25  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
//   26  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
//   27  * SUCH DAMAGE.
//   28  *
//   29  * This file is part of the Contiki operating system.
//   30  */
//   31 
//   32 /**
//   33  * \file
//   34  *         Implementation of the clock functions for the cc253x.
//   35  *         Ported over from the cc243x original.
//   36  * \author
//   37  *         Zach Shelby (zach@sensinode.com) - original (cc243x)
//   38  *         George Oikonomou - <oikonomou@users.sourceforge.net> - cc2530 port
//   39  */
//   40 #include "sfr-bits.h"
//   41 #include "sys/clock.h"

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
// static int sleeping
sleeping:
        DS 2
        REQUIRE __INIT_XDATA_Z
//   42 #include "sys/etimer.h"
//   43 #include "cc253x.h"
//   44 #include "sys/energest.h"
//   45 
//   46 /* Sleep timer runs on the 32k RC osc. */
//   47 /* One clock tick is 7.8 ms */
//   48 #define TICK_VAL (32768/128)  /* 256 */
//   49 #define TICK_VAL_MY (32768*3)
//   50 /*---------------------------------------------------------------------------*/
//   51 #if CLOCK_CONF_STACK_FRIENDLY

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   52 volatile uint8_t sleep_flag;
sleep_flag:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   53 #endif
//   54 
//   55 /*---------------------------------------------------------------------------*/
//   56 /* Do NOT remove the absolute address and do NOT remove the initialiser here */
//   57 //__xdata __at(0x0000) static unsigned long timer_value = 0;

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA32
//   58 static CC_AT_DATA unsigned long timer_value = 0;
timer_value:
        DS 4
        REQUIRE __INIT_DATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA32
//   59 static CC_AT_DATA unsigned long sleeptimer = 0;
sleeptimer:
        DS 4
        REQUIRE __INIT_DATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA16
//   60 static volatile CC_AT_DATA clock_time_t count = 0; /* Uptime in ticks */
count:
        DS 2
        REQUIRE __INIT_DATA_Z

        RSEG DATA_Z:DATA:NOROOT(0)
        DATA16
//   61 static volatile CC_AT_DATA clock_time_t seconds = 0; /* Uptime in secs */
seconds:
        DS 2
        REQUIRE __INIT_DATA_Z
//   62 /*---------------------------------------------------------------------------*/
//   63 /**
//   64  * Each iteration is ~1.0xy usec, so this function delays for roughly len usec
//   65  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   66     void
//   67 clock_delay_usec(uint16_t len)
clock_delay_usec:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function clock_delay_usec
        CODE
//   68 {
        ; Saved register size: 0
        ; Auto size: 0
//   69     DISABLE_INTERRUPTS();
        CLR     0xa8.7
        SJMP    ??clock_delay_usec_0
//   70     while(len--) {
//   71         asm("nop");
??clock_delay_usec_1:
        nop
//   72     }
??clock_delay_usec_0:
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x1
        MOV     R2,A
        MOV     A,R1
        ADDC    A,#-0x1
        MOV     R3,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??clock_delay_usec_1
//   73     ENABLE_INTERRUPTS();
        SETB    0xa8.7
//   74 }
        LJMP    ?BRET
          CFI EndBlock cfiBlock0
        REQUIRE _A_IEN0
//   75 /*---------------------------------------------------------------------------*/
//   76 /**
//   77  * Wait for a multiple of ~8 ms (a tick)
//   78  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   79     void
//   80 clock_wait(clock_time_t i)
clock_wait:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function clock_wait
        CODE
//   81 {
        FUNCALL clock_wait, clock_time
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL clock_wait, clock_time
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
//   82     clock_time_t start;
//   83 
//   84     start = clock_time();
        ; Setup parameters for call to function clock_time
        LCALL   ??clock_time?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     R6,?V0 + 2
        MOV     R7,?V0 + 3
//   85     while(clock_time() - start < (clock_time_t)i);
??clock_wait_0:
        ; Setup parameters for call to function clock_time
        LCALL   ??clock_time?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R6
        MOV     R0,A
        MOV     A,?V0 + 3
        SUBB    A,R7
        MOV     R1,A
        CLR     C
        MOV     A,R0
        SUBB    A,?V0 + 0
        MOV     A,R1
        SUBB    A,?V0 + 1
        JC      ??clock_wait_0
//   86 }
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock1
//   87 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   88     CCIF clock_time_t
//   89 clock_time(void)
clock_time:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function clock_time
        CODE
//   90 {
        ; Saved register size: 0
        ; Auto size: 0
//   91     return count;
        MOV     R2,count+0x0
        MOV     R3,count+0x1
        LJMP    ?BRET
          CFI EndBlock cfiBlock2
//   92 }
//   93 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   94     CCIF unsigned long
//   95 clock_seconds(void)
clock_seconds:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function clock_seconds
        CODE
//   96 {
        PUSH    ?V0 + 0
          CFI V0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    ?V0 + 1
          CFI V1 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//   97     return seconds;
        MOV     ?V0 + 0,seconds+0x0
        MOV     ?V0 + 1,seconds+0x1
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        CLR     A
        MOV     R4,A
        MOV     R5,A
        POP     ?V0 + 1
          CFI V1 SameValue
          CFI CFA_SP SP+-4
        POP     ?V0 + 0
          CFI V0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock3
//   98 }
//   99 /*---------------------------------------------------------------------------*/
//  100 /*
//  101  * There is some ambiguity between TI cc2530 software examples and information
//  102  * in the datasheet.
//  103  *
//  104  * TI examples appear to be writing to SLEEPCMD, initialising hardware in a
//  105  * fashion semi-similar to cc2430
//  106  *
//  107  * However, the datasheet claims that those bits in SLEEPCMD are reserved
//  108  *
//  109  * The code here goes by the datasheet (ignore TI examples) and seems to work.
//  110  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  111     void
//  112 clock_init(void)
clock_init:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function clock_init
        CODE
//  113 {
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  114     /* Make sure we know where we stand */
//  115     CLKCONCMD = CLKCONCMD_OSC32K | CLKCONCMD_OSC;
        MOV     0xc6,#-0x40
//  116 
//  117     /* Stay with 32 KHz RC OSC, Chance System Clock to 32 MHz */
//  118     CLKCONCMD &= ~CLKCONCMD_OSC;
        ANL     0xc6,#0xbf
//  119     while(CLKCONSTA & CLKCONCMD_OSC);
??clock_init_0:
        MOV     A,0x9e
        MOV     C,0xE0 /* A   */.6
        JC      ??clock_init_0
//  120 
//  121     /* Tickspeed 500 kHz for timers[1-4] */
//  122     CLKCONCMD |= CLKCONCMD_TICKSPD2 | CLKCONCMD_TICKSPD1;
        ORL     0xc6,#0x30
//  123     while(CLKCONSTA != CLKCONCMD);
??clock_init_1:
        MOV     A,0xc6
        XRL     A,0x9e
        JNZ     ??clock_init_1
//  124 
//  125     /* Initialize tick value */
//  126     timer_value = ST0;
        MOV     A,0x95
        MOV     R0,A
        CLR     A
        MOV     R1,A
        MOV     R2,A
        MOV     R3,A
        MOV     timer_value+0x0,R0
        MOV     timer_value+0x1,R1
        MOV     timer_value+0x2,R2
        MOV     timer_value+0x3,R3
//  127     timer_value += ((unsigned long int)ST1) << 8;
        MOV     A,0x96
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     R0,#timer_value
        MOV     R1,#?V0 + 0
        LCALL   ?L_ADD
//  128     timer_value += ((unsigned long int)ST2) << 16;
        MOV     A,0x97
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     R0,#timer_value
        MOV     R1,#?V0 + 0
        LCALL   ?L_ADD
//  129     timer_value += TICK_VAL;
        MOV     DPTR,#__Constant_100
        MOV     R0,#timer_value
        LCALL   ?L_ADD_X
//  130     ST2 = (unsigned char)(timer_value >> 16);
        MOV     R1,#timer_value
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?UL_SHR
        MOV     A,?V0 + 0
        MOV     0x97,A
//  131     ST1 = (unsigned char)(timer_value >> 8);
        MOV     ?V0 + 0,timer_value+0x0
        MOV     ?V0 + 1,timer_value+0x1
        MOV     ?V0 + 2,timer_value+0x2
        MOV     ?V0 + 3,timer_value+0x3
        CLR     A
        MOV     A,?V0 + 1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 0
        MOV     0x96,A
//  132     ST0 = (unsigned char)timer_value;
        MOV     A,timer_value+0x0
        MOV     ?V0 + 1,timer_value+0x1
        MOV     ?V0 + 2,timer_value+0x2
        MOV     ?V0 + 3,timer_value+0x3
        MOV     0x95,A
//  133 
//  134     STIE = 1; /* IEN0.STIE interrupt enable */
        SETB    0xa8.5
//  135 
//  136 }
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock4
        REQUIRE CLKCONCMD
        REQUIRE CLKCONSTA
        REQUIRE ST0
        REQUIRE ST1
        REQUIRE ST2
        REQUIRE _A_IEN0
//  137 /*---------------------------------------------------------------------------*/
//  138 /* avoid referencing bits, we don't call code which use them */
//  139 #pragma save
//  140 #if CC_CONF_OPTIMIZE_STACK_SIZE
//  141 #pragma exclude bits
//  142 #endif
//  143 #pragma vector = ST_VECTOR

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  144 __interrupt void clock_isr(void)
clock_isr:
          CFI Block cfiBlock5 Using cfiCommon1
          CFI Function clock_isr
        CODE
//  145 {
        PUSH    A
          CFI A Frame(CFA_SP, 3)
          CFI CFA_SP SP+-3
        MOV     A,#-0x11
        LCALL   ?INTERRUPT_ENTER_XSP
          CFI B load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI PSW load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI R5 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R4 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R3 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI R2 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R1 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI R0 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI CFA_XSP16 add(XSP16, 17)
        ; Saved register size: 17
        ; Auto size: 0
//  146     DISABLE_INTERRUPTS();
        CLR     0xa8.7
//  147     ENERGEST_ON(ENERGEST_TYPE_IRQ);
        MOV     A,0xe2
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,0xe3
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R0,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R1,A
        MOV     DPTR,#energest_current_time + 4
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#energest_current_mode + 2
        MOV     A,#0x1
        MOVX    @DPTR,A
//  148 
//  149     /*
//  150      * Read value of the ST0:ST1:ST2, add TICK_VAL and write it back.
//  151      * Next interrupt occurs after the current time + TICK_VAL
//  152      */
//  153 
//  154     if(sleeping == 0)
        MOV     DPTR,#sleeping
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??clock_isr_0
//  155     {
//  156         timer_value = ST0;
        MOV     A,0x95
        MOV     R0,A
        CLR     A
        MOV     R1,A
        MOV     R2,A
        MOV     R3,A
        MOV     timer_value+0x0,R0
        MOV     timer_value+0x1,R1
        MOV     timer_value+0x2,R2
        MOV     timer_value+0x3,R3
//  157         timer_value += ((unsigned long int)ST1) << 8;
        MOV     A,0x96
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     R0,#timer_value
        MOV     R1,#?V0 + 0
        LCALL   ?L_ADD
//  158         timer_value += ((unsigned long int)ST2) << 16;
        MOV     A,0x97
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     R0,#timer_value
        MOV     R1,#?V0 + 0
        LCALL   ?L_ADD
//  159         timer_value += TICK_VAL;  //default: TICK_VAL, mine: TICK_VAL_MY
        MOV     DPTR,#__Constant_100
        MOV     R0,#timer_value
        LCALL   ?L_ADD_X
//  160         ST2 = (unsigned char)(timer_value >> 16);
        MOV     R1,#timer_value
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?UL_SHR
        MOV     A,?V0 + 0
        MOV     0x97,A
//  161         ST1 = (unsigned char)(timer_value >> 8);
        MOV     ?V0 + 0,timer_value+0x0
        MOV     ?V0 + 1,timer_value+0x1
        MOV     ?V0 + 2,timer_value+0x2
        MOV     ?V0 + 3,timer_value+0x3
        CLR     A
        MOV     A,?V0 + 1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 0
        MOV     0x96,A
//  162         ST0 = (unsigned char)timer_value;
        MOV     A,timer_value+0x0
        MOV     ?V0 + 1,timer_value+0x1
        MOV     ?V0 + 2,timer_value+0x2
        MOV     ?V0 + 3,timer_value+0x3
        MOV     0x95,A
        SJMP    ??clock_isr_1
//  163     }
//  164     else
//  165     {
//  166         sleeptimer = ST0;
??clock_isr_0:
        MOV     A,0x95
        MOV     R0,A
        CLR     A
        MOV     R1,A
        MOV     R2,A
        MOV     R3,A
        MOV     sleeptimer+0x0,R0
        MOV     sleeptimer+0x1,R1
        MOV     sleeptimer+0x2,R2
        MOV     sleeptimer+0x3,R3
//  167         sleeptimer += ((unsigned long int)ST1) << 8;
        MOV     A,0x96
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     A,#0x8
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     R0,#sleeptimer
        MOV     R1,#?V0 + 0
        LCALL   ?L_ADD
//  168         sleeptimer += ((unsigned long int)ST2) << 16;
        MOV     A,0x97
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?L_SHL
        MOV     R0,#sleeptimer
        MOV     R1,#?V0 + 0
        LCALL   ?L_ADD
//  169         sleeptimer += TICK_VAL_MY;  //default: TICK_VAL, mine: TICK_VAL_MY
        MOV     DPTR,#__Constant_18000
        MOV     R0,#sleeptimer
        LCALL   ?L_ADD_X
//  170         ST2 = (unsigned char)(sleeptimer >> 16);
        MOV     R1,#sleeptimer
        MOV     R0,#?V0 + 0
        LCALL   ?L_MOV
        MOV     A,#0x10
        MOV     R0,#?V0 + 0
        LCALL   ?UL_SHR
        MOV     A,?V0 + 0
        MOV     0x97,A
//  171         ST1 = (unsigned char)(sleeptimer >> 8);
        MOV     ?V0 + 0,sleeptimer+0x0
        MOV     ?V0 + 1,sleeptimer+0x1
        MOV     ?V0 + 2,sleeptimer+0x2
        MOV     ?V0 + 3,sleeptimer+0x3
        CLR     A
        MOV     A,?V0 + 1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 0
        MOV     0x96,A
//  172         ST0 = (unsigned char)sleeptimer;
        MOV     A,sleeptimer+0x0
        MOV     ?V0 + 1,sleeptimer+0x1
        MOV     ?V0 + 2,sleeptimer+0x2
        MOV     ?V0 + 3,sleeptimer+0x3
        MOV     0x95,A
//  173     }
//  174 
//  175 
//  176     ++count;
??clock_isr_1:
        MOV     R0,#count
        MOV     A,@R0
        ADD     A,#0x1
        MOV     @R0,A
        INC     R0
        MOV     A,@R0
        ADDC    A,#0x0
        MOV     @R0,A
        DEC     R0
//  177 
//  178     /* Make sure the CLOCK_CONF_SECOND is a power of two, to ensure
//  179        that the modulo operation below becomes a logical and and not
//  180        an expensive divide. Algorithm from Wikipedia:
//  181 http://en.wikipedia.org/wiki/Power_of_two */
//  182 #if (CLOCK_CONF_SECOND & (CLOCK_CONF_SECOND - 1)) != 0
//  183 #pragma error CLOCK_CONF_SECOND must be a power of two (i.e., 1, 2, 4, 8, 16, 32, 64, ...).
//  184 #pragma error Change CLOCK_CONF_SECOND in contiki-conf.h.
//  185 #endif
//  186     if(count % CLOCK_CONF_SECOND == 0) {
        MOV     R0,count+0x0
        MOV     R1,count+0x1
        MOV     R2,#-0x80
        MOV     R3,#0x0
        LCALL   ?US_DIV_MOD
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??clock_isr_2
//  187         ++seconds;
        MOV     R0,#seconds
        MOV     A,@R0
        ADD     A,#0x1
        MOV     @R0,A
        INC     R0
        MOV     A,@R0
        ADDC    A,#0x0
        MOV     @R0,A
        DEC     R0
//  188     }
//  189 
//  190 #if CLOCK_CONF_STACK_FRIENDLY
//  191     sleep_flag = 1;
??clock_isr_2:
        MOV     DPTR,#sleep_flag
        MOV     A,#0x1
        MOVX    @DPTR,A
//  192 #else
//  193     if(etimer_pending()
//  194             && (etimer_next_expiration_time() - count - 1) > MAX_TICKS) {
//  195         etimer_request_poll();
//  196     }
//  197 #endif
//  198 
//  199     STIF = 0; /* IRCON.STIF */
        CLR     0xc0.7
//  200     ENERGEST_OFF(ENERGEST_TYPE_IRQ);
        MOV     DPTR,#energest_current_mode + 2
        MOVX    A,@DPTR
        JZ      ??clock_isr_3
        MOV     A,0xe2
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,0xe3
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     A,R2
        ADD     A,R0
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R1
        MOV     R3,A
        MOV     DPTR,#energest_current_time + 4
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        CLR     C
        SUBB    A,R0
        MOV     ?V0 + 0,A
        MOV     A,R3
        SUBB    A,R1
        MOV     ?V0 + 1,A
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     DPTR,#energest_total_time + 8
        MOV     R0,#?V0 + 0
        LCALL   ?L_ADD_TO_X
        MOV     DPTR,#energest_current_mode + 2
        MOV     A,#0x0
        MOVX    @DPTR,A
//  201     ENABLE_INTERRUPTS();
??clock_isr_3:
        SETB    0xa8.7
//  202 }
        MOV     R7,#0x4
        LJMP    ?INTERRUPT_LEAVE_XSP
          CFI EndBlock cfiBlock5
        REQUIRE _A_IEN0
        REQUIRE T1CNTL
        REQUIRE T1CNTH
        REQUIRE ST0
        REQUIRE ST1
        REQUIRE ST2
        REQUIRE _A_IRCON
//  203 #pragma restore
//  204 /*---------------------------------------------------------------------------*/
//  205 
//  206 //---------------------added by dongbo huang---------------------------

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  207 int clock_getSleepState()
clock_getSleepState:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function clock_getSleepState
        CODE
//  208 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  209     return sleeping;
        MOV     DPTR,#sleeping
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock6
//  210 }
//  211 

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  212 void clock_setSleepState(int state)
clock_setSleepState:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function clock_setSleepState
        CODE
//  213 {
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  214     sleeping = state;
        MOV     DPTR,#sleeping
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
//  215 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock7

        COMMON INTVEC:CODE:ROOT(0)
        ORG 43
`??clock_isr??INTVEC 43`:
        LJMP       (clock_isr)

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_100:
        DS 4
        REQUIRE `?<Initializer for __Constant_100>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_100>`:
        DATA32
        DD 256

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_18000:
        DS 4
        REQUIRE `?<Initializer for __Constant_18000>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_18000>`:
        DATA32
        DD 98304

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_delay_usec?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_delay_usec

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_wait?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_wait

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_time?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_time

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_seconds?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_seconds

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_init?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_getSleepState?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_getSleepState

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??clock_setSleepState?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    clock_setSleepState

        END
//  216 //-------------------------------------------------------------------
// 
// 303 bytes in segment BANKED_CODE
//  42 bytes in segment BANK_RELAYS
//  12 bytes in segment DATA_Z
//   3 bytes in segment INTVEC
// 427 bytes in segment NEAR_CODE
//   9 bytes in segment SFR_AN
//   8 bytes in segment XDATA_I
//   8 bytes in segment XDATA_ID
//   3 bytes in segment XDATA_Z
// 
// 772 bytes of CODE  memory (+ 11 bytes shared)
//  12 bytes of DATA  memory (+  9 bytes shared)
//   3 bytes of XDATA memory (+  8 bytes shared)
//
//Errors: none
//Warnings: 2
