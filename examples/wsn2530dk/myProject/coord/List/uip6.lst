###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             03/Apr/2014  10:45:55 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\myWork\myWork\core\net\uip6.c                   #
#    Command line       =  D:\myWork\myWork\core\net\uip6.c -D                #
#                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC             #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\ -lA D:\myWork\myWork\examples\wsn2530dk\my #
#                          Project\coord\List\ --diag_suppress                #
#                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o          #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\ -e --no_cse --no_unroll --no_inline         #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 --preinclude D:\myWork\myWork\examples\wsn2530d #
#                          k\myProject\..\..\..\cpu\cc253x\cc253x.h -I        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\cpu\cc253x\ -I D:\myWork\myWork\examples\wsn2 #
#                          530dk\myProject\..\..\..\platform\wsn2530dk\ -I    #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\core\ -I D:\myWork\myWork\examples\wsn2530dk\ #
#                          myProject\..\..\..\apps\ -I                        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\ -Ol #
#    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\uip6.lst                                    #
#    Object file        =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\uip6.r51                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\myWork\myWork\core\net\uip6.c
      1          /**
      2           * \addtogroup uip6
      3           * @{
      4           */
      5          
      6          /**
      7           * \file
      8           *         The uIP TCP/IPv6 stack code.
      9           *
     10           * \author Adam Dunkels <adam@sics.se>
     11           * \author Julien Abeille <jabeille@cisco.com> (IPv6 related code)
     12           * \author Mathilde Durvy <mdurvy@cisco.com> (IPv6 related code)
     13           */
     14          /*
     15           * Copyright (c) 2001-2003, Adam Dunkels.
     16           * All rights reserved.
     17           *
     18           * Redistribution and use in source and binary forms, with or without
     19           * modification, are permitted provided that the following conditions
     20           * are met:
     21           * 1. Redistributions of source code must retain the above copyright
     22           *    notice, this list of conditions and the following disclaimer.
     23           * 2. Redistributions in binary form must reproduce the above copyright
     24           *    notice, this list of conditions and the following disclaimer in the
     25           *    documentation and/or other materials provided with the distribution.
     26           * 3. The name of the author may not be used to endorse or promote
     27           *    products derived from this software without specific prior
     28           *    written permission.
     29           *
     30           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
     31           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     32           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     33           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
     34           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     35           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
     36           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     37           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
     38           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     39           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     40           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     41           *
     42           * This file is part of the uIP TCP/IP stack.
     43           *
     44           *
     45           */
     46          
     47          /*
     48           * uIP is a small implementation of the IP, UDP and TCP protocols (as
     49           * well as some basic ICMP stuff). The implementation couples the IP,
     50           * UDP, TCP and the application layers very tightly. To keep the size
     51           * of the compiled code down, this code frequently uses the goto
     52           * statement. While it would be possible to break the uip_process()
     53           * function into many smaller functions, this would increase the code
     54           * size because of the overhead of parameter passing and the fact that
     55           * the optimizer would not be as efficient.
     56           *
     57           * The principle is that we have a small buffer, called the uip_buf,
     58           * in which the device driver puts an incoming packet. The TCP/IP
     59           * stack parses the headers in the packet, and calls the
     60           * application. If the remote host has sent data to the application,
     61           * this data is present in the uip_buf and the application read the
     62           * data from there. It is up to the application to put this data into
     63           * a byte stream if needed. The application will not be fed with data
     64           * that is out of sequence.
     65           *
     66           * If the application wishes to send data to the peer, it should put
     67           * its data into the uip_buf. The uip_appdata pointer points to the
     68           * first available byte. The TCP/IP stack will calculate the
     69           * checksums, and fill in the necessary header fields and finally send
     70           * the packet back to the peer.
     71           */
     72          
     73          #include "net/uip.h"
     74          #include "net/uipopt.h"
     75          #include "net/uip-icmp6.h"
     76          #include "net/uip-nd6.h"
     77          #include "net/uip-ds6.h"
     78          
     79          #include <string.h>
     80          
     81          #if UIP_CONF_IPV6
     82          /*---------------------------------------------------------------------------*/
     83          /* For Debug, logging, statistics                                            */
     84          /*---------------------------------------------------------------------------*/
     85          
     86          #define DEBUG DEBUG_NONE
     87          #include "net/uip-debug.h"
     88          
     89          #if UIP_CONF_IPV6_RPL
     90          #include "rpl/rpl.h"
     91          #endif /* UIP_CONF_IPV6_RPL */
     92          
     93          #if UIP_LOGGING == 1
     94          #include <stdio.h>
     95          void uip_log(char *msg);
     96          #define UIP_LOG(m) uip_log(m)
     97          #else
     98          #define UIP_LOG(m)
     99          #endif /* UIP_LOGGING == 1 */
    100          
    101          #if UIP_STATISTICS == 1
    102          struct uip_stats uip_stat;
    103          #endif /* UIP_STATISTICS == 1 */
    104           
    105          
    106          /*---------------------------------------------------------------------------*/
    107          /** @{ \name Layer 2 variables */
    108          /*---------------------------------------------------------------------------*/
    109          /** Host L2 address */
    110          #if UIP_CONF_LL_802154

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          uip_lladdr_t uip_lladdr;
   \                     uip_lladdr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    112          #else /*UIP_CONF_LL_802154*/
    113          uip_lladdr_t uip_lladdr = {{0x00,0x06,0x98,0x00,0x02,0x32}};
    114          #endif /*UIP_CONF_LL_802154*/
    115          /** @} */
    116          
    117          /*---------------------------------------------------------------------------*/
    118          /** @{ \name Layer 3 variables */
    119          /*---------------------------------------------------------------------------*/
    120          /**
    121           * \brief Type of the next header in IPv6 header or extension headers
    122           *
    123           * Can be the next header field in the IPv6 header or in an extension header.
    124           * When doing fragment reassembly, we must change the value of the next header
    125           * field in the header before the fragmentation header, hence we need a pointer
    126           * to this field.
    127           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    128          uint8_t *uip_next_hdr;
   \                     uip_next_hdr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    129          /** \brief bitmap we use to record which IPv6 headers we have already seen */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    130          uint8_t uip_ext_bitmap = 0;
   \                     uip_ext_bitmap:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    131          /**
    132           * \brief length of the extension headers read. updated each time we process
    133           * a header
    134           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          uint8_t uip_ext_len = 0;
   \                     uip_ext_len:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    136          /** \brief length of the header options read */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    137          uint8_t uip_ext_opt_offset = 0;
   \                     uip_ext_opt_offset:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    138          /** @} */
    139          
    140          /*---------------------------------------------------------------------------*/
    141          /* Buffers                                                                   */
    142          /*---------------------------------------------------------------------------*/
    143          /** \name Buffer defines
    144           *  @{
    145           */
    146          #define FBUF                             ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
    147          #define UIP_IP_BUF                          ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
    148          #define UIP_ICMP_BUF                      ((struct uip_icmp_hdr *)&uip_buf[uip_l2_l3_hdr_len])
    149          #define UIP_UDP_BUF                        ((struct uip_udp_hdr *)&uip_buf[UIP_LLH_LEN + UIP_IPH_LEN])
    150          #define UIP_TCP_BUF                        ((struct uip_tcp_hdr *)&uip_buf[UIP_LLH_LEN + UIP_IPH_LEN])
    151          #define UIP_EXT_BUF                        ((struct uip_ext_hdr *)&uip_buf[uip_l2_l3_hdr_len])
    152          #define UIP_ROUTING_BUF                ((struct uip_routing_hdr *)&uip_buf[uip_l2_l3_hdr_len])
    153          #define UIP_FRAG_BUF                      ((struct uip_frag_hdr *)&uip_buf[uip_l2_l3_hdr_len])
    154          #define UIP_HBHO_BUF                      ((struct uip_hbho_hdr *)&uip_buf[uip_l2_l3_hdr_len])
    155          #define UIP_DESTO_BUF                    ((struct uip_desto_hdr *)&uip_buf[uip_l2_l3_hdr_len])
    156          #define UIP_EXT_HDR_OPT_BUF            ((struct uip_ext_hdr_opt *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
    157          #define UIP_EXT_HDR_OPT_PADN_BUF  ((struct uip_ext_hdr_opt_padn *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
    158          #if UIP_CONF_IPV6_RPL
    159          #define UIP_EXT_HDR_OPT_RPL_BUF    ((struct uip_ext_hdr_opt_rpl *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
    160          #endif /* UIP_CONF_IPV6_RPL */
    161          #define UIP_ICMP6_ERROR_BUF            ((struct uip_icmp6_error *)&uip_buf[uip_l2_l3_icmp_hdr_len])
    162          /** @} */
    163          /** \name Buffer variables
    164           *  @{
    165           */
    166          /** Packet buffer for incoming and outgoing packets */
    167          #ifndef UIP_CONF_EXTERNAL_BUFFER

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    168          uip_buf_t uip_aligned_buf;
   \                     uip_aligned_buf:
   \   000000                DS 240
   \   0000F0                REQUIRE __INIT_XDATA_Z
    169          #endif /* UIP_CONF_EXTERNAL_BUFFER */
    170          
    171          /* The uip_appdata pointer points to application data. */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    172          void *uip_appdata;
   \                     uip_appdata:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    173          /* The uip_appdata pointer points to the application data which is to be sent*/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    174          void *uip_sappdata;
   \                     uip_sappdata:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    175          
    176          #if UIP_URGDATA > 0
    177          /* The uip_urgdata pointer points to urgent data (out-of-band data), if present */
    178          void *uip_urgdata;
    179          uint16_t uip_urglen, uip_surglen;
    180          #endif /* UIP_URGDATA > 0 */
    181          
    182          /* The uip_len is either 8 or 16 bits, depending on the maximum packet size.*/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          uint16_t uip_len, uip_slen;
   \                     uip_len:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     uip_slen:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          /** @} */
    185          
    186          /*---------------------------------------------------------------------------*/
    187          /** @{ \name General variables                                               */
    188          /*---------------------------------------------------------------------------*/
    189          
    190          /* The uip_flags variable is used for communication between the TCP/IP stack
    191          and the application program. */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    192          uint8_t uip_flags;
   \                     uip_flags:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    193          
    194          /* uip_conn always points to the current connection (set to NULL for UDP). */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    195          struct uip_conn *uip_conn;
   \                     uip_conn:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    196          
    197          /* Temporary variables. */
    198          #if (UIP_TCP || UIP_UDP)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    199          static uint8_t c;
   \                     `c`:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    200          #endif
    201          
    202          #if UIP_ACTIVE_OPEN || UIP_UDP
    203          /* Keeps track of the last port used for a new connection. */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    204          static uint16_t lastport;
   \                     lastport:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    205          #endif /* UIP_ACTIVE_OPEN || UIP_UDP */
    206          /** @} */
    207          
    208          /*---------------------------------------------------------------------------*/
    209          /* TCP                                                                       */
    210          /*---------------------------------------------------------------------------*/
    211          /** \name TCP defines
    212           *@{
    213           */
    214          /* Structures and definitions. */
    215          #define TCP_FIN 0x01
    216          #define TCP_SYN 0x02
    217          #define TCP_RST 0x04
    218          #define TCP_PSH 0x08
    219          #define TCP_ACK 0x10
    220          #define TCP_URG 0x20
    221          #define TCP_CTL 0x3f
    222          
    223          #define TCP_OPT_END     0   /* End of TCP options list */
    224          #define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
    225          #define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
    226          
    227          #define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
    228          /** @} */
    229          /** \name TCP variables
    230           *@{
    231           */
    232          #if UIP_TCP
    233          /* The uip_conns array holds all TCP connections. */
    234          struct uip_conn uip_conns[UIP_CONNS];
    235          
    236          /* The uip_listenports list all currently listning ports. */
    237          uint16_t uip_listenports[UIP_LISTENPORTS];
    238          
    239          /* The iss variable is used for the TCP initial sequence number. */
    240          static uint8_t iss[4];
    241          
    242          /* Temporary variables. */
    243          uint8_t uip_acc32[4];
    244          static uint8_t opt;
    245          static uint16_t tmp16;
    246          #endif /* UIP_TCP */
    247          /** @} */
    248          
    249          /*---------------------------------------------------------------------------*/
    250          /** @{ \name UDP variables                                                   */
    251          /*---------------------------------------------------------------------------*/
    252          #if UIP_UDP

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    253          struct uip_udp_conn *uip_udp_conn;
   \                     uip_udp_conn:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    254          struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
   \                     uip_udp_conns:
   \   000000                DS 250
   \   0000FA                REQUIRE __INIT_XDATA_Z
    255          #endif /* UIP_UDP */
    256          /** @} */
    257          
    258          /*---------------------------------------------------------------------------*/
    259          /** @{ \name ICMPv6 variables                                                */
    260          /*---------------------------------------------------------------------------*/
    261          #if UIP_CONF_ICMP6
    262          /** single possible icmpv6 "connection" */
    263          struct uip_icmp6_conn uip_icmp6_conns;
    264          #endif /*UIP_CONF_ICMP6*/
    265          /** @} */
    266          
    267          /*---------------------------------------------------------------------------*/
    268          /* Functions                                                                 */
    269          /*---------------------------------------------------------------------------*/
    270          #if (!UIP_ARCH_ADD32 && UIP_TCP)
    271          void
    272          uip_add32(uint8_t *op32, uint16_t op16)
    273          {
    274            uip_acc32[3] = op32[3] + (op16 & 0xff);
    275            uip_acc32[2] = op32[2] + (op16 >> 8);
    276            uip_acc32[1] = op32[1];
    277            uip_acc32[0] = op32[0];
    278            
    279            if(uip_acc32[2] < (op16 >> 8)) {
    280              ++uip_acc32[1];
    281              if(uip_acc32[1] == 0) {
    282                ++uip_acc32[0];
    283              }
    284            }
    285            
    286            
    287            if(uip_acc32[3] < (op16 & 0xff)) {
    288              ++uip_acc32[2];
    289              if(uip_acc32[2] == 0) {
    290                ++uip_acc32[1];
    291                if(uip_acc32[1] == 0) {
    292                  ++uip_acc32[0];
    293                }
    294              }
    295            }
    296          }
    297          
    298          #endif /* UIP_ARCH_ADD32 && UIP_TCP */
    299          
    300          #if ! UIP_ARCH_CHKSUM
    301          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    302          static uint16_t
    303          chksum(uint16_t sum, const uint8_t *data, uint16_t len)
   \                     chksum:
    304          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   740A         MOV     A,#0xa
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FE           MOV     R6,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FF           MOV     R7,A
    305            uint16_t t;
    306            const uint8_t *dataptr;
    307            const uint8_t *last_byte;
    308          
    309            dataptr = data;
   \   00000F   EC           MOV     A,R4
   \   000010   F8           MOV     R0,A
   \   000011   ED           MOV     A,R5
   \   000012   F9           MOV     R1,A
    310            last_byte = data + len - 1;
   \   000013   EC           MOV     A,R4
   \   000014   2E           ADD     A,R6
   \   000015   FC           MOV     R4,A
   \   000016   ED           MOV     A,R5
   \   000017   3F           ADDC    A,R7
   \   000018   FD           MOV     R5,A
   \   000019   EC           MOV     A,R4
   \   00001A   24FF         ADD     A,#-0x1
   \   00001C   FE           MOV     R6,A
   \   00001D   ED           MOV     A,R5
   \   00001E   34FF         ADDC    A,#-0x1
   \   000020   FF           MOV     R7,A
   \   000021   803B         SJMP    ??chksum_0
    311            
    312            while(dataptr < last_byte) {   /* At least two more bytes */
    313              t = (dataptr[0] << 8) + dataptr[1];
   \                     ??chksum_1:
   \   000023   8882         MOV     DPL,R0
   \   000025   8983         MOV     DPH,R1
   \   000027   E0           MOVX    A,@DPTR
   \   000028   FC           MOV     R4,A
   \   000029   7D00         MOV     R5,#0x0
   \   00002B   E4           CLR     A
   \   00002C   CC           XCH     A,R4
   \   00002D   FD           MOV     R5,A
   \   00002E   8882         MOV     DPL,R0
   \   000030   8983         MOV     DPH,R1
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F5..         MOV     ?V0 + 0,A
   \   000036   75..00       MOV     ?V0 + 1,#0x0
   \   000039   EC           MOV     A,R4
   \   00003A   25..         ADD     A,?V0 + 0
   \   00003C   FC           MOV     R4,A
   \   00003D   ED           MOV     A,R5
   \   00003E   35..         ADDC    A,?V0 + 1
   \   000040   FD           MOV     R5,A
    314              sum += t;
   \   000041   EA           MOV     A,R2
   \   000042   2C           ADD     A,R4
   \   000043   FA           MOV     R2,A
   \   000044   EB           MOV     A,R3
   \   000045   3D           ADDC    A,R5
   \   000046   FB           MOV     R3,A
    315              if(sum < t) {
   \   000047   C3           CLR     C
   \   000048   EA           MOV     A,R2
   \   000049   9C           SUBB    A,R4
   \   00004A   EB           MOV     A,R3
   \   00004B   9D           SUBB    A,R5
   \   00004C   5008         JNC     ??chksum_2
    316                sum++;      /* carry */
   \   00004E   EA           MOV     A,R2
   \   00004F   2401         ADD     A,#0x1
   \   000051   FA           MOV     R2,A
   \   000052   EB           MOV     A,R3
   \   000053   3400         ADDC    A,#0x0
   \   000055   FB           MOV     R3,A
    317              }
    318              dataptr += 2;
   \                     ??chksum_2:
   \   000056   E8           MOV     A,R0
   \   000057   2402         ADD     A,#0x2
   \   000059   F8           MOV     R0,A
   \   00005A   E9           MOV     A,R1
   \   00005B   3400         ADDC    A,#0x0
   \   00005D   F9           MOV     R1,A
    319            }
   \                     ??chksum_0:
   \   00005E   EE           MOV     A,R6
   \   00005F   FC           MOV     R4,A
   \   000060   EF           MOV     A,R7
   \   000061   FD           MOV     R5,A
   \   000062   C3           CLR     C
   \   000063   E8           MOV     A,R0
   \   000064   9C           SUBB    A,R4
   \   000065   E9           MOV     A,R1
   \   000066   9D           SUBB    A,R5
   \   000067   40BA         JC      ??chksum_1
    320            
    321            if(dataptr == last_byte) {
   \   000069   EE           MOV     A,R6
   \   00006A   68           XRL     A,R0
   \   00006B   7002         JNZ     ??chksum_3
   \   00006D   EF           MOV     A,R7
   \   00006E   69           XRL     A,R1
   \                     ??chksum_3:
   \   00006F   7020         JNZ     ??chksum_4
    322              t = (dataptr[0] << 8) + 0;
   \   000071   8882         MOV     DPL,R0
   \   000073   8983         MOV     DPH,R1
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FC           MOV     R4,A
   \   000077   7D00         MOV     R5,#0x0
   \   000079   E4           CLR     A
   \   00007A   CC           XCH     A,R4
   \   00007B   FD           MOV     R5,A
    323              sum += t;
   \   00007C   EA           MOV     A,R2
   \   00007D   2C           ADD     A,R4
   \   00007E   FA           MOV     R2,A
   \   00007F   EB           MOV     A,R3
   \   000080   3D           ADDC    A,R5
   \   000081   FB           MOV     R3,A
    324              if(sum < t) {
   \   000082   C3           CLR     C
   \   000083   EA           MOV     A,R2
   \   000084   9C           SUBB    A,R4
   \   000085   EB           MOV     A,R3
   \   000086   9D           SUBB    A,R5
   \   000087   5008         JNC     ??chksum_4
    325                sum++;      /* carry */
   \   000089   EA           MOV     A,R2
   \   00008A   2401         ADD     A,#0x1
   \   00008C   FA           MOV     R2,A
   \   00008D   EB           MOV     A,R3
   \   00008E   3400         ADDC    A,#0x0
   \   000090   FB           MOV     R3,A
    326              }
    327            }
    328          
    329            /* Return sum in host byte order. */
    330            return sum;
   \                     ??chksum_4:
   \   000091   7F02         MOV     R7,#0x2
   \   000093   02....       LJMP    ?BANKED_LEAVE_XDATA
    331          }
    332          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    333          uint16_t
    334          uip_chksum(uint16_t *data, uint16_t len)
   \                     uip_chksum:
    335          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    336            return uip_htons(chksum(0, (uint8_t *)data, len));
   \   000005                ; Setup parameters for call to function uip_htons
   \   000005                ; Setup parameters for call to function chksum
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000E   EA           MOV     A,R2
   \   00000F   FC           MOV     R4,A
   \   000010   EB           MOV     A,R3
   \   000011   FD           MOV     R5,A
   \   000012   7A00         MOV     R2,#0x0
   \   000014   7B00         MOV     R3,#0x0
   \   000016   12....       LCALL   ??chksum?relay
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001E   12....       LCALL   ??uip_htons?relay
   \   000021   7F02         MOV     R7,#0x2
   \   000023   02....       LJMP    ?BANKED_LEAVE_XDATA
    337          }
    338          /*---------------------------------------------------------------------------*/
    339          #ifndef UIP_ARCH_IPCHKSUM

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    340          uint16_t
    341          uip_ipchksum(void)
   \                     uip_ipchksum:
    342          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    343            uint16_t sum;
    344          
    345            sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
   \   000005                ; Setup parameters for call to function chksum
   \   000005   75..28       MOV     ?V0 + 0,#0x28
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   7C..         MOV     R4,#uip_aligned_buf & 0xff
   \   000012   7D..         MOV     R5,#(uip_aligned_buf >> 8) & 0xff
   \   000014   7A00         MOV     R2,#0x0
   \   000016   7B00         MOV     R3,#0x0
   \   000018   12....       LCALL   ??chksum?relay
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020   8A..         MOV     ?V0 + 0,R2
   \   000022   8B..         MOV     ?V0 + 1,R3
   \   000024   AA..         MOV     R2,?V0 + 0
   \   000026   AB..         MOV     R3,?V0 + 1
    346            PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
    347            return (sum == 0) ? 0xffff : uip_htons(sum);
   \   000028   EA           MOV     A,R2
   \   000029   4B           ORL     A,R3
   \   00002A   7006         JNZ     ??uip_ipchksum_0
   \   00002C   7AFF         MOV     R2,#-0x1
   \   00002E   7BFF         MOV     R3,#-0x1
   \   000030   800B         SJMP    ??uip_ipchksum_1
   \                     ??uip_ipchksum_0:
   \   000032                ; Setup parameters for call to function uip_htons
   \   000032   12....       LCALL   ??uip_htons?relay
   \   000035   8A..         MOV     ?V0 + 0,R2
   \   000037   8B..         MOV     ?V0 + 1,R3
   \   000039   AA..         MOV     R2,?V0 + 0
   \   00003B   AB..         MOV     R3,?V0 + 1
   \                     ??uip_ipchksum_1:
   \   00003D   7F02         MOV     R7,#0x2
   \   00003F   02....       LJMP    ?BANKED_LEAVE_XDATA
    348          }
    349          #endif
    350          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    351          static uint16_t
    352          upper_layer_chksum(uint8_t proto)
   \                     upper_layer_chksum:
    353          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    354          /* gcc 4.4.0 - 4.6.1 (maybe 4.3...) with -Os on 8 bit CPUS incorrectly compiles:
    355           * int bar (int);
    356           * int foo (unsigned char a, unsigned char b) {
    357           *   int len = (a << 8) + b; //len becomes 0xff00&<random>+b
    358           *   return len + bar (len);
    359           * }
    360           * upper_layer_len triggers this bug unless it is declared volatile.
    361           * See https://sourceforge.net/apps/mantisbt/contiki/view.php?id=3
    362           */
    363            volatile uint16_t upper_layer_len;
    364            uint16_t sum;
    365            
    366            upper_layer_len = (((uint16_t)(UIP_IP_BUF->len[0]) << 8) + UIP_IP_BUF->len[1] - uip_ext_len);
   \   00000C   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   7900         MOV     R1,#0x0
   \   000013   E4           CLR     A
   \   000014   C8           XCH     A,R0
   \   000015   F9           MOV     R1,A
   \   000016   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FA           MOV     R2,A
   \   00001B   7B00         MOV     R3,#0x0
   \   00001D   E8           MOV     A,R0
   \   00001E   2A           ADD     A,R2
   \   00001F   F8           MOV     R0,A
   \   000020   E9           MOV     A,R1
   \   000021   3B           ADDC    A,R3
   \   000022   F9           MOV     R1,A
   \   000023   90....       MOV     DPTR,#uip_ext_len
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FA           MOV     R2,A
   \   000028   7B00         MOV     R3,#0x0
   \   00002A   E8           MOV     A,R0
   \   00002B   C3           CLR     C
   \   00002C   9A           SUBB    A,R2
   \   00002D   F8           MOV     R0,A
   \   00002E   E9           MOV     A,R1
   \   00002F   9B           SUBB    A,R3
   \   000030   F9           MOV     R1,A
   \   000031   85..82       MOV     DPL,?XSP + 0
   \   000034   85..83       MOV     DPH,?XSP + 1
   \   000037   E8           MOV     A,R0
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   E9           MOV     A,R1
   \   00003B   F0           MOVX    @DPTR,A
    367            
    368            PRINTF("Upper layer checksum len: %d from: %d\n", upper_layer_len,
    369          	 UIP_IPH_LEN + UIP_LLH_LEN + uip_ext_len);
    370          
    371            /* First sum pseudoheader. */
    372            /* IP protocol and length fields. This addition cannot carry. */
    373            sum = upper_layer_len + proto;
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   8E..         MOV     ?V0 + 0,R6
   \   000044   75..00       MOV     ?V0 + 1,#0x0
   \   000047   E0           MOVX    A,@DPTR
   \   000048   25..         ADD     A,?V0 + 0
   \   00004A   FA           MOV     R2,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   35..         ADDC    A,?V0 + 1
   \   00004F   FB           MOV     R3,A
    374            /* Sum IP source and destination addresses. */
    375            sum = chksum(sum, (uint8_t *)&UIP_IP_BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
   \   000050                ; Setup parameters for call to function chksum
   \   000050   75..20       MOV     ?V0 + 0,#0x20
   \   000053   75..00       MOV     ?V0 + 1,#0x0
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C..         MOV     R4,#(uip_aligned_buf + 8) & 0xff
   \   00005D   7D..         MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   00005F   12....       LCALL   ??chksum?relay
   \   000062   7402         MOV     A,#0x2
   \   000064   12....       LCALL   ?DEALLOC_XSTACK8
   \   000067   8A..         MOV     ?V0 + 0,R2
   \   000069   8B..         MOV     ?V0 + 1,R3
   \   00006B   AA..         MOV     R2,?V0 + 0
   \   00006D   AB..         MOV     R3,?V0 + 1
    376          
    377            /* Sum TCP header and data. */
    378            sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN + uip_ext_len],
    379                         upper_layer_len);
   \   00006F                ; Setup parameters for call to function chksum
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000078   90....       MOV     DPTR,#uip_ext_len
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   7900         MOV     R1,#0x0
   \   00007F   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   000081   28           ADD     A,R0
   \   000082   FC           MOV     R4,A
   \   000083   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000085   39           ADDC    A,R1
   \   000086   FD           MOV     R5,A
   \   000087   12....       LCALL   ??chksum?relay
   \   00008A   7402         MOV     A,#0x2
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008F   8A..         MOV     ?V0 + 0,R2
   \   000091   8B..         MOV     ?V0 + 1,R3
   \   000093   AA..         MOV     R2,?V0 + 0
   \   000095   AB..         MOV     R3,?V0 + 1
    380              
    381            return (sum == 0) ? 0xffff : uip_htons(sum);
   \   000097   EA           MOV     A,R2
   \   000098   4B           ORL     A,R3
   \   000099   7006         JNZ     ??upper_layer_chksum_0
   \   00009B   7AFF         MOV     R2,#-0x1
   \   00009D   7BFF         MOV     R3,#-0x1
   \   00009F   800B         SJMP    ??upper_layer_chksum_1
   \                     ??upper_layer_chksum_0:
   \   0000A1                ; Setup parameters for call to function uip_htons
   \   0000A1   12....       LCALL   ??uip_htons?relay
   \   0000A4   8A..         MOV     ?V0 + 0,R2
   \   0000A6   8B..         MOV     ?V0 + 1,R3
   \   0000A8   AA..         MOV     R2,?V0 + 0
   \   0000AA   AB..         MOV     R3,?V0 + 1
   \                     ??upper_layer_chksum_1:
   \   0000AC   7402         MOV     A,#0x2
   \   0000AE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B1   7F02         MOV     R7,#0x2
   \   0000B3   02....       LJMP    ?BANKED_LEAVE_XDATA
    382          }
    383          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    384          uint16_t
    385          uip_icmp6chksum(void)
   \                     uip_icmp6chksum:
    386          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    387            return upper_layer_chksum(UIP_PROTO_ICMP6);
   \   000004                ; Setup parameters for call to function upper_layer_chksum
   \   000004   793A         MOV     R1,#0x3a
   \   000006   12....       LCALL   ??upper_layer_chksum?relay
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   02....       LJMP    ?BRET
    388            
    389          }
    390          /*---------------------------------------------------------------------------*/
    391          #if UIP_TCP
    392          uint16_t
    393          uip_tcpchksum(void)
    394          {
    395            return upper_layer_chksum(UIP_PROTO_TCP);
    396          }
    397          #endif /* UIP_TCP */
    398          /*---------------------------------------------------------------------------*/
    399          #if UIP_UDP && UIP_UDP_CHECKSUMS

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    400          uint16_t
    401          uip_udpchksum(void)
   \                     uip_udpchksum:
    402          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    403            return upper_layer_chksum(UIP_PROTO_UDP);
   \   000004                ; Setup parameters for call to function upper_layer_chksum
   \   000004   7911         MOV     R1,#0x11
   \   000006   12....       LCALL   ??upper_layer_chksum?relay
   \   000009   D083         POP     DPH
   \   00000B   D082         POP     DPL
   \   00000D   02....       LJMP    ?BRET
    404          }
    405          #endif /* UIP_UDP && UIP_UDP_CHECKSUMS */
    406          #endif /* UIP_ARCH_CHKSUM */
    407          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void
    409          uip_init(void)
   \                     uip_init:
    410          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    411             
    412            uip_ds6_init();
   \   000004                ; Setup parameters for call to function uip_ds6_init
   \   000004   12....       LCALL   ??uip_ds6_init?relay
    413          
    414          #if UIP_TCP
    415            for(c = 0; c < UIP_LISTENPORTS; ++c) {
    416              uip_listenports[c] = 0;
    417            }
    418            for(c = 0; c < UIP_CONNS; ++c) {
    419              uip_conns[c].tcpstateflags = UIP_CLOSED;
    420            }
    421          #endif /* UIP_TCP */
    422          
    423          #if UIP_ACTIVE_OPEN || UIP_UDP
    424            lastport = 1024;
   \   000007   90....       MOV     DPTR,#lastport
   \   00000A   7400         MOV     A,#0x0
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   A3           INC     DPTR
   \   00000E   7404         MOV     A,#0x4
   \   000010   F0           MOVX    @DPTR,A
    425          #endif /* UIP_ACTIVE_OPEN || UIP_UDP */
    426          
    427          #if UIP_UDP
    428            for(c = 0; c < UIP_UDP_CONNS; ++c) {
   \   000011   90....       MOV     DPTR,#`c`
   \   000014   7400         MOV     A,#0x0
   \   000016   F0           MOVX    @DPTR,A
   \   000017   8034         SJMP    ??uip_init_0
    429              uip_udp_conns[c].lport = 0;
   \                     ??uip_init_1:
   \   000019   90....       MOV     DPTR,#`c`
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   7900         MOV     R1,#0x0
   \   000020   E8           MOV     A,R0
   \   000021   75F019       MOV     B,#0x19
   \   000024   A4           MUL     AB
   \   000025   C8           XCH     A,R0
   \   000026   AAF0         MOV     R2,B
   \   000028   75F000       MOV     B,#0x0
   \   00002B   A4           MUL     AB
   \   00002C   2A           ADD     A,R2
   \   00002D   FA           MOV     R2,A
   \   00002E   75F019       MOV     B,#0x19
   \   000031   E9           MOV     A,R1
   \   000032   A4           MUL     AB
   \   000033   2A           ADD     A,R2
   \   000034   F9           MOV     R1,A
   \   000035   74..         MOV     A,#(uip_udp_conns + 16) & 0xff
   \   000037   28           ADD     A,R0
   \   000038   F582         MOV     DPL,A
   \   00003A   74..         MOV     A,#((uip_udp_conns + 16) >> 8) & 0xff
   \   00003C   39           ADDC    A,R1
   \   00003D   F583         MOV     DPH,A
   \   00003F   7400         MOV     A,#0x0
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   7400         MOV     A,#0x0
   \   000045   F0           MOVX    @DPTR,A
    430            }
   \   000046   90....       MOV     DPTR,#`c`
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   2401         ADD     A,#0x1
   \   00004C   F0           MOVX    @DPTR,A
   \                     ??uip_init_0:
   \   00004D   90....       MOV     DPTR,#`c`
   \   000050   E0           MOVX    A,@DPTR
   \   000051   C3           CLR     C
   \   000052   940A         SUBB    A,#0xa
   \   000054   40C3         JC      ??uip_init_1
    431          #endif /* UIP_UDP */
    432          }
   \   000056   D083         POP     DPH
   \   000058   D082         POP     DPL
   \   00005A   02....       LJMP    ?BRET
    433          /*---------------------------------------------------------------------------*/
    434          #if UIP_TCP && UIP_ACTIVE_OPEN
    435          struct uip_conn *
    436          uip_connect(uip_ipaddr_t *ripaddr, uint16_t rport)
    437          {
    438            register struct uip_conn *conn, *cconn;
    439            
    440            /* Find an unused local port. */
    441           again:
    442            ++lastport;
    443          
    444            if(lastport >= 32000) {
    445              lastport = 4096;
    446            }
    447          
    448            /* Check if this port is already in use, and if so try to find
    449               another one. */
    450            for(c = 0; c < UIP_CONNS; ++c) {
    451              conn = &uip_conns[c];
    452              if(conn->tcpstateflags != UIP_CLOSED &&
    453                 conn->lport == uip_htons(lastport)) {
    454                goto again;
    455              }
    456            }
    457          
    458            conn = 0;
    459            for(c = 0; c < UIP_CONNS; ++c) {
    460              cconn = &uip_conns[c];
    461              if(cconn->tcpstateflags == UIP_CLOSED) {
    462                conn = cconn;
    463                break;
    464              }
    465              if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    466                if(conn == 0 ||
    467                   cconn->timer > conn->timer) {
    468                  conn = cconn;
    469                }
    470              }
    471            }
    472          
    473            if(conn == 0) {
    474              return 0;
    475            }
    476            
    477            conn->tcpstateflags = UIP_SYN_SENT;
    478          
    479            conn->snd_nxt[0] = iss[0];
    480            conn->snd_nxt[1] = iss[1];
    481            conn->snd_nxt[2] = iss[2];
    482            conn->snd_nxt[3] = iss[3];
    483          
    484            conn->rcv_nxt[0] = 0;
    485            conn->rcv_nxt[1] = 0;
    486            conn->rcv_nxt[2] = 0;
    487            conn->rcv_nxt[3] = 0;
    488          
    489            conn->initialmss = conn->mss = UIP_TCP_MSS;
    490            
    491            conn->len = 1;   /* TCP length of the SYN is one. */
    492            conn->nrtx = 0;
    493            conn->timer = 1; /* Send the SYN next time around. */
    494            conn->rto = UIP_RTO;
    495            conn->sa = 0;
    496            conn->sv = 16;   /* Initial value of the RTT variance. */
    497            conn->lport = uip_htons(lastport);
    498            conn->rport = rport;
    499            uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    500            
    501            return conn;
    502          }
    503          #endif /* UIP_TCP && UIP_ACTIVE_OPEN */
    504          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    505          void
    506          remove_ext_hdr(void)
   \                     remove_ext_hdr:
    507          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    508            /* Remove ext header before TCP/UDP processing. */
    509            if(uip_ext_len > 0) {
   \   000005   90....       MOV     DPTR,#uip_ext_len
   \   000008   E0           MOVX    A,@DPTR
   \   000009   C3           CLR     C
   \   00000A   9401         SUBB    A,#0x1
   \   00000C   5003         JNC     $+5
   \   00000E   02....       LJMP    ??remove_ext_hdr_0 & 0xFFFF
    510              PRINTF("Cutting ext-header before processing (extlen: %d, uiplen: %d)\n",
    511          	   uip_ext_len, uip_len);
    512              if(uip_len < UIP_IPH_LEN + uip_ext_len) {
   \   000011   90....       MOV     DPTR,#uip_len
   \   000014   C082         PUSH    DPL
   \   000016   C083         PUSH    DPH
   \   000018   90....       MOV     DPTR,#uip_ext_len
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F8           MOV     R0,A
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   2428         ADD     A,#0x28
   \   000021   F8           MOV     R0,A
   \   000022   E9           MOV     A,R1
   \   000023   3400         ADDC    A,#0x0
   \   000025   F9           MOV     R1,A
   \   000026   D083         POP     DPH
   \   000028   D082         POP     DPL
   \   00002A   C3           CLR     C
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   98           SUBB    A,R0
   \   00002D   A3           INC     DPTR
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   99           SUBB    A,R1
   \   000030   5012         JNC     ??remove_ext_hdr_1
    513                PRINTF("ERROR: uip_len too short compared to ext len\n");
    514                uip_ext_len = 0;
   \   000032   90....       MOV     DPTR,#uip_ext_len
   \   000035   7400         MOV     A,#0x0
   \   000037   F0           MOVX    @DPTR,A
    515                uip_len = 0;
   \   000038   90....       MOV     DPTR,#uip_len
   \   00003B   7400         MOV     A,#0x0
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   7400         MOV     A,#0x0
   \   000041   F0           MOVX    @DPTR,A
    516                return;
   \   000042   807E         SJMP    ??remove_ext_hdr_0
    517              }
    518              memmove(((uint8_t *)UIP_TCP_BUF), (uint8_t *)UIP_TCP_BUF + uip_ext_len,
    519          	    uip_len - UIP_IPH_LEN - uip_ext_len);
   \                     ??remove_ext_hdr_1:
   \   000044                ; Setup parameters for call to function memmove
   \   000044   90....       MOV     DPTR,#uip_len
   \   000047   E0           MOVX    A,@DPTR
   \   000048   24D8         ADD     A,#-0x28
   \   00004A   F8           MOV     R0,A
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   34FF         ADDC    A,#-0x1
   \   00004F   F9           MOV     R1,A
   \   000050   90....       MOV     DPTR,#uip_ext_len
   \   000053   E0           MOVX    A,@DPTR
   \   000054   FA           MOV     R2,A
   \   000055   7B00         MOV     R3,#0x0
   \   000057   E8           MOV     A,R0
   \   000058   C3           CLR     C
   \   000059   9A           SUBB    A,R2
   \   00005A   F5..         MOV     ?V0 + 0,A
   \   00005C   E9           MOV     A,R1
   \   00005D   9B           SUBB    A,R3
   \   00005E   F5..         MOV     ?V0 + 1,A
   \   000060   78..         MOV     R0,#?V0 + 0
   \   000062   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000065   90....       MOV     DPTR,#uip_ext_len
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F8           MOV     R0,A
   \   00006A   7900         MOV     R1,#0x0
   \   00006C   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00006E   28           ADD     A,R0
   \   00006F   F8           MOV     R0,A
   \   000070   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000072   39           ADDC    A,R1
   \   000073   F9           MOV     R1,A
   \   000074   E8           MOV     A,R0
   \   000075   2428         ADD     A,#0x28
   \   000077   FC           MOV     R4,A
   \   000078   E9           MOV     A,R1
   \   000079   3400         ADDC    A,#0x0
   \   00007B   FD           MOV     R5,A
   \   00007C   7A..         MOV     R2,#(uip_aligned_buf + 40) & 0xff
   \   00007E   7B..         MOV     R3,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000080   12....       LCALL   ??memmove?relay
   \   000083   7402         MOV     A,#0x2
   \   000085   12....       LCALL   ?DEALLOC_XSTACK8
    520          
    521              uip_len -= uip_ext_len;
   \   000088   90....       MOV     DPTR,#uip_ext_len
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   F8           MOV     R0,A
   \   00008D   7900         MOV     R1,#0x0
   \   00008F   90....       MOV     DPTR,#uip_len
   \   000092   C3           CLR     C
   \   000093   E0           MOVX    A,@DPTR
   \   000094   98           SUBB    A,R0
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   E0           MOVX    A,@DPTR
   \   000098   99           SUBB    A,R1
   \   000099   F0           MOVX    @DPTR,A
    522          
    523              /* Update the IP length. */
    524              UIP_IP_BUF->len[0] = (uip_len - UIP_IPH_LEN) >> 8;
   \   00009A   90....       MOV     DPTR,#uip_len
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   24D8         ADD     A,#-0x28
   \   0000A0   F8           MOV     R0,A
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   34FF         ADDC    A,#-0x1
   \   0000A5   F9           MOV     R1,A
   \   0000A6   E4           CLR     A
   \   0000A7   E9           MOV     A,R1
   \   0000A8   F8           MOV     R0,A
   \   0000A9   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   0000AC   F0           MOVX    @DPTR,A
    525              UIP_IP_BUF->len[1] = (uip_len - UIP_IPH_LEN) & 0xff;
   \   0000AD   90....       MOV     DPTR,#uip_len
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   F8           MOV     R0,A
   \   0000B2   A3           INC     DPTR
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   F9           MOV     R1,A
   \   0000B5   E8           MOV     A,R0
   \   0000B6   24D8         ADD     A,#-0x28
   \   0000B8   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   0000BB   F0           MOVX    @DPTR,A
    526              uip_ext_len = 0;
   \   0000BC   90....       MOV     DPTR,#uip_ext_len
   \   0000BF   7400         MOV     A,#0x0
   \   0000C1   F0           MOVX    @DPTR,A
    527            }
    528          }
   \                     ??remove_ext_hdr_0:
   \   0000C2   7F02         MOV     R7,#0x2
   \   0000C4   02....       LJMP    ?BANKED_LEAVE_XDATA
    529          /*---------------------------------------------------------------------------*/
    530          #if UIP_UDP

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    531          struct uip_udp_conn *
    532          uip_udp_new(const uip_ipaddr_t *ripaddr, uint16_t rport)
   \                     uip_udp_new:
    533          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   8048         SJMP    ??uip_udp_new_0
    534            register struct uip_udp_conn *conn;
    535            
    536            /* Find an unused local port. */
    537           again:
    538            ++lastport;
    539          
    540            if(lastport >= 32000) {
    541              lastport = 4096;
    542            }
    543            
    544            for(c = 0; c < UIP_UDP_CONNS; ++c) {
    545              if(uip_udp_conns[c].lport == uip_htons(lastport)) {
   \                     ??uip_udp_new_1:
   \   00000F   90....       MOV     DPTR,#`c`
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   7900         MOV     R1,#0x0
   \   000016   E8           MOV     A,R0
   \   000017   75F019       MOV     B,#0x19
   \   00001A   A4           MUL     AB
   \   00001B   C8           XCH     A,R0
   \   00001C   AAF0         MOV     R2,B
   \   00001E   75F000       MOV     B,#0x0
   \   000021   A4           MUL     AB
   \   000022   2A           ADD     A,R2
   \   000023   FA           MOV     R2,A
   \   000024   75F019       MOV     B,#0x19
   \   000027   E9           MOV     A,R1
   \   000028   A4           MUL     AB
   \   000029   2A           ADD     A,R2
   \   00002A   F9           MOV     R1,A
   \   00002B   74..         MOV     A,#(uip_udp_conns + 16) & 0xff
   \   00002D   28           ADD     A,R0
   \   00002E   F582         MOV     DPL,A
   \   000030   74..         MOV     A,#((uip_udp_conns + 16) >> 8) & 0xff
   \   000032   39           ADDC    A,R1
   \   000033   F583         MOV     DPH,A
   \   000035   C082         PUSH    DPL
   \   000037   C083         PUSH    DPH
   \   000039                ; Setup parameters for call to function uip_htons
   \   000039   90....       MOV     DPTR,#lastport
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FA           MOV     R2,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
   \   000041   12....       LCALL   ??uip_htons?relay
   \   000044   8A..         MOV     ?V0 + 4,R2
   \   000046   8B..         MOV     ?V0 + 5,R3
   \   000048   D083         POP     DPH
   \   00004A   D082         POP     DPL
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   65..         XRL     A,?V0 + 4
   \   00004F   7004         JNZ     ??uip_udp_new_2
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   65..         XRL     A,?V0 + 5
   \                     ??uip_udp_new_2:
   \   000055   702B         JNZ     ??uip_udp_new_3
    546                goto again;
    547              }
    548            }
   \                     ??uip_udp_new_0:
   \   000057   90....       MOV     DPTR,#lastport
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   2401         ADD     A,#0x1
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   3400         ADDC    A,#0x0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   90....       MOV     DPTR,#lastport
   \   000066   C3           CLR     C
   \   000067   E0           MOVX    A,@DPTR
   \   000068   9400         SUBB    A,#0x0
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   947D         SUBB    A,#0x7d
   \   00006E   400A         JC      ??uip_udp_new_4
   \   000070   90....       MOV     DPTR,#lastport
   \   000073   7400         MOV     A,#0x0
   \   000075   F0           MOVX    @DPTR,A
   \   000076   A3           INC     DPTR
   \   000077   7410         MOV     A,#0x10
   \   000079   F0           MOVX    @DPTR,A
   \                     ??uip_udp_new_4:
   \   00007A   90....       MOV     DPTR,#`c`
   \   00007D   7400         MOV     A,#0x0
   \   00007F   F0           MOVX    @DPTR,A
   \   000080   8007         SJMP    ??uip_udp_new_5
   \                     ??uip_udp_new_3:
   \   000082   90....       MOV     DPTR,#`c`
   \   000085   E0           MOVX    A,@DPTR
   \   000086   2401         ADD     A,#0x1
   \   000088   F0           MOVX    @DPTR,A
   \                     ??uip_udp_new_5:
   \   000089   90....       MOV     DPTR,#`c`
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   C3           CLR     C
   \   00008E   940A         SUBB    A,#0xa
   \   000090   5003         JNC     $+5
   \   000092   02....       LJMP    ??uip_udp_new_1 & 0xFFFF
    549          
    550            conn = 0;
   \   000095   7E00         MOV     R6,#0x0
   \   000097   7F00         MOV     R7,#0x0
    551            for(c = 0; c < UIP_UDP_CONNS; ++c) {
   \   000099   90....       MOV     DPTR,#`c`
   \   00009C   7400         MOV     A,#0x0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   8007         SJMP    ??uip_udp_new_6
   \                     ??uip_udp_new_7:
   \   0000A1   90....       MOV     DPTR,#`c`
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   2401         ADD     A,#0x1
   \   0000A7   F0           MOVX    @DPTR,A
   \                     ??uip_udp_new_6:
   \   0000A8   90....       MOV     DPTR,#`c`
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   C3           CLR     C
   \   0000AD   940A         SUBB    A,#0xa
   \   0000AF   5053         JNC     ??uip_udp_new_8
    552              if(uip_udp_conns[c].lport == 0) {
   \   0000B1   90....       MOV     DPTR,#`c`
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   F8           MOV     R0,A
   \   0000B6   7900         MOV     R1,#0x0
   \   0000B8   E8           MOV     A,R0
   \   0000B9   75F019       MOV     B,#0x19
   \   0000BC   A4           MUL     AB
   \   0000BD   C8           XCH     A,R0
   \   0000BE   AAF0         MOV     R2,B
   \   0000C0   75F000       MOV     B,#0x0
   \   0000C3   A4           MUL     AB
   \   0000C4   2A           ADD     A,R2
   \   0000C5   FA           MOV     R2,A
   \   0000C6   75F019       MOV     B,#0x19
   \   0000C9   E9           MOV     A,R1
   \   0000CA   A4           MUL     AB
   \   0000CB   2A           ADD     A,R2
   \   0000CC   F9           MOV     R1,A
   \   0000CD   74..         MOV     A,#(uip_udp_conns + 16) & 0xff
   \   0000CF   28           ADD     A,R0
   \   0000D0   F582         MOV     DPL,A
   \   0000D2   74..         MOV     A,#((uip_udp_conns + 16) >> 8) & 0xff
   \   0000D4   39           ADDC    A,R1
   \   0000D5   F583         MOV     DPH,A
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   F8           MOV     R0,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   F9           MOV     R1,A
   \   0000DC   E8           MOV     A,R0
   \   0000DD   49           ORL     A,R1
   \   0000DE   70C1         JNZ     ??uip_udp_new_7
    553                conn = &uip_udp_conns[c];
   \   0000E0   90....       MOV     DPTR,#`c`
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   F8           MOV     R0,A
   \   0000E5   7900         MOV     R1,#0x0
   \   0000E7   E8           MOV     A,R0
   \   0000E8   75F019       MOV     B,#0x19
   \   0000EB   A4           MUL     AB
   \   0000EC   C8           XCH     A,R0
   \   0000ED   AAF0         MOV     R2,B
   \   0000EF   75F000       MOV     B,#0x0
   \   0000F2   A4           MUL     AB
   \   0000F3   2A           ADD     A,R2
   \   0000F4   FA           MOV     R2,A
   \   0000F5   75F019       MOV     B,#0x19
   \   0000F8   E9           MOV     A,R1
   \   0000F9   A4           MUL     AB
   \   0000FA   2A           ADD     A,R2
   \   0000FB   F9           MOV     R1,A
   \   0000FC   74..         MOV     A,#uip_udp_conns & 0xff
   \   0000FE   28           ADD     A,R0
   \   0000FF   FE           MOV     R6,A
   \   000100   74..         MOV     A,#(uip_udp_conns >> 8) & 0xff
   \   000102   39           ADDC    A,R1
   \   000103   FF           MOV     R7,A
    554                break;
    555              }
    556            }
    557          
    558            if(conn == 0) {
   \                     ??uip_udp_new_8:
   \   000104   EE           MOV     A,R6
   \   000105   4F           ORL     A,R7
   \   000106   7007         JNZ     ??uip_udp_new_9
    559              return 0;
   \   000108   7A00         MOV     R2,#0x0
   \   00010A   7B00         MOV     R3,#0x0
   \   00010C   02....       LJMP    ??uip_udp_new_10 & 0xFFFF
    560            }
    561            
    562            conn->lport = UIP_HTONS(lastport);
   \                     ??uip_udp_new_9:
   \   00010F   90....       MOV     DPTR,#lastport
   \   000112   E0           MOVX    A,@DPTR
   \   000113   FA           MOV     R2,A
   \   000114   A3           INC     DPTR
   \   000115   E0           MOVX    A,@DPTR
   \   000116   FB           MOV     R3,A
   \   000117   E4           CLR     A
   \   000118   CA           XCH     A,R2
   \   000119   FB           MOV     R3,A
   \   00011A   90....       MOV     DPTR,#lastport
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F8           MOV     R0,A
   \   00011F   A3           INC     DPTR
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   E4           CLR     A
   \   000123   C9           XCH     A,R1
   \   000124   F8           MOV     R0,A
   \   000125   EA           MOV     A,R2
   \   000126   48           ORL     A,R0
   \   000127   F8           MOV     R0,A
   \   000128   EB           MOV     A,R3
   \   000129   49           ORL     A,R1
   \   00012A   F9           MOV     R1,A
   \   00012B   EE           MOV     A,R6
   \   00012C   2410         ADD     A,#0x10
   \   00012E   F582         MOV     DPL,A
   \   000130   EF           MOV     A,R7
   \   000131   3400         ADDC    A,#0x0
   \   000133   F583         MOV     DPH,A
   \   000135   E8           MOV     A,R0
   \   000136   F0           MOVX    @DPTR,A
   \   000137   A3           INC     DPTR
   \   000138   E9           MOV     A,R1
   \   000139   F0           MOVX    @DPTR,A
    563            conn->rport = rport;
   \   00013A   EE           MOV     A,R6
   \   00013B   2412         ADD     A,#0x12
   \   00013D   F582         MOV     DPL,A
   \   00013F   EF           MOV     A,R7
   \   000140   3400         ADDC    A,#0x0
   \   000142   F583         MOV     DPH,A
   \   000144   E5..         MOV     A,?V0 + 2
   \   000146   F0           MOVX    @DPTR,A
   \   000147   A3           INC     DPTR
   \   000148   E5..         MOV     A,?V0 + 3
   \   00014A   F0           MOVX    @DPTR,A
    564            if(ripaddr == NULL) {
   \   00014B   E5..         MOV     A,?V0 + 0
   \   00014D   45..         ORL     A,?V0 + 1
   \   00014F   701D         JNZ     ??uip_udp_new_11
    565              memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
   \   000151                ; Setup parameters for call to function memset
   \   000151   75..10       MOV     ?V0 + 0,#0x10
   \   000154   75..00       MOV     ?V0 + 1,#0x0
   \   000157   78..         MOV     R0,#?V0 + 0
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015C   7C00         MOV     R4,#0x0
   \   00015E   7D00         MOV     R5,#0x0
   \   000160   EE           MOV     A,R6
   \   000161   FA           MOV     R2,A
   \   000162   EF           MOV     A,R7
   \   000163   FB           MOV     R3,A
   \   000164   12....       LCALL   ??memset?relay
   \   000167   7402         MOV     A,#0x2
   \   000169   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016C   801B         SJMP    ??uip_udp_new_12
    566            } else {
    567              uip_ipaddr_copy(&conn->ripaddr, ripaddr);
   \                     ??uip_udp_new_11:
   \   00016E                ; Setup parameters for call to function memcpy
   \   00016E   75..10       MOV     ?V0 + 2,#0x10
   \   000171   75..00       MOV     ?V0 + 3,#0x0
   \   000174   78..         MOV     R0,#?V0 + 2
   \   000176   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000179   AC..         MOV     R4,?V0 + 0
   \   00017B   AD..         MOV     R5,?V0 + 1
   \   00017D   EE           MOV     A,R6
   \   00017E   FA           MOV     R2,A
   \   00017F   EF           MOV     A,R7
   \   000180   FB           MOV     R3,A
   \   000181   12....       LCALL   ??memcpy?relay
   \   000184   7402         MOV     A,#0x2
   \   000186   12....       LCALL   ?DEALLOC_XSTACK8
    568            }
    569            conn->ttl = uip_ds6_if.cur_hop_limit;
   \                     ??uip_udp_new_12:
   \   000189   90....       MOV     DPTR,#uip_ds6_if + 4
   \   00018C   E0           MOVX    A,@DPTR
   \   00018D   C0E0         PUSH    A
   \   00018F   EE           MOV     A,R6
   \   000190   2414         ADD     A,#0x14
   \   000192   F582         MOV     DPL,A
   \   000194   EF           MOV     A,R7
   \   000195   3400         ADDC    A,#0x0
   \   000197   F583         MOV     DPH,A
   \   000199   D0E0         POP     A
   \   00019B   F0           MOVX    @DPTR,A
    570            
    571            return conn;
   \   00019C   EE           MOV     A,R6
   \   00019D   FA           MOV     R2,A
   \   00019E   EF           MOV     A,R7
   \   00019F   FB           MOV     R3,A
   \                     ??uip_udp_new_10:
   \   0001A0   7F06         MOV     R7,#0x6
   \   0001A2   02....       LJMP    ?BANKED_LEAVE_XDATA
    572          }
    573          #endif /* UIP_UDP */
    574          /*---------------------------------------------------------------------------*/
    575          #if UIP_TCP
    576          void
    577          uip_unlisten(uint16_t port)
    578          {
    579            for(c = 0; c < UIP_LISTENPORTS; ++c) {
    580              if(uip_listenports[c] == port) {
    581                uip_listenports[c] = 0;
    582                return;
    583              }
    584            }
    585          }
    586          /*---------------------------------------------------------------------------*/
    587          void
    588          uip_listen(uint16_t port)
    589          {
    590            for(c = 0; c < UIP_LISTENPORTS; ++c) {
    591              if(uip_listenports[c] == 0) {
    592                uip_listenports[c] = port;
    593                return;
    594              }
    595            }
    596          }
    597          #endif
    598          /*---------------------------------------------------------------------------*/
    599          
    600          #if UIP_CONF_IPV6_REASSEMBLY
    601          #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
    602          
    603          static uint8_t uip_reassbuf[UIP_REASS_BUFSIZE];
    604          
    605          static uint8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
    606          /*the first byte of an IP fragment is aligned on an 8-byte boundary */
    607          
    608          static const uint8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
    609                                              0x0f, 0x07, 0x03, 0x01};
    610          static uint16_t uip_reasslen;
    611          static uint8_t uip_reassflags;
    612          
    613          #define UIP_REASS_FLAG_LASTFRAG 0x01
    614          #define UIP_REASS_FLAG_FIRSTFRAG 0x02
    615          #define UIP_REASS_FLAG_ERROR_MSG 0x04
    616          
    617          
    618          /*
    619           * See RFC 2460 for a description of fragmentation in IPv6
    620           * A typical Ipv6 fragment
    621           *  +------------------+--------+--------------+
    622           *  |  Unfragmentable  |Fragment|    first     |
    623           *  |       Part       | Header |   fragment   |
    624           *  +------------------+--------+--------------+
    625           */
    626          
    627          
    628          struct etimer uip_reass_timer; /* timer for reassembly */
    629          uint8_t uip_reass_on; /* equal to 1 if we are currently reassembling a packet */
    630          
    631          static uint32_t uip_id; /* For every packet that is to be fragmented, the source
    632                                  node generates an Identification value that is present
    633                                  in all the fragments */
    634          #define IP_MF   0x0001
    635          
    636          static uint16_t
    637          uip_reass(void)
    638          {
    639            uint16_t offset=0;
    640            uint16_t len;
    641            uint16_t i;
    642            
    643            /* If ip_reasstmr is zero, no packet is present in the buffer */
    644            /* We first write the unfragmentable part of IP header into the reassembly
    645               buffer. The reset the other reassembly variables. */
    646            if(uip_reass_on == 0) {
    647              PRINTF("Starting reassembly\n");
    648              memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
    649              /* temporary in case we do not receive the fragment with offset 0 first */
    650              etimer_set(&uip_reass_timer, UIP_REASS_MAXAGE*CLOCK_SECOND);
    651              uip_reass_on = 1;
    652              uip_reassflags = 0;
    653              uip_id = UIP_FRAG_BUF->id;
    654              /* Clear the bitmap. */
    655              memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
    656            }
    657            /*
    658             * Check if the incoming fragment matches the one currently present
    659             * in the reasembly buffer. If so, we proceed with copying the fragment
    660             * into the buffer.
    661             */
    662            if(uip_ipaddr_cmp(&FBUF->srcipaddr, &UIP_IP_BUF->srcipaddr) &&
    663               uip_ipaddr_cmp(&FBUF->destipaddr, &UIP_IP_BUF->destipaddr) &&
    664               UIP_FRAG_BUF->id == uip_id) {
    665              len = uip_len - uip_ext_len - UIP_IPH_LEN - UIP_FRAGH_LEN;
    666              offset = (uip_ntohs(UIP_FRAG_BUF->offsetresmore) & 0xfff8);
    667              /* in byte, originaly in multiple of 8 bytes*/
    668              PRINTF("len %d\n", len);
    669              PRINTF("offset %d\n", offset);
    670              if(offset == 0){
    671                uip_reassflags |= UIP_REASS_FLAG_FIRSTFRAG;
    672                /*
    673                 * The Next Header field of the last header of the Unfragmentable
    674                 * Part is obtained from the Next Header field of the first
    675                 * fragment's Fragment header.
    676                 */
    677                *uip_next_hdr = UIP_FRAG_BUF->next;
    678                memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
    679                PRINTF("src ");
    680                PRINT6ADDR(&FBUF->srcipaddr);
    681                PRINTF("dest ");
    682                PRINT6ADDR(&FBUF->destipaddr);
    683                PRINTF("next %d\n", UIP_IP_BUF->proto);
    684                
    685              }
    686              
    687              /* If the offset or the offset + fragment length overflows the
    688                 reassembly buffer, we discard the entire packet. */
    689              if(offset > UIP_REASS_BUFSIZE ||
    690                 offset + len > UIP_REASS_BUFSIZE) {
    691                uip_reass_on = 0;
    692                etimer_stop(&uip_reass_timer);
    693                return 0;
    694              }
    695          
    696              /* If this fragment has the More Fragments flag set to zero, it is the
    697                 last fragment*/
    698              if((uip_ntohs(UIP_FRAG_BUF->offsetresmore) & IP_MF) == 0) {
    699                uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
    700                /*calculate the size of the entire packet*/
    701                uip_reasslen = offset + len;
    702                PRINTF("LAST FRAGMENT reasslen %d\n", uip_reasslen);
    703              } else {
    704                /* If len is not a multiple of 8 octets and the M flag of that fragment
    705                   is 1, then that fragment must be discarded and an ICMP Parameter
    706                   Problem, Code 0, message should be sent to the source of the fragment,
    707                   pointing to the Payload Length field of the fragment packet. */
    708                if(len % 8 != 0){
    709                  uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, 4);
    710                  uip_reassflags |= UIP_REASS_FLAG_ERROR_MSG;
    711                  /* not clear if we should interrupt reassembly, but it seems so from
    712                     the conformance tests */
    713                  uip_reass_on = 0;
    714                  etimer_stop(&uip_reass_timer);
    715                  return uip_len;
    716                }
    717              }
    718              
    719              /* Copy the fragment into the reassembly buffer, at the right
    720                 offset. */
    721              memcpy((uint8_t *)FBUF + UIP_IPH_LEN + uip_ext_len + offset,
    722                     (uint8_t *)UIP_FRAG_BUF + UIP_FRAGH_LEN, len);
    723              
    724              /* Update the bitmap. */
    725              if(offset >> 6 == (offset + len) >> 6) {
    726                uip_reassbitmap[offset >> 6] |=
    727                  bitmap_bits[(offset >> 3) & 7] &
    728                  ~bitmap_bits[((offset + len) >> 3)  & 7];
    729              } else {
    730                /* If the two endpoints are in different bytes, we update the
    731                   bytes in the endpoints and fill the stuff inbetween with
    732                   0xff. */
    733                uip_reassbitmap[offset >> 6] |= bitmap_bits[(offset >> 3) & 7];
    734           
    735                for(i = (1 + (offset >> 6)); i < ((offset + len) >> 6); ++i) {
    736                  uip_reassbitmap[i] = 0xff;
    737                }
    738                uip_reassbitmap[(offset + len) >> 6] |=
    739                  ~bitmap_bits[((offset + len) >> 3) & 7];
    740              }
    741            
    742              /* Finally, we check if we have a full packet in the buffer. We do
    743                 this by checking if we have the last fragment and if all bits
    744                 in the bitmap are set. */
    745              
    746              if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
    747                /* Check all bytes up to and including all but the last byte in
    748                   the bitmap. */
    749                for(i = 0; i < (uip_reasslen >> 6); ++i) {
    750                  if(uip_reassbitmap[i] != 0xff) {
    751                    return 0;
    752                  }
    753                }
    754                /* Check the last byte in the bitmap. It should contain just the
    755                   right amount of bits. */
    756                if(uip_reassbitmap[uip_reasslen >> 6] !=
    757                   (uint8_t)~bitmap_bits[(uip_reasslen >> 3) & 7]) {
    758                  return 0;
    759                }
    760          
    761               /* If we have come this far, we have a full packet in the
    762                   buffer, so we copy it to uip_buf. We also reset the timer. */
    763                uip_reass_on = 0;
    764                etimer_stop(&uip_reass_timer);
    765          
    766                uip_reasslen += UIP_IPH_LEN + uip_ext_len;
    767                memcpy(UIP_IP_BUF, FBUF, uip_reasslen);
    768                UIP_IP_BUF->len[0] = ((uip_reasslen - UIP_IPH_LEN) >> 8);
    769                UIP_IP_BUF->len[1] = ((uip_reasslen - UIP_IPH_LEN) & 0xff);
    770                PRINTF("REASSEMBLED PAQUET %d (%d)\n", uip_reasslen,
    771                       (UIP_IP_BUF->len[0] << 8) | UIP_IP_BUF->len[1]);
    772             
    773                return uip_reasslen;
    774                
    775              }
    776            } else {
    777              PRINTF("Already reassembling another paquet\n");
    778            }
    779            return 0;
    780          }
    781          
    782          void
    783          uip_reass_over(void)
    784          {
    785             /* to late, we abandon the reassembly of the packet */
    786          
    787            uip_reass_on = 0;
    788            etimer_stop(&uip_reass_timer);
    789          
    790            if(uip_reassflags & UIP_REASS_FLAG_FIRSTFRAG){
    791              PRINTF("FRAG INTERRUPTED TOO LATE\n");
    792              /* If the first fragment has been received, an ICMP Time Exceeded
    793                 -- Fragment Reassembly Time Exceeded message should be sent to the
    794                 source of that fragment. */
    795              /** \note
    796               * We don't have a complete packet to put in the error message.
    797               * We could include the first fragment but since its not mandated by
    798               * any RFC, we decided not to include it as it reduces the size of
    799               * the packet.
    800               */
    801              uip_len = 0;
    802              uip_ext_len = 0;
    803              memcpy(UIP_IP_BUF, FBUF, UIP_IPH_LEN); /* copy the header for src
    804                                                        and dest address*/
    805              uip_icmp6_error_output(ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_REASSEMBLY, 0);
    806              
    807              UIP_STAT(++uip_stat.ip.sent);
    808              uip_flags = 0;
    809            }
    810          }
    811          
    812          #endif /* UIP_CONF_IPV6_REASSEMBLY */
    813          
    814          /*---------------------------------------------------------------------------*/
    815          #if UIP_TCP
    816          static void
    817          uip_add_rcv_nxt(uint16_t n)
    818          {
    819            uip_add32(uip_conn->rcv_nxt, n);
    820            uip_conn->rcv_nxt[0] = uip_acc32[0];
    821            uip_conn->rcv_nxt[1] = uip_acc32[1];
    822            uip_conn->rcv_nxt[2] = uip_acc32[2];
    823            uip_conn->rcv_nxt[3] = uip_acc32[3];
    824          }
    825          #endif
    826          /*---------------------------------------------------------------------------*/
    827          
    828          /**
    829           * \brief Process the options in Destination and Hop By Hop extension headers
    830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    831          static uint8_t
    832          ext_hdr_options_process(void)
   \                     ext_hdr_options_process:
    833          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    834           /*
    835            * Length field in the extension header: length of the header in units of
    836            * 8 bytes, excluding the first 8 bytes
    837            * length field in an option : the length of data in the option
    838            */
    839            uip_ext_opt_offset = 2;
   \   000005   90....       MOV     DPTR,#uip_ext_opt_offset
   \   000008   7402         MOV     A,#0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   8007         SJMP    ??ext_hdr_options_process_0
    840            while(uip_ext_opt_offset < ((UIP_EXT_BUF->len << 3) + 8)) {
    841              switch(UIP_EXT_HDR_OPT_BUF->type) {
    842                /*
    843                 * for now we do not support any options except padding ones
    844                 * PAD1 does not make sense as the header must be 8bytes aligned,
    845                 * hence we can only have
    846                 */
    847                case UIP_EXT_HDR_OPT_PAD1:
    848                  PRINTF("Processing PAD1 option\n");
    849                  uip_ext_opt_offset += 1;
   \                     ??ext_hdr_options_process_1:
   \   00000D   90....       MOV     DPTR,#uip_ext_opt_offset
   \   000010   E0           MOVX    A,@DPTR
   \   000011   2401         ADD     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
    850                  break;
   \                     ??ext_hdr_options_process_0:
   \   000014   90....       MOV     DPTR,#uip_ext_opt_offset
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FA           MOV     R2,A
   \   000019   7B00         MOV     R3,#0x0
   \   00001B   90....       MOV     DPTR,#uip_ext_len
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   F8           MOV     R0,A
   \   000020   7900         MOV     R1,#0x0
   \   000022   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000024   28           ADD     A,R0
   \   000025   F8           MOV     R0,A
   \   000026   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000028   39           ADDC    A,R1
   \   000029   F9           MOV     R1,A
   \   00002A   E8           MOV     A,R0
   \   00002B   2429         ADD     A,#0x29
   \   00002D   F582         MOV     DPL,A
   \   00002F   E9           MOV     A,R1
   \   000030   3400         ADDC    A,#0x0
   \   000032   F583         MOV     DPH,A
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F5..         MOV     ?V0 + 0,A
   \   000037   75..00       MOV     ?V0 + 1,#0x0
   \   00003A   7403         MOV     A,#0x3
   \   00003C   78..         MOV     R0,#?V0 + 0
   \   00003E   12....       LCALL   ?S_SHL
   \   000041   E5..         MOV     A,?V0 + 0
   \   000043   2408         ADD     A,#0x8
   \   000045   F8           MOV     R0,A
   \   000046   E5..         MOV     A,?V0 + 1
   \   000048   3400         ADDC    A,#0x0
   \   00004A   F9           MOV     R1,A
   \   00004B   C3           CLR     C
   \   00004C   EA           MOV     A,R2
   \   00004D   98           SUBB    A,R0
   \   00004E   EB           MOV     A,R3
   \   00004F   99           SUBB    A,R1
   \   000050   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000052   65D0         XRL     A,PSW
   \   000054   33           RLC     A
   \   000055   4003         JC      $+5
   \   000057   02....       LJMP    ??ext_hdr_options_process_2 & 0xFFFF
   \   00005A   90....       MOV     DPTR,#uip_ext_len
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F8           MOV     R0,A
   \   00005F   7900         MOV     R1,#0x0
   \   000061   90....       MOV     DPTR,#uip_ext_opt_offset
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FA           MOV     R2,A
   \   000066   7B00         MOV     R3,#0x0
   \   000068   E8           MOV     A,R0
   \   000069   2A           ADD     A,R2
   \   00006A   F8           MOV     R0,A
   \   00006B   E9           MOV     A,R1
   \   00006C   3B           ADDC    A,R3
   \   00006D   F9           MOV     R1,A
   \   00006E   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   000070   28           ADD     A,R0
   \   000071   F582         MOV     DPL,A
   \   000073   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000075   39           ADDC    A,R1
   \   000076   F583         MOV     DPH,A
   \   000078   E0           MOVX    A,@DPTR
   \   000079   6092         JZ      ??ext_hdr_options_process_1
   \   00007B   14           DEC     A
   \   00007C   6006         JZ      ??ext_hdr_options_process_3
   \   00007E   249E         ADD     A,#-0x62
   \   000080   6035         JZ      ??ext_hdr_options_process_4
   \   000082   8068         SJMP    ??ext_hdr_options_process_5
    851                case UIP_EXT_HDR_OPT_PADN:
    852                  PRINTF("Processing PADN option\n");
    853                  uip_ext_opt_offset += UIP_EXT_HDR_OPT_PADN_BUF->opt_len + 2;
   \                     ??ext_hdr_options_process_3:
   \   000084   90....       MOV     DPTR,#uip_ext_len
   \   000087   E0           MOVX    A,@DPTR
   \   000088   F8           MOV     R0,A
   \   000089   7900         MOV     R1,#0x0
   \   00008B   90....       MOV     DPTR,#uip_ext_opt_offset
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   FA           MOV     R2,A
   \   000090   7B00         MOV     R3,#0x0
   \   000092   E8           MOV     A,R0
   \   000093   2A           ADD     A,R2
   \   000094   F8           MOV     R0,A
   \   000095   E9           MOV     A,R1
   \   000096   3B           ADDC    A,R3
   \   000097   F9           MOV     R1,A
   \   000098   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00009A   28           ADD     A,R0
   \   00009B   F8           MOV     R0,A
   \   00009C   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00009E   39           ADDC    A,R1
   \   00009F   F9           MOV     R1,A
   \   0000A0   E8           MOV     A,R0
   \   0000A1   2429         ADD     A,#0x29
   \   0000A3   F582         MOV     DPL,A
   \   0000A5   E9           MOV     A,R1
   \   0000A6   3400         ADDC    A,#0x0
   \   0000A8   F583         MOV     DPH,A
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   2402         ADD     A,#0x2
   \   0000AD   F8           MOV     R0,A
   \   0000AE   90....       MOV     DPTR,#uip_ext_opt_offset
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   28           ADD     A,R0
   \   0000B3   F0           MOVX    @DPTR,A
    854                  break;
   \   0000B4   02....       LJMP    ??ext_hdr_options_process_0 & 0xFFFF
    855                case UIP_EXT_HDR_OPT_RPL:
    856          		/* Fixes situation when a node that is not using RPL
    857          		 * joins a network which does. The received packages will include the
    858          		 * RPL header and processed by the "default" case of the switch
    859          		 * (0x63 & 0xC0 = 0x40). Hence, the packet is discarded as the header
    860          		 * is considered invalid.
    861          		 * Using this fix, the header is ignored, and the next header (if
    862          		 * present) is processed.
    863          		 */
    864          #if UIP_CONF_IPV6_RPL
    865                  PRINTF("Processing RPL option\n");
    866                  if(rpl_verify_header(uip_ext_opt_offset)) {
    867                    PRINTF("RPL Option Error: Dropping Packet\n");
    868                    return 1;
    869                  }
    870          #endif /* UIP_CONF_IPV6_RPL */
    871                  uip_ext_opt_offset += (UIP_EXT_HDR_OPT_BUF->len) + 2;
   \                     ??ext_hdr_options_process_4:
   \   0000B7   90....       MOV     DPTR,#uip_ext_len
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   F8           MOV     R0,A
   \   0000BC   7900         MOV     R1,#0x0
   \   0000BE   90....       MOV     DPTR,#uip_ext_opt_offset
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   FA           MOV     R2,A
   \   0000C3   7B00         MOV     R3,#0x0
   \   0000C5   E8           MOV     A,R0
   \   0000C6   2A           ADD     A,R2
   \   0000C7   F8           MOV     R0,A
   \   0000C8   E9           MOV     A,R1
   \   0000C9   3B           ADDC    A,R3
   \   0000CA   F9           MOV     R1,A
   \   0000CB   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0000CD   28           ADD     A,R0
   \   0000CE   F8           MOV     R0,A
   \   0000CF   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0000D1   39           ADDC    A,R1
   \   0000D2   F9           MOV     R1,A
   \   0000D3   E8           MOV     A,R0
   \   0000D4   2429         ADD     A,#0x29
   \   0000D6   F582         MOV     DPL,A
   \   0000D8   E9           MOV     A,R1
   \   0000D9   3400         ADDC    A,#0x0
   \   0000DB   F583         MOV     DPH,A
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   2402         ADD     A,#0x2
   \   0000E0   F8           MOV     R0,A
   \   0000E1   90....       MOV     DPTR,#uip_ext_opt_offset
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   28           ADD     A,R0
   \   0000E6   F0           MOVX    @DPTR,A
    872                  return 0;
   \   0000E7   7900         MOV     R1,#0x0
   \   0000E9   02....       LJMP    ??ext_hdr_options_process_6 & 0xFFFF
    873                default:
    874                  /*
    875                   * check the two highest order bits of the option
    876                   * - 00 skip over this option and continue processing the header.
    877                   * - 01 discard the packet.
    878                   * - 10 discard the packet and, regardless of whether or not the
    879                   *   packet's Destination Address was a multicast address, send an
    880                   *   ICMP Parameter Problem, Code 2, message to the packet's
    881                   *   Source Address, pointing to the unrecognized Option Type.
    882                   * - 11 discard the packet and, only if the packet's Destination
    883                   *   Address was not a multicast address, send an ICMP Parameter
    884                   *   Problem, Code 2, message to the packet's Source Address,
    885                   *   pointing to the unrecognized Option Type.
    886                   */
    887                  PRINTF("MSB %x\n", UIP_EXT_HDR_OPT_BUF->type);
    888                  switch(UIP_EXT_HDR_OPT_BUF->type & 0xC0) {
   \                     ??ext_hdr_options_process_5:
   \   0000EC   90....       MOV     DPTR,#uip_ext_len
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   F8           MOV     R0,A
   \   0000F1   7900         MOV     R1,#0x0
   \   0000F3   90....       MOV     DPTR,#uip_ext_opt_offset
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   FA           MOV     R2,A
   \   0000F8   7B00         MOV     R3,#0x0
   \   0000FA   E8           MOV     A,R0
   \   0000FB   2A           ADD     A,R2
   \   0000FC   F8           MOV     R0,A
   \   0000FD   E9           MOV     A,R1
   \   0000FE   3B           ADDC    A,R3
   \   0000FF   F9           MOV     R1,A
   \   000100   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   000102   28           ADD     A,R0
   \   000103   F582         MOV     DPL,A
   \   000105   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000107   39           ADDC    A,R1
   \   000108   F583         MOV     DPH,A
   \   00010A   E0           MOVX    A,@DPTR
   \   00010B   F8           MOV     R0,A
   \   00010C   7900         MOV     R1,#0x0
   \   00010E   54C0         ANL     A,#0xc0
   \   000110   F8           MOV     R0,A
   \   000111   E9           MOV     A,R1
   \   000112   5400         ANL     A,#0x0
   \   000114   F9           MOV     R1,A
   \   000115   E8           MOV     A,R0
   \   000116   600C         JZ      ??ext_hdr_options_process_7
   \   000118   24C0         ADD     A,#-0x40
   \   00011A   603B         JZ      ??ext_hdr_options_process_8
   \   00011C   24C0         ADD     A,#-0x40
   \   00011E   6047         JZ      ??ext_hdr_options_process_9
   \   000120   24C0         ADD     A,#-0x40
   \   000122   6037         JZ      ??ext_hdr_options_process_10
    889                    case 0:
    890                      break;
    891                    case 0x40:
    892                      return 1;
    893                    case 0xC0:
    894                      if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    895                        return 1;
    896                      }
    897                    case 0x80:
    898                      uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION,
    899                                       (uint32_t)UIP_IPH_LEN + uip_ext_len + uip_ext_opt_offset);
    900                      return 2;
    901                  }
    902                  /* in the cases were we did not discard, update ext_opt* */
    903                  uip_ext_opt_offset += UIP_EXT_HDR_OPT_BUF->len + 2;
   \                     ??ext_hdr_options_process_7:
   \   000124   90....       MOV     DPTR,#uip_ext_len
   \   000127   E0           MOVX    A,@DPTR
   \   000128   F8           MOV     R0,A
   \   000129   7900         MOV     R1,#0x0
   \   00012B   90....       MOV     DPTR,#uip_ext_opt_offset
   \   00012E   E0           MOVX    A,@DPTR
   \   00012F   FA           MOV     R2,A
   \   000130   7B00         MOV     R3,#0x0
   \   000132   E8           MOV     A,R0
   \   000133   2A           ADD     A,R2
   \   000134   F8           MOV     R0,A
   \   000135   E9           MOV     A,R1
   \   000136   3B           ADDC    A,R3
   \   000137   F9           MOV     R1,A
   \   000138   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00013A   28           ADD     A,R0
   \   00013B   F8           MOV     R0,A
   \   00013C   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00013E   39           ADDC    A,R1
   \   00013F   F9           MOV     R1,A
   \   000140   E8           MOV     A,R0
   \   000141   2429         ADD     A,#0x29
   \   000143   F582         MOV     DPL,A
   \   000145   E9           MOV     A,R1
   \   000146   3400         ADDC    A,#0x0
   \   000148   F583         MOV     DPH,A
   \   00014A   E0           MOVX    A,@DPTR
   \   00014B   2402         ADD     A,#0x2
   \   00014D   F8           MOV     R0,A
   \   00014E   90....       MOV     DPTR,#uip_ext_opt_offset
   \   000151   E0           MOVX    A,@DPTR
   \   000152   28           ADD     A,R0
   \   000153   F0           MOVX    @DPTR,A
    904                  break;
   \   000154   02....       LJMP    ??ext_hdr_options_process_0 & 0xFFFF
   \                     ??ext_hdr_options_process_8:
   \   000157   7901         MOV     R1,#0x1
   \   000159   804C         SJMP    ??ext_hdr_options_process_6
   \                     ??ext_hdr_options_process_10:
   \   00015B   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   64FF         XRL     A,#0xff
   \   000161   7004         JNZ     ??ext_hdr_options_process_9
   \   000163   7901         MOV     R1,#0x1
   \   000165   8040         SJMP    ??ext_hdr_options_process_6
   \                     ??ext_hdr_options_process_9:
   \   000167                ; Setup parameters for call to function uip_icmp6_error_output
   \   000167   90....       MOV     DPTR,#uip_ext_len
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   F5..         MOV     ?V0 + 0,A
   \   00016D   E4           CLR     A
   \   00016E   F5..         MOV     ?V0 + 1,A
   \   000170   F5..         MOV     ?V0 + 2,A
   \   000172   F5..         MOV     ?V0 + 3,A
   \   000174   90....       MOV     DPTR,#uip_ext_opt_offset
   \   000177   E0           MOVX    A,@DPTR
   \   000178   F5..         MOV     ?V0 + 4,A
   \   00017A   E4           CLR     A
   \   00017B   F5..         MOV     ?V0 + 5,A
   \   00017D   F5..         MOV     ?V0 + 6,A
   \   00017F   F5..         MOV     ?V0 + 7,A
   \   000181   78..         MOV     R0,#?V0 + 0
   \   000183   79..         MOV     R1,#?V0 + 4
   \   000185   12....       LCALL   ?L_ADD
   \   000188   90....       MOV     DPTR,#__Constant_28
   \   00018B   78..         MOV     R0,#?V0 + 0
   \   00018D   12....       LCALL   ?L_ADD_X
   \   000190   78..         MOV     R0,#?V0 + 0
   \   000192   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000195   7A02         MOV     R2,#0x2
   \   000197   7904         MOV     R1,#0x4
   \   000199   12....       LCALL   ??uip_icmp6_error_output?relay
   \   00019C   7404         MOV     A,#0x4
   \   00019E   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001A1   7902         MOV     R1,#0x2
   \   0001A3   8002         SJMP    ??ext_hdr_options_process_6
    905              }
    906            }
    907            return 0;
   \                     ??ext_hdr_options_process_2:
   \   0001A5   7900         MOV     R1,#0x0
   \                     ??ext_hdr_options_process_6:
   \   0001A7   7F08         MOV     R7,#0x8
   \   0001A9   02....       LJMP    ?BANKED_LEAVE_XDATA
    908          }
    909          
    910          
    911          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    912          void
    913          uip_process(uint8_t flag)
   \                     uip_process:
    914          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    915          #if UIP_TCP
    916            register struct uip_conn *uip_connr = uip_conn;
    917          #endif /* UIP_TCP */
    918          #if UIP_UDP
    919            if(flag == UIP_UDP_SEND_CONN) {
   \   000007   7404         MOV     A,#0x4
   \   000009   6E           XRL     A,R6
   \   00000A   7011         JNZ     ??uip_process_0
    920              goto udp_send;
    921            }
    922          #endif /* UIP_UDP */
    923            uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    924             
    925            /* Check if we were invoked because of a poll request for a
    926               particular connection. */
    927            if(flag == UIP_POLL_REQUEST) {
    928          #if UIP_TCP
    929              if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    930                 !uip_outstanding(uip_connr)) {
    931                uip_flags = UIP_POLL;
    932                UIP_APPCALL();
    933                goto appsend;
    934          #if UIP_ACTIVE_OPEN
    935              } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) {
    936                /* In the SYN_SENT state, we retransmit out SYN. */
    937                UIP_TCP_BUF->flags = 0;
    938                goto tcp_send_syn;
    939          #endif /* UIP_ACTIVE_OPEN */
    940              }
    941              goto drop;
    942          #endif /* UIP_TCP */
    943              /* Check if we were invoked because of the perodic timer fireing. */
    944            } else if(flag == UIP_TIMER) {
    945              /* Reset the length variables. */
    946          #if UIP_TCP
    947              uip_len = 0;
    948              uip_slen = 0;
    949              
    950              /* Increase the initial sequence number. */
    951              if(++iss[3] == 0) {
    952                if(++iss[2] == 0) {
    953                  if(++iss[1] == 0) {
    954                    ++iss[0];
    955                  }
    956                }
    957              }
    958              
    959              /*
    960               * Check if the connection is in a state in which we simply wait
    961               * for the connection to time out. If so, we increase the
    962               * connection's timer and remove the connection if it times
    963               * out.
    964               */
    965              if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    966                 uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
    967                ++(uip_connr->timer);
    968                if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    969                  uip_connr->tcpstateflags = UIP_CLOSED;
    970                }
    971              } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    972                /*
    973                 * If the connection has outstanding data, we increase the
    974                 * connection's timer and see if it has reached the RTO value
    975                 * in which case we retransmit.
    976                 */
    977                if(uip_outstanding(uip_connr)) {
    978                  if(uip_connr->timer-- == 0) {
    979                    if(uip_connr->nrtx == UIP_MAXRTX ||
    980                       ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    981                         uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    982                        uip_connr->nrtx == UIP_MAXSYNRTX)) {
    983                      uip_connr->tcpstateflags = UIP_CLOSED;
    984                            
    985                      /*
    986                       * We call UIP_APPCALL() with uip_flags set to
    987                       * UIP_TIMEDOUT to inform the application that the
    988                       * connection has timed out.
    989                       */
    990                      uip_flags = UIP_TIMEDOUT;
    991                      UIP_APPCALL();
    992                            
    993                      /* We also send a reset packet to the remote host. */
    994                      UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
    995                      goto tcp_send_nodata;
    996                    }
    997                         
    998                    /* Exponential backoff. */
    999                    uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
   1000                                                   4:
   1001                                                   uip_connr->nrtx);
   1002                    ++(uip_connr->nrtx);
   1003                         
   1004                    /*
   1005                     * Ok, so we need to retransmit. We do this differently
   1006                     * depending on which state we are in. In ESTABLISHED, we
   1007                     * call upon the application so that it may prepare the
   1008                     * data for the retransmit. In SYN_RCVD, we resend the
   1009                     * SYNACK that we sent earlier and in LAST_ACK we have to
   1010                     * retransmit our FINACK.
   1011                     */
   1012                    UIP_STAT(++uip_stat.tcp.rexmit);
   1013                    switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
   1014                      case UIP_SYN_RCVD:
   1015                        /* In the SYN_RCVD state, we should retransmit our SYNACK. */
   1016                        goto tcp_send_synack;
   1017                               
   1018          #if UIP_ACTIVE_OPEN
   1019                      case UIP_SYN_SENT:
   1020                        /* In the SYN_SENT state, we retransmit out SYN. */
   1021                        UIP_TCP_BUF->flags = 0;
   1022                        goto tcp_send_syn;
   1023          #endif /* UIP_ACTIVE_OPEN */
   1024                               
   1025                      case UIP_ESTABLISHED:
   1026                        /*
   1027                         * In the ESTABLISHED state, we call upon the application
   1028                         * to do the actual retransmit after which we jump into
   1029                         * the code for sending out the packet (the apprexmit
   1030                         * label).
   1031                         */
   1032                        uip_flags = UIP_REXMIT;
   1033                        UIP_APPCALL();
   1034                        goto apprexmit;
   1035                               
   1036                      case UIP_FIN_WAIT_1:
   1037                      case UIP_CLOSING:
   1038                      case UIP_LAST_ACK:
   1039                        /* In all these states we should retransmit a FINACK. */
   1040                        goto tcp_send_finack;
   1041                    }
   1042                  }
   1043                } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
   1044                  /*
   1045                   * If there was no need for a retransmission, we poll the
   1046                   * application for new data.
   1047                   */
   1048                  uip_flags = UIP_POLL;
   1049                  UIP_APPCALL();
   1050                  goto appsend;
   1051                }
   1052              }
   1053              goto drop;
   1054          #endif /* UIP_TCP */
   1055            }
   1056          #if UIP_UDP
   1057            if(flag == UIP_UDP_TIMER) {
   1058              if(uip_udp_conn->lport != 0) {
   1059                uip_conn = NULL;
   1060                uip_sappdata = uip_appdata = &uip_buf[UIP_IPUDPH_LEN + UIP_LLH_LEN];
   1061                uip_len = uip_slen = 0;
   1062                uip_flags = UIP_POLL;
   1063                UIP_UDP_APPCALL();
   1064                goto udp_send;
   1065              } else {
   1066                goto drop;
   1067              }
   1068            }
   1069          #endif /* UIP_UDP */
   1070          
   1071            
   1072            /* This is where the input processing starts. */
   1073            UIP_STAT(++uip_stat.ip.recv);
   1074             
   1075            /* Start of IP input header processing code. */
   1076             
   1077            /* Check validity of the IP header. */
   1078            if((UIP_IP_BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
   1079              UIP_STAT(++uip_stat.ip.drop);
   1080              UIP_STAT(++uip_stat.ip.vhlerr);
   1081              UIP_LOG("ipv6: invalid version.");
   1082              goto drop;
   1083            }
   1084            /*
   1085             * Check the size of the packet. If the size reported to us in
   1086             * uip_len is smaller the size reported in the IP header, we assume
   1087             * that the packet has been corrupted in transit. If the size of
   1088             * uip_len is larger than the size reported in the IP packet header,
   1089             * the packet has been padded and we set uip_len to the correct
   1090             * value..
   1091             */
   1092             
   1093            if((UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1] <= uip_len) {
   1094              uip_len = (UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1] + UIP_IPH_LEN;
   1095              /*
   1096               * The length reported in the IPv6 header is the
   1097               * length of the payload that follows the
   1098               * header. However, uIP uses the uip_len variable
   1099               * for holding the size of the entire packet,
   1100               * including the IP header. For IPv4 this is not a
   1101               * problem as the length field in the IPv4 header
   1102               * contains the length of the entire packet. But
   1103               * for IPv6 we need to add the size of the IPv6
   1104               * header (40 bytes).
   1105               */
   1106            } else {
   1107              UIP_LOG("ip: packet shorter than reported in IP header.");
   1108              goto drop;
   1109            }
   1110            
   1111            PRINTF("IPv6 packet received from ");
   1112            PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
   1113            PRINTF(" to ");
   1114            PRINT6ADDR(&UIP_IP_BUF->destipaddr);
   1115            PRINTF("\n");
   1116          
   1117            if(uip_is_addr_mcast(&UIP_IP_BUF->srcipaddr)){
   1118              UIP_STAT(++uip_stat.ip.drop);
   1119              PRINTF("Dropping packet, src is mcast\n");
   1120              goto drop;
   1121            }
   1122          
   1123          #if UIP_CONF_ROUTER
   1124            /*
   1125             * Next header field processing. In IPv6, we can have extension headers,
   1126             * if present, the Hop-by-Hop Option must be processed before forwarding
   1127             * the packet.
   1128             */
   1129            uip_next_hdr = &UIP_IP_BUF->proto;
   1130            uip_ext_len = 0;
   1131            uip_ext_bitmap = 0;
   1132            if(*uip_next_hdr == UIP_PROTO_HBHO) {
   1133          #if UIP_CONF_IPV6_CHECKS
   1134              uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_HBHO;
   1135          #endif /* UIP_CONF_IPV6_CHECKS */
   1136              switch(ext_hdr_options_process()) {
   1137                case 0:
   1138                  /* continue */
   1139                  uip_next_hdr = &UIP_EXT_BUF->next;
   1140                  uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
   1141                  break;
   1142                case 1:
   1143          	PRINTF("Dropping packet after extension header processing\n");
   1144                  /* silently discard */
   1145                  goto drop;
   1146                case 2:
   1147          	PRINTF("Sending error message after extension header processing\n");
   1148                  /* send icmp error message (created in ext_hdr_options_process)
   1149                   * and discard*/
   1150                  goto send;
   1151              }
   1152            }
   1153          
   1154          
   1155            /* TBD Some Parameter problem messages */
   1156            if(!uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr) &&
   1157               !uip_ds6_is_my_maddr(&UIP_IP_BUF->destipaddr)) {
   1158              if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr) &&
   1159                 !uip_is_addr_link_local(&UIP_IP_BUF->destipaddr) &&
   1160                 !uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr) &&
   1161                 !uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr) &&
   1162                 !uip_is_addr_loopback(&UIP_IP_BUF->destipaddr)) {
   1163          
   1164          
   1165                /* Check MTU */
   1166                if(uip_len > UIP_LINK_MTU) {
   1167                  uip_icmp6_error_output(ICMP6_PACKET_TOO_BIG, 0, UIP_LINK_MTU);
   1168                  UIP_STAT(++uip_stat.ip.drop);
   1169                  goto send;
   1170                }
   1171                /* Check Hop Limit */
   1172                if(UIP_IP_BUF->ttl <= 1) {
   1173                  uip_icmp6_error_output(ICMP6_TIME_EXCEEDED,
   1174                                         ICMP6_TIME_EXCEED_TRANSIT, 0);
   1175                  UIP_STAT(++uip_stat.ip.drop);
   1176                  goto send;
   1177                }
   1178          
   1179          #if UIP_CONF_IPV6_RPL
   1180                rpl_update_header_empty();
   1181          #endif /* UIP_CONF_IPV6_RPL */
   1182          
   1183                UIP_IP_BUF->ttl = UIP_IP_BUF->ttl - 1;
   1184                PRINTF("Forwarding packet to ");
   1185                PRINT6ADDR(&UIP_IP_BUF->destipaddr);
   1186                PRINTF("\n");
   1187                UIP_STAT(++uip_stat.ip.forwarded);
   1188                goto send;
   1189              } else {
   1190                if((uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr)) &&
   1191                   (!uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) &&
   1192                   (!uip_is_addr_loopback(&UIP_IP_BUF->destipaddr)) &&
   1193                   (!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) &&
   1194                   (!uip_ds6_is_addr_onlink((&UIP_IP_BUF->destipaddr)))) {
   1195                  PRINTF("LL source address with off link destination, dropping\n");
   1196                  uip_icmp6_error_output(ICMP6_DST_UNREACH,
   1197                                         ICMP6_DST_UNREACH_NOTNEIGHBOR, 0);
   1198                  goto send;
   1199                }
   1200                PRINTF("Dropping packet, not for me and link local or multicast\n");
   1201                UIP_STAT(++uip_stat.ip.drop);
   1202                goto drop;
   1203              }
   1204            }
   1205          #else /* UIP_CONF_ROUTER */
   1206            if(!uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr) &&
   1207               !uip_ds6_is_my_maddr(&UIP_IP_BUF->destipaddr) &&
   1208               !uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
   1209              PRINTF("Dropping packet, not for me\n");
   1210              UIP_STAT(++uip_stat.ip.drop);
   1211              goto drop;
   1212            }
   1213          
   1214            /*
   1215             * Next header field processing. In IPv6, we can have extension headers,
   1216             * they are processed here
   1217             */
   1218            uip_next_hdr = &UIP_IP_BUF->proto;
   1219            uip_ext_len = 0;
   1220            uip_ext_bitmap = 0;
   1221          #endif /* UIP_CONF_ROUTER */
   1222          
   1223            while(1) {
   1224              switch(*uip_next_hdr){
   1225          #if UIP_TCP
   1226                case UIP_PROTO_TCP:
   1227                  /* TCP, for both IPv4 and IPv6 */
   1228                  goto tcp_input;
   1229          #endif /* UIP_TCP */
   1230          #if UIP_UDP
   1231                case UIP_PROTO_UDP:
   1232                  /* UDP, for both IPv4 and IPv6 */
   1233                  goto udp_input;
   1234          #endif /* UIP_UDP */
   1235                case UIP_PROTO_ICMP6:
   1236                  /* ICMPv6 */
   1237                  goto icmp6_input;
   1238                case UIP_PROTO_HBHO:
   1239                  PRINTF("Processing hbh header\n");
   1240                  /* Hop by hop option header */
   1241          #if UIP_CONF_IPV6_CHECKS
   1242                  /* Hop by hop option header. If we saw one HBH already, drop */
   1243                  if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_HBHO) {
   1244                    goto bad_hdr;
   1245                  } else {
   1246                    uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_HBHO;
   1247                  }
   1248          #endif /*UIP_CONF_IPV6_CHECKS*/
   1249                  switch(ext_hdr_options_process()) {
   1250                    case 0:
   1251                      /*continue*/
   1252                      uip_next_hdr = &UIP_EXT_BUF->next;
   1253                      uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
   1254                      break;
   1255                    case 1:
   1256                      /*silently discard*/
   1257                      goto drop;
   1258                    case 2:
   1259                      /* send icmp error message (created in ext_hdr_options_process)
   1260                       * and discard*/
   1261                      goto send;
   1262                  }
   1263                  break;
   1264                case UIP_PROTO_DESTO:
   1265          #if UIP_CONF_IPV6_CHECKS
   1266                  /* Destination option header. if we saw two already, drop */
   1267                  PRINTF("Processing desto header\n");
   1268                  if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO1) {
   1269                    if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO2) {
   1270                      goto bad_hdr;
   1271                    } else{
   1272                      uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO2;
   1273                    }
   1274                  } else {
   1275                    uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO1;
   1276                  }
   1277          #endif /*UIP_CONF_IPV6_CHECKS*/
   1278                  switch(ext_hdr_options_process()) {
   1279                    case 0:
   1280                      /*continue*/
   1281                      uip_next_hdr = &UIP_EXT_BUF->next;
   1282                      uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
   1283                      break;
   1284                    case 1:
   1285                      /*silently discard*/
   1286                      goto drop;
   1287                    case 2:
   1288                      /* send icmp error message (created in ext_hdr_options_process)
   1289                       * and discard*/
   1290                      goto send;
   1291                  }
   1292                  break;
   1293                case UIP_PROTO_ROUTING:
   1294          #if UIP_CONF_IPV6_CHECKS
   1295                  /* Routing header. If we saw one already, drop */
   1296                  if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_ROUTING) {
   1297                    goto bad_hdr;
   1298                  } else {
   1299                    uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_ROUTING;
   1300                  }
   1301          #endif /*UIP_CONF_IPV6_CHECKS*/
   1302                  /*
   1303                   * Routing Header  length field is in units of 8 bytes, excluding
   1304                   * As per RFC2460 section 4.4, if routing type is unrecognized:
   1305                   * if segments left = 0, ignore the header
   1306                   * if segments left > 0, discard packet and send icmp error pointing
   1307                   * to the routing type
   1308                   */
   1309          
   1310                  PRINTF("Processing Routing header\n");
   1311                  if(UIP_ROUTING_BUF->seg_left > 0) {
   1312                    uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, UIP_IPH_LEN + uip_ext_len + 2);
   1313                    UIP_STAT(++uip_stat.ip.drop);
   1314                    UIP_LOG("ip6: unrecognized routing type");
   1315                    goto send;
   1316                  }
   1317                  uip_next_hdr = &UIP_EXT_BUF->next;
   1318                  uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
   1319                  break;
   1320                case UIP_PROTO_FRAG:
   1321                  /* Fragmentation header:call the reassembly function, then leave */
   1322          #if UIP_CONF_IPV6_REASSEMBLY
   1323                  PRINTF("Processing frag header\n");
   1324                  uip_len = uip_reass();
   1325                  if(uip_len == 0) {
   1326                    goto drop;
   1327                  }
   1328                  if(uip_reassflags & UIP_REASS_FLAG_ERROR_MSG){
   1329                    /* we are not done with reassembly, this is an error message */
   1330                    goto send;
   1331                  }
   1332                  /*packet is reassembled, reset the next hdr to the beginning
   1333                     of the IP header and restart the parsing of the reassembled pkt*/
   1334                  PRINTF("Processing reassembled packet\n");
   1335                  uip_ext_len = 0;
   1336                  uip_ext_bitmap = 0;
   1337                  uip_next_hdr = &UIP_IP_BUF->proto;
   1338                  break;
   1339          #else /* UIP_CONF_IPV6_REASSEMBLY */
   1340                  UIP_STAT(++uip_stat.ip.drop);
   1341                  UIP_STAT(++uip_stat.ip.fragerr);
   1342                  UIP_LOG("ip: fragment dropped.");
   1343                  goto drop;
   1344          #endif /* UIP_CONF_IPV6_REASSEMBLY */
   1345                case UIP_PROTO_NONE:
   1346                  goto drop;
   1347                default:
   1348                  goto bad_hdr;
   1349              }
   1350            }
   1351            bad_hdr:
   1352            /*
   1353             * RFC 2460 send error message parameterr problem, code unrecognized
   1354             * next header, pointing to the next header field
   1355             */
   1356            uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER, (uint32_t)(uip_next_hdr - (uint8_t *)UIP_IP_BUF));
   1357            UIP_STAT(++uip_stat.ip.drop);
   1358            UIP_STAT(++uip_stat.ip.protoerr);
   1359            UIP_LOG("ip6: unrecognized header");
   1360            goto send;
   1361            /* End of headers processing */
   1362            
   1363            icmp6_input:
   1364            /* This is IPv6 ICMPv6 processing code. */
   1365            PRINTF("icmp6_input: length %d type: %d \n", uip_len, UIP_ICMP_BUF->type);
   1366          
   1367          #if UIP_CONF_IPV6_CHECKS
   1368            /* Compute and check the ICMP header checksum */
   1369            if(uip_icmp6chksum() != 0xffff) {
   1370              UIP_STAT(++uip_stat.icmp.drop);
   1371              UIP_STAT(++uip_stat.icmp.chkerr);
   1372              UIP_LOG("icmpv6: bad checksum.");
   1373              PRINTF("icmpv6: bad checksum.");
   1374              goto drop;
   1375            }
   1376          #endif /*UIP_CONF_IPV6_CHECKS*/
   1377          
   1378            UIP_STAT(++uip_stat.icmp.recv);
   1379            /*
   1380             * Here we process incoming ICMPv6 packets
   1381             * For echo request, we send echo reply
   1382             * For ND pkts, we call the appropriate function in uip-nd6.c
   1383             * We do not treat Error messages for now
   1384             * If no pkt is to be sent as an answer to the incoming one, we
   1385             * "goto drop". Else we just break; then at the after the "switch"
   1386             * we "goto send"
   1387             */
   1388          #if UIP_CONF_ICMP6
   1389            UIP_ICMP6_APPCALL(UIP_ICMP_BUF->type);
   1390          #endif /*UIP_CONF_ICMP6*/
   1391          
   1392            switch(UIP_ICMP_BUF->type) {
   1393              case ICMP6_NS:
   1394          #if UIP_ND6_SEND_NA
   1395                uip_nd6_ns_input();
   1396          #else /* UIP_ND6_SEND_NA */
   1397                UIP_STAT(++uip_stat.icmp.drop);
   1398                uip_len = 0;
   1399          #endif /* UIP_ND6_SEND_NA */
   1400                break;
   1401              case ICMP6_NA:
   1402          #if UIP_ND6_SEND_NA
   1403                uip_nd6_na_input();
   1404          #else /* UIP_ND6_SEND_NA */
   1405                UIP_STAT(++uip_stat.icmp.drop);
   1406                uip_len = 0;
   1407          #endif /* UIP_ND6_SEND_NA */
   1408                break;
   1409              case ICMP6_RS:
   1410          #if UIP_CONF_ROUTER && UIP_ND6_SEND_RA
   1411              uip_nd6_rs_input();
   1412          #else /* UIP_CONF_ROUTER && UIP_ND6_SEND_RA */
   1413              UIP_STAT(++uip_stat.icmp.drop);
   1414              uip_len = 0;
   1415          #endif /* UIP_CONF_ROUTER && UIP_ND6_SEND_RA */
   1416              break;
   1417            case ICMP6_RA:
   1418          #if UIP_CONF_ROUTER
   1419              UIP_STAT(++uip_stat.icmp.drop);
   1420              uip_len = 0;
   1421          #else /* UIP_CONF_ROUTER */
   1422              uip_nd6_ra_input();
   1423          #endif /* UIP_CONF_ROUTER */
   1424              break;
   1425          #if UIP_CONF_IPV6_RPL
   1426            case ICMP6_RPL:
   1427              uip_rpl_input();
   1428              break;
   1429          #endif /* UIP_CONF_IPV6_RPL */
   1430              case ICMP6_ECHO_REQUEST:
   1431                uip_icmp6_echo_request_input();
   1432                break;
   1433              case ICMP6_ECHO_REPLY:
   1434                /** \note We don't implement any application callback for now */
   1435                PRINTF("Received an icmp6 echo reply\n");
   1436                UIP_STAT(++uip_stat.icmp.recv);
   1437                uip_len = 0;
   1438                break;
   1439              default:
   1440                PRINTF("Unknown icmp6 message type %d\n", UIP_ICMP_BUF->type);
   1441                UIP_STAT(++uip_stat.icmp.drop);
   1442                UIP_STAT(++uip_stat.icmp.typeerr);
   1443                UIP_LOG("icmp6: unknown ICMP message.");
   1444                uip_len = 0;
   1445                break;
   1446            }
   1447            
   1448            if(uip_len > 0) {
   1449              goto send;
   1450            } else {
   1451              goto drop;
   1452            }
   1453            /* End of IPv6 ICMP processing. */
   1454             
   1455          
   1456          #if UIP_UDP
   1457            /* UDP input processing. */
   1458           udp_input:
   1459          
   1460            remove_ext_hdr();
   1461          
   1462            PRINTF("Receiving UDP packet\n");
   1463            UIP_STAT(++uip_stat.udp.recv);
   1464           
   1465            /* UDP processing is really just a hack. We don't do anything to the
   1466               UDP/IP headers, but let the UDP application do all the hard
   1467               work. If the application sets uip_slen, it has a packet to
   1468               send. */
   1469          #if UIP_UDP_CHECKSUMS
   1470            uip_len = uip_len - UIP_IPUDPH_LEN;
   1471            uip_appdata = &uip_buf[UIP_IPUDPH_LEN + UIP_LLH_LEN];
   1472            /* XXX hack: UDP/IPv6 receivers should drop packets with UDP
   1473               checksum 0. Here, we explicitly receive UDP packets with checksum
   1474               0. This is to be able to debug code that for one reason or
   1475               another miscomputes UDP checksums. The reception of zero UDP
   1476               checksums should be turned into a configration option. */
   1477            if(UIP_UDP_BUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
   1478              UIP_STAT(++uip_stat.udp.drop);
   1479              UIP_STAT(++uip_stat.udp.chkerr);
   1480              PRINTF("udp: bad checksum 0x%04x 0x%04x\n", UIP_UDP_BUF->udpchksum,
   1481                     uip_udpchksum());
   1482              goto drop;
   1483            }
   1484          #else /* UIP_UDP_CHECKSUMS */
   1485            uip_len = uip_len - UIP_IPUDPH_LEN;
   1486          #endif /* UIP_UDP_CHECKSUMS */
   1487          
   1488            /* Make sure that the UDP destination port number is not zero. */
   1489            if(UIP_UDP_BUF->destport == 0) {
   1490              PRINTF("udp: zero port.\n");
   1491              goto drop;
   1492            }
   1493          
   1494            /* Demultiplex this UDP packet between the UDP "connections". */
   1495            for(uip_udp_conn = &uip_udp_conns[0];
   1496                uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
   1497                ++uip_udp_conn) {
   1498              /* If the local UDP port is non-zero, the connection is considered
   1499                 to be used. If so, the local port number is checked against the
   1500                 destination port number in the received packet. If the two port
   1501                 numbers match, the remote port number is checked if the
   1502                 connection is bound to a remote port. Finally, if the
   1503                 connection is bound to a remote IP address, the source IP
   1504                 address of the packet is checked. */
   1505              if(uip_udp_conn->lport != 0 &&
   1506                 UIP_UDP_BUF->destport == uip_udp_conn->lport &&
   1507                 (uip_udp_conn->rport == 0 ||
   1508                  UIP_UDP_BUF->srcport == uip_udp_conn->rport) &&
   1509                 (uip_is_addr_unspecified(&uip_udp_conn->ripaddr) ||
   1510                  uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
   1511                goto udp_found;
   1512              }
   1513            }
   1514            PRINTF("udp: no matching connection found\n");
   1515          
   1516          #if UIP_UDP_SEND_UNREACH_NOPORT
   1517            uip_icmp6_error_output(ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT, 0);
   1518            UIP_STAT(++uip_stat.ip.drop);
   1519            goto send;
   1520          #else
   1521            goto drop;
   1522          #endif
   1523          
   1524           udp_found:
   1525            PRINTF("In udp_found\n");
   1526           
   1527            uip_conn = NULL;
   1528            uip_flags = UIP_NEWDATA;
   1529            uip_sappdata = uip_appdata = &uip_buf[UIP_IPUDPH_LEN + UIP_LLH_LEN];
   1530            uip_slen = 0;
   1531            UIP_UDP_APPCALL();
   1532          
   1533           udp_send:
   1534            PRINTF("In udp_send\n");
   1535          
   1536            if(uip_slen == 0) {
   \                     ??uip_process_1:
   \   00000C   90....       MOV     DPTR,#uip_slen
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F8           MOV     R0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F9           MOV     R1,A
   \   000014   E8           MOV     A,R0
   \   000015   49           ORL     A,R1
   \   000016   6003         JZ      $+5
   \   000018   02....       LJMP    ??uip_process_2 & 0xFFFF
   1537              goto drop;
   \   00001B   8074         SJMP    ??uip_process_3
   1538            }
   \                     ??uip_process_0:
   \   00001D   78..         MOV     R0,#(uip_aligned_buf + 60) & 0xff
   \   00001F   79..         MOV     R1,#((uip_aligned_buf + 60) >> 8) & 0xff
   \   000021   90....       MOV     DPTR,#uip_appdata
   \   000024   E8           MOV     A,R0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   E9           MOV     A,R1
   \   000028   F0           MOVX    @DPTR,A
   \   000029   90....       MOV     DPTR,#uip_sappdata
   \   00002C   E8           MOV     A,R0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E9           MOV     A,R1
   \   000030   F0           MOVX    @DPTR,A
   \   000031   7403         MOV     A,#0x3
   \   000033   6E           XRL     A,R6
   \   000034   7405         MOV     A,#0x5
   \   000036   6E           XRL     A,R6
   \   000037   7079         JNZ     ??uip_process_4
   \   000039   90....       MOV     DPTR,#uip_udp_conn
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   C8           XCH     A,R0
   \   000041   2410         ADD     A,#0x10
   \   000043   F582         MOV     DPL,A
   \   000045   E8           MOV     A,R0
   \   000046   3400         ADDC    A,#0x0
   \   000048   F583         MOV     DPH,A
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F8           MOV     R0,A
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F9           MOV     R1,A
   \   00004F   E8           MOV     A,R0
   \   000050   49           ORL     A,R1
   \   000051   603E         JZ      ??uip_process_3
   \   000053   90....       MOV     DPTR,#uip_conn
   \   000056   7400         MOV     A,#0x0
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   7400         MOV     A,#0x0
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   78..         MOV     R0,#(uip_aligned_buf + 48) & 0xff
   \   00005F   79..         MOV     R1,#((uip_aligned_buf + 48) >> 8) & 0xff
   \   000061   90....       MOV     DPTR,#uip_appdata
   \   000064   E8           MOV     A,R0
   \   000065   F0           MOVX    @DPTR,A
   \   000066   A3           INC     DPTR
   \   000067   E9           MOV     A,R1
   \   000068   F0           MOVX    @DPTR,A
   \   000069   90....       MOV     DPTR,#uip_sappdata
   \   00006C   E8           MOV     A,R0
   \   00006D   F0           MOVX    @DPTR,A
   \   00006E   A3           INC     DPTR
   \   00006F   E9           MOV     A,R1
   \   000070   F0           MOVX    @DPTR,A
   \   000071   7800         MOV     R0,#0x0
   \   000073   7900         MOV     R1,#0x0
   \   000075   90....       MOV     DPTR,#uip_slen
   \   000078   E8           MOV     A,R0
   \   000079   F0           MOVX    @DPTR,A
   \   00007A   A3           INC     DPTR
   \   00007B   E9           MOV     A,R1
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   90....       MOV     DPTR,#uip_len
   \   000080   E8           MOV     A,R0
   \   000081   F0           MOVX    @DPTR,A
   \   000082   A3           INC     DPTR
   \   000083   E9           MOV     A,R1
   \   000084   F0           MOVX    @DPTR,A
   \   000085   90....       MOV     DPTR,#uip_flags
   \   000088   7408         MOV     A,#0x8
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B                ; Setup parameters for call to function tcpip_uipcall
   \   00008B   12....       LCALL   ??tcpip_uipcall?relay
   \   00008E   02....       LJMP    ??uip_process_1 & 0xFFFF
   1539            uip_len = uip_slen + UIP_IPUDPH_LEN;
   1540          
   1541            /* For IPv6, the IP length field does not include the IPv6 IP header
   1542               length. */
   1543            UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
   1544            UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
   1545          
   1546            UIP_IP_BUF->ttl = uip_udp_conn->ttl;
   1547            UIP_IP_BUF->proto = UIP_PROTO_UDP;
   1548          
   1549            UIP_UDP_BUF->udplen = UIP_HTONS(uip_slen + UIP_UDPH_LEN);
   1550            UIP_UDP_BUF->udpchksum = 0;
   1551          
   1552            UIP_UDP_BUF->srcport  = uip_udp_conn->lport;
   1553            UIP_UDP_BUF->destport = uip_udp_conn->rport;
   1554          
   1555            uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_udp_conn->ripaddr);
   1556            uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
   1557          
   1558            uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
   1559          
   1560          #if UIP_CONF_IPV6_RPL
   1561            rpl_insert_header();
   1562          #endif /* UIP_CONF_IPV6_RPL */
   1563          
   1564          #if UIP_UDP_CHECKSUMS
   1565            /* Calculate UDP checksum. */
   1566            UIP_UDP_BUF->udpchksum = ~(uip_udpchksum());
   1567            if(UIP_UDP_BUF->udpchksum == 0) {
   1568              UIP_UDP_BUF->udpchksum = 0xffff;
   1569            }
   1570          #endif /* UIP_UDP_CHECKSUMS */
   1571            UIP_STAT(++uip_stat.udp.sent);
   1572            goto ip_send_nolen;
   1573          #endif /* UIP_UDP */
   1574          
   1575          #if UIP_TCP
   1576            /* TCP input processing. */
   1577           tcp_input:
   1578          
   1579            remove_ext_hdr();
   1580          
   1581            UIP_STAT(++uip_stat.tcp.recv);
   1582            PRINTF("Receiving TCP packet\n");
   1583            /* Start of TCP input header processing code. */
   1584            
   1585            if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
   1586                                                 checksum. */
   1587              UIP_STAT(++uip_stat.tcp.drop);
   1588              UIP_STAT(++uip_stat.tcp.chkerr);
   1589              PRINTF("tcp: bad checksum 0x%04x 0x%04x\n", UIP_TCP_BUF->tcpchksum,
   1590                     uip_tcpchksum());
   1591              goto drop;
   1592            }
   1593          
   1594            /* Make sure that the TCP port number is not zero. */
   1595            if(UIP_TCP_BUF->destport == 0 || UIP_TCP_BUF->srcport == 0) {
   1596              PRINTF("tcp: zero port.");
   1597              goto drop;
   1598            }
   1599          
   1600            /* Demultiplex this segment. */
   1601            /* First check any active connections. */
   1602            for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
   1603                ++uip_connr) {
   1604              if(uip_connr->tcpstateflags != UIP_CLOSED &&
   1605                 UIP_TCP_BUF->destport == uip_connr->lport &&
   1606                 UIP_TCP_BUF->srcport == uip_connr->rport &&
   1607                 uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_connr->ripaddr)) {
   1608                goto found;
   1609              }
   1610            }
   1611          
   1612            /* If we didn't find and active connection that expected the packet,
   1613               either this packet is an old duplicate, or this is a SYN packet
   1614               destined for a connection in LISTEN. If the SYN flag isn't set,
   1615               it is an old packet and we send a RST. */
   1616            if((UIP_TCP_BUF->flags & TCP_CTL) != TCP_SYN) {
   1617              goto reset;
   1618            }
   1619            
   1620            tmp16 = UIP_TCP_BUF->destport;
   1621            /* Next, check listening connections. */
   1622            for(c = 0; c < UIP_LISTENPORTS; ++c) {
   1623              if(tmp16 == uip_listenports[c]) {
   1624                goto found_listen;
   1625              }
   1626            }
   1627            
   1628            /* No matching connection found, so we send a RST packet. */
   1629            UIP_STAT(++uip_stat.tcp.synrst);
   1630          
   1631           reset:
   1632            PRINTF("In reset\n");
   1633            /* We do not send resets in response to resets. */
   1634            if(UIP_TCP_BUF->flags & TCP_RST) {
   1635              goto drop;
   1636            }
   1637          
   1638            UIP_STAT(++uip_stat.tcp.rst);
   1639            
   1640            UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
   1641            uip_len = UIP_IPTCPH_LEN;
   1642            UIP_TCP_BUF->tcpoffset = 5 << 4;
   1643          
   1644            /* Flip the seqno and ackno fields in the TCP header. */
   1645            c = UIP_TCP_BUF->seqno[3];
   1646            UIP_TCP_BUF->seqno[3] = UIP_TCP_BUF->ackno[3];
   1647            UIP_TCP_BUF->ackno[3] = c;
   1648            
   1649            c = UIP_TCP_BUF->seqno[2];
   1650            UIP_TCP_BUF->seqno[2] = UIP_TCP_BUF->ackno[2];
   1651            UIP_TCP_BUF->ackno[2] = c;
   1652            
   1653            c = UIP_TCP_BUF->seqno[1];
   1654            UIP_TCP_BUF->seqno[1] = UIP_TCP_BUF->ackno[1];
   1655            UIP_TCP_BUF->ackno[1] = c;
   1656            
   1657            c = UIP_TCP_BUF->seqno[0];
   1658            UIP_TCP_BUF->seqno[0] = UIP_TCP_BUF->ackno[0];
   1659            UIP_TCP_BUF->ackno[0] = c;
   1660          
   1661            /* We also have to increase the sequence number we are
   1662               acknowledging. If the least significant byte overflowed, we need
   1663               to propagate the carry to the other bytes as well. */
   1664            if(++UIP_TCP_BUF->ackno[3] == 0) {
   1665              if(++UIP_TCP_BUF->ackno[2] == 0) {
   1666                if(++UIP_TCP_BUF->ackno[1] == 0) {
   1667                  ++UIP_TCP_BUF->ackno[0];
   1668                }
   1669              }
   1670            }
   1671           
   1672            /* Swap port numbers. */
   1673            tmp16 = UIP_TCP_BUF->srcport;
   1674            UIP_TCP_BUF->srcport = UIP_TCP_BUF->destport;
   1675            UIP_TCP_BUF->destport = tmp16;
   1676            
   1677            /* Swap IP addresses. */
   1678            uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);
   1679            uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
   1680            /* And send out the RST packet! */
   1681            goto tcp_send_noconn;
   1682          
   1683            /* This label will be jumped to if we matched the incoming packet
   1684               with a connection in LISTEN. In that case, we should create a new
   1685               connection and send a SYNACK in return. */
   1686           found_listen:
   1687            PRINTF("In found listen\n");
   1688            /* First we check if there are any connections avaliable. Unused
   1689               connections are kept in the same table as used connections, but
   1690               unused ones have the tcpstate set to CLOSED. Also, connections in
   1691               TIME_WAIT are kept track of and we'll use the oldest one if no
   1692               CLOSED connections are found. Thanks to Eddie C. Dost for a very
   1693               nice algorithm for the TIME_WAIT search. */
   1694            uip_connr = 0;
   1695            for(c = 0; c < UIP_CONNS; ++c) {
   1696              if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
   1697                uip_connr = &uip_conns[c];
   1698                break;
   1699              }
   1700              if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
   1701                if(uip_connr == 0 ||
   1702                   uip_conns[c].timer > uip_connr->timer) {
   1703                  uip_connr = &uip_conns[c];
   1704                }
   1705              }
   1706            }
   1707          
   1708            if(uip_connr == 0) {
   1709              /* All connections are used already, we drop packet and hope that
   1710                 the remote end will retransmit the packet at a time when we
   1711                 have more spare connections. */
   1712              UIP_STAT(++uip_stat.tcp.syndrop);
   1713              UIP_LOG("tcp: found no unused connections.");
   1714              goto drop;
   1715            }
   1716            uip_conn = uip_connr;
   1717            
   1718            /* Fill in the necessary fields for the new connection. */
   1719            uip_connr->rto = uip_connr->timer = UIP_RTO;
   1720            uip_connr->sa = 0;
   1721            uip_connr->sv = 4;
   1722            uip_connr->nrtx = 0;
   1723            uip_connr->lport = UIP_TCP_BUF->destport;
   1724            uip_connr->rport = UIP_TCP_BUF->srcport;
   1725            uip_ipaddr_copy(&uip_connr->ripaddr, &UIP_IP_BUF->srcipaddr);
   1726            uip_connr->tcpstateflags = UIP_SYN_RCVD;
   1727          
   1728            uip_connr->snd_nxt[0] = iss[0];
   1729            uip_connr->snd_nxt[1] = iss[1];
   1730            uip_connr->snd_nxt[2] = iss[2];
   1731            uip_connr->snd_nxt[3] = iss[3];
   1732            uip_connr->len = 1;
   1733          
   1734            /* rcv_nxt should be the seqno from the incoming packet + 1. */
   1735            uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];
   1736            uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];
   1737            uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];
   1738            uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];
   1739            uip_add_rcv_nxt(1);
   1740          
   1741            /* Parse the TCP MSS option, if present. */
   1742            if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {
   1743              for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
   1744                opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
   1745                if(opt == TCP_OPT_END) {
   1746                  /* End of options. */
   1747                  break;
   1748                } else if(opt == TCP_OPT_NOOP) {
   1749                  ++c;
   1750                  /* NOP option. */
   1751                } else if(opt == TCP_OPT_MSS &&
   1752                          uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
   1753                  /* An MSS option with the right option length. */
   1754                  tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
   1755                    (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
   1756                  uip_connr->initialmss = uip_connr->mss =
   1757                    tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
   1758             
   1759                  /* And we are done processing options. */
   1760                  break;
   1761                } else {
   1762                  /* All other options have a length field, so that we easily
   1763                     can skip past them. */
   1764                  if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
   1765                    /* If the length field is zero, the options are malformed
   1766                       and we don't process them further. */
   1767                    break;
   1768                  }
   1769                  c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
   1770                }
   1771              }
   1772            }
   1773            
   1774            /* Our response will be a SYNACK. */
   1775          #if UIP_ACTIVE_OPEN
   1776           tcp_send_synack:
   1777            UIP_TCP_BUF->flags = TCP_ACK;
   1778            
   1779           tcp_send_syn:
   1780            UIP_TCP_BUF->flags |= TCP_SYN;
   1781          #else /* UIP_ACTIVE_OPEN */
   1782           tcp_send_synack:
   1783            UIP_TCP_BUF->flags = TCP_SYN | TCP_ACK;
   1784          #endif /* UIP_ACTIVE_OPEN */
   1785            
   1786            /* We send out the TCP Maximum Segment Size option with our
   1787               SYNACK. */
   1788            UIP_TCP_BUF->optdata[0] = TCP_OPT_MSS;
   1789            UIP_TCP_BUF->optdata[1] = TCP_OPT_MSS_LEN;
   1790            UIP_TCP_BUF->optdata[2] = (UIP_TCP_MSS) / 256;
   1791            UIP_TCP_BUF->optdata[3] = (UIP_TCP_MSS) & 255;
   1792            uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
   1793            UIP_TCP_BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
   1794            goto tcp_send;
   1795          
   1796            /* This label will be jumped to if we found an active connection. */
   1797           found:
   1798            PRINTF("In found\n");
   1799            uip_conn = uip_connr;
   1800            uip_flags = 0;
   1801            /* We do a very naive form of TCP reset processing; we just accept
   1802               any RST and kill our connection. We should in fact check if the
   1803               sequence number of this reset is wihtin our advertised window
   1804               before we accept the reset. */
   1805            if(UIP_TCP_BUF->flags & TCP_RST) {
   1806              uip_connr->tcpstateflags = UIP_CLOSED;
   1807              UIP_LOG("tcp: got reset, aborting connection.");
   1808              uip_flags = UIP_ABORT;
   1809              UIP_APPCALL();
   1810              goto drop;
   1811            }
   1812            /* Calculate the length of the data, if the application has sent
   1813               any data to us. */
   1814            c = (UIP_TCP_BUF->tcpoffset >> 4) << 2;
   1815            /* uip_len will contain the length of the actual TCP data. This is
   1816               calculated by subtracing the length of the TCP header (in
   1817               c) and the length of the IP header (20 bytes). */
   1818            uip_len = uip_len - c - UIP_IPH_LEN;
   1819          
   1820            /* First, check if the sequence number of the incoming packet is
   1821               what we're expecting next. If not, we send out an ACK with the
   1822               correct numbers in, unless we are in the SYN_RCVD state and
   1823               receive a SYN, in which case we should retransmit our SYNACK
   1824               (which is done futher down). */
   1825            if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
   1826          	((UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
   1827                 (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
   1828          	((UIP_TCP_BUF->flags & TCP_CTL) == TCP_SYN)))) {
   1829              if((uip_len > 0 || ((UIP_TCP_BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
   1830                 (UIP_TCP_BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
   1831                  UIP_TCP_BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
   1832                  UIP_TCP_BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
   1833                  UIP_TCP_BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
   1834          
   1835                if(UIP_TCP_BUF->flags & TCP_SYN) {
   1836                  goto tcp_send_synack;
   1837                }
   1838                goto tcp_send_ack;
   1839              }
   1840            }
   1841          
   1842            /* Next, check if the incoming segment acknowledges any outstanding
   1843               data. If so, we update the sequence number, reset the length of
   1844               the outstanding data, calculate RTT estimations, and reset the
   1845               retransmission timer. */
   1846            if((UIP_TCP_BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
   1847              uip_add32(uip_connr->snd_nxt, uip_connr->len);
   1848          
   1849              if(UIP_TCP_BUF->ackno[0] == uip_acc32[0] &&
   1850                 UIP_TCP_BUF->ackno[1] == uip_acc32[1] &&
   1851                 UIP_TCP_BUF->ackno[2] == uip_acc32[2] &&
   1852                 UIP_TCP_BUF->ackno[3] == uip_acc32[3]) {
   1853                /* Update sequence number. */
   1854                uip_connr->snd_nxt[0] = uip_acc32[0];
   1855                uip_connr->snd_nxt[1] = uip_acc32[1];
   1856                uip_connr->snd_nxt[2] = uip_acc32[2];
   1857                uip_connr->snd_nxt[3] = uip_acc32[3];
   1858             
   1859                /* Do RTT estimation, unless we have done retransmissions. */
   1860                if(uip_connr->nrtx == 0) {
   1861                  signed char m;
   1862                  m = uip_connr->rto - uip_connr->timer;
   1863                  /* This is taken directly from VJs original code in his paper */
   1864                  m = m - (uip_connr->sa >> 3);
   1865                  uip_connr->sa += m;
   1866                  if(m < 0) {
   1867                    m = -m;
   1868                  }
   1869                  m = m - (uip_connr->sv >> 2);
   1870                  uip_connr->sv += m;
   1871                  uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
   1872          
   1873                }
   1874                /* Set the acknowledged flag. */
   1875                uip_flags = UIP_ACKDATA;
   1876                /* Reset the retransmission timer. */
   1877                uip_connr->timer = uip_connr->rto;
   1878          
   1879                /* Reset length of outstanding data. */
   1880                uip_connr->len = 0;
   1881              }
   1882              
   1883            }
   1884          
   1885            /* Do different things depending on in what state the connection is. */
   1886            switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
   1887              /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
   1888                 implemented, since we force the application to close when the
   1889                 peer sends a FIN (hence the application goes directly from
   1890                 ESTABLISHED to LAST_ACK). */
   1891              case UIP_SYN_RCVD:
   1892                /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
   1893                   we are waiting for an ACK that acknowledges the data we sent
   1894                   out the last time. Therefore, we want to have the UIP_ACKDATA
   1895                   flag set. If so, we enter the ESTABLISHED state. */
   1896                if(uip_flags & UIP_ACKDATA) {
   1897                  uip_connr->tcpstateflags = UIP_ESTABLISHED;
   1898                  uip_flags = UIP_CONNECTED;
   1899                  uip_connr->len = 0;
   1900                  if(uip_len > 0) {
   1901                    uip_flags |= UIP_NEWDATA;
   1902                    uip_add_rcv_nxt(uip_len);
   1903                  }
   1904                  uip_slen = 0;
   1905                  UIP_APPCALL();
   1906                  goto appsend;
   1907                }
   1908                /* We need to retransmit the SYNACK */
   1909                if((UIP_TCP_BUF->flags & TCP_CTL) == TCP_SYN) {
   1910          	goto tcp_send_synack;
   1911                }
   1912                goto drop;
   1913          #if UIP_ACTIVE_OPEN
   1914              case UIP_SYN_SENT:
   1915                /* In SYN_SENT, we wait for a SYNACK that is sent in response to
   1916                   our SYN. The rcv_nxt is set to sequence number in the SYNACK
   1917                   plus one, and we send an ACK. We move into the ESTABLISHED
   1918                   state. */
   1919                if((uip_flags & UIP_ACKDATA) &&
   1920                   (UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
   1921          
   1922                  /* Parse the TCP MSS option, if present. */
   1923                  if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {
   1924                    for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
   1925                      opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
   1926                      if(opt == TCP_OPT_END) {
   1927                        /* End of options. */
   1928                        break;
   1929                      } else if(opt == TCP_OPT_NOOP) {
   1930                        ++c;
   1931                        /* NOP option. */
   1932                      } else if(opt == TCP_OPT_MSS &&
   1933                                uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
   1934                        /* An MSS option with the right option length. */
   1935                        tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
   1936                          uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
   1937                        uip_connr->initialmss =
   1938                          uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
   1939          
   1940                        /* And we are done processing options. */
   1941                        break;
   1942                      } else {
   1943                        /* All other options have a length field, so that we easily
   1944                           can skip past them. */
   1945                        if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
   1946                          /* If the length field is zero, the options are malformed
   1947                             and we don't process them further. */
   1948                          break;
   1949                        }
   1950                        c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
   1951                      }
   1952                    }
   1953                  }
   1954                  uip_connr->tcpstateflags = UIP_ESTABLISHED;
   1955                  uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];
   1956                  uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];
   1957                  uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];
   1958                  uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];
   1959                  uip_add_rcv_nxt(1);
   1960                  uip_flags = UIP_CONNECTED | UIP_NEWDATA;
   1961                  uip_connr->len = 0;
   1962                  uip_len = 0;
   1963                  uip_slen = 0;
   1964                  UIP_APPCALL();
   1965                  goto appsend;
   1966                }
   1967                /* Inform the application that the connection failed */
   1968                uip_flags = UIP_ABORT;
   1969                UIP_APPCALL();
   1970                /* The connection is closed after we send the RST */
   1971                uip_conn->tcpstateflags = UIP_CLOSED;
   1972                goto reset;
   1973          #endif /* UIP_ACTIVE_OPEN */
   1974              
   1975              case UIP_ESTABLISHED:
   1976                /* In the ESTABLISHED state, we call upon the application to feed
   1977                   data into the uip_buf. If the UIP_ACKDATA flag is set, the
   1978                   application should put new data into the buffer, otherwise we are
   1979                   retransmitting an old segment, and the application should put that
   1980                   data into the buffer.
   1981          
   1982                   If the incoming packet is a FIN, we should close the connection on
   1983                   this side as well, and we send out a FIN and enter the LAST_ACK
   1984                   state. We require that there is no outstanding data; otherwise the
   1985                   sequence numbers will be screwed up. */
   1986          
   1987                if(UIP_TCP_BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
   1988                  if(uip_outstanding(uip_connr)) {
   1989                    goto drop;
   1990                  }
   1991                  uip_add_rcv_nxt(1 + uip_len);
   1992                  uip_flags |= UIP_CLOSE;
   1993                  if(uip_len > 0) {
   1994                    uip_flags |= UIP_NEWDATA;
   1995                  }
   1996                  UIP_APPCALL();
   1997                  uip_connr->len = 1;
   1998                  uip_connr->tcpstateflags = UIP_LAST_ACK;
   1999                  uip_connr->nrtx = 0;
   2000                tcp_send_finack:
   2001                  UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;
   2002                  goto tcp_send_nodata;
   2003                }
   2004          
   2005                /* Check the URG flag. If this is set, the segment carries urgent
   2006                   data that we must pass to the application. */
   2007                if((UIP_TCP_BUF->flags & TCP_URG) != 0) {
   2008          #if UIP_URGDATA > 0
   2009                  uip_urglen = (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];
   2010                  if(uip_urglen > uip_len) {
   2011                    /* There is more urgent data in the next segment to come. */
   2012                    uip_urglen = uip_len;
   2013                  }
   2014                  uip_add_rcv_nxt(uip_urglen);
   2015                  uip_len -= uip_urglen;
   2016                  uip_urgdata = uip_appdata;
   2017                  uip_appdata += uip_urglen;
   2018                } else {
   2019                  uip_urglen = 0;
   2020          #else /* UIP_URGDATA > 0 */
   2021                  uip_appdata = ((char *)uip_appdata) + ((UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1]);
   2022                  uip_len -= (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];
   2023          #endif /* UIP_URGDATA > 0 */
   2024                }
   2025          
   2026                /* If uip_len > 0 we have TCP data in the packet, and we flag this
   2027                   by setting the UIP_NEWDATA flag and update the sequence number
   2028                   we acknowledge. If the application has stopped the dataflow
   2029                   using uip_stop(), we must not accept any data packets from the
   2030                   remote host. */
   2031                if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
   2032                  uip_flags |= UIP_NEWDATA;
   2033                  uip_add_rcv_nxt(uip_len);
   2034                }
   2035          
   2036                /* Check if the available buffer space advertised by the other end
   2037                   is smaller than the initial MSS for this connection. If so, we
   2038                   set the current MSS to the window size to ensure that the
   2039                   application does not send more data than the other end can
   2040                   handle.
   2041          
   2042                   If the remote host advertises a zero window, we set the MSS to
   2043                   the initial MSS so that the application will send an entire MSS
   2044                   of data. This data will not be acknowledged by the receiver,
   2045                   and the application will retransmit it. This is called the
   2046                   "persistent timer" and uses the retransmission mechanim.
   2047                */
   2048                tmp16 = ((uint16_t)UIP_TCP_BUF->wnd[0] << 8) + (uint16_t)UIP_TCP_BUF->wnd[1];
   2049                if(tmp16 > uip_connr->initialmss ||
   2050                   tmp16 == 0) {
   2051                  tmp16 = uip_connr->initialmss;
   2052                }
   2053                uip_connr->mss = tmp16;
   2054          
   2055                /* If this packet constitutes an ACK for outstanding data (flagged
   2056                   by the UIP_ACKDATA flag, we should call the application since it
   2057                   might want to send more data. If the incoming packet had data
   2058                   from the peer (as flagged by the UIP_NEWDATA flag), the
   2059                   application must also be notified.
   2060          
   2061                   When the application is called, the global variable uip_len
   2062                   contains the length of the incoming data. The application can
   2063                   access the incoming data through the global pointer
   2064                   uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
   2065                   bytes into the uip_buf array.
   2066          
   2067                   If the application wishes to send any data, this data should be
   2068                   put into the uip_appdata and the length of the data should be
   2069                   put into uip_len. If the application don't have any data to
   2070                   send, uip_len must be set to 0. */
   2071                if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
   2072                  uip_slen = 0;
   2073                  UIP_APPCALL();
   2074          
   2075                appsend:
   2076                
   2077                  if(uip_flags & UIP_ABORT) {
   2078                    uip_slen = 0;
   2079                    uip_connr->tcpstateflags = UIP_CLOSED;
   2080                    UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
   2081                    goto tcp_send_nodata;
   2082                  }
   2083          
   2084                  if(uip_flags & UIP_CLOSE) {
   2085                    uip_slen = 0;
   2086                    uip_connr->len = 1;
   2087                    uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
   2088                    uip_connr->nrtx = 0;
   2089                    UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;
   2090                    goto tcp_send_nodata;
   2091                  }
   2092          
   2093                  /* If uip_slen > 0, the application has data to be sent. */
   2094                  if(uip_slen > 0) {
   2095          
   2096                    /* If the connection has acknowledged data, the contents of
   2097                       the ->len variable should be discarded. */
   2098                    if((uip_flags & UIP_ACKDATA) != 0) {
   2099                      uip_connr->len = 0;
   2100                    }
   2101          
   2102                    /* If the ->len variable is non-zero the connection has
   2103                       already data in transit and cannot send anymore right
   2104                       now. */
   2105                    if(uip_connr->len == 0) {
   2106          
   2107                      /* The application cannot send more than what is allowed by
   2108                         the mss (the minumum of the MSS and the available
   2109                         window). */
   2110                      if(uip_slen > uip_connr->mss) {
   2111                        uip_slen = uip_connr->mss;
   2112                      }
   2113          
   2114                      /* Remember how much data we send out now so that we know
   2115                         when everything has been acknowledged. */
   2116                      uip_connr->len = uip_slen;
   2117                    } else {
   2118          
   2119                      /* If the application already had unacknowledged data, we
   2120                         make sure that the application does not send (i.e.,
   2121                         retransmit) out more than it previously sent out. */
   2122                      uip_slen = uip_connr->len;
   2123                    }
   2124                  }
   2125                  uip_connr->nrtx = 0;
   2126                apprexmit:
   2127                  uip_appdata = uip_sappdata;
   2128                
   2129                  /* If the application has data to be sent, or if the incoming
   2130                     packet had new data in it, we must send out a packet. */
   2131                  if(uip_slen > 0 && uip_connr->len > 0) {
   2132                    /* Add the length of the IP and TCP headers. */
   2133                    uip_len = uip_connr->len + UIP_TCPIP_HLEN;
   2134                    /* We always set the ACK flag in response packets. */
   2135                    UIP_TCP_BUF->flags = TCP_ACK | TCP_PSH;
   2136                    /* Send the packet. */
   2137                    goto tcp_send_noopts;
   2138                  }
   2139                  /* If there is no data to send, just send out a pure ACK if
   2140                     there is newdata. */
   2141                  if(uip_flags & UIP_NEWDATA) {
   2142                    uip_len = UIP_TCPIP_HLEN;
   2143                    UIP_TCP_BUF->flags = TCP_ACK;
   2144                    goto tcp_send_noopts;
   2145                  }
   2146                }
   2147                goto drop;
   2148              case UIP_LAST_ACK:
   2149                /* We can close this connection if the peer has acknowledged our
   2150                   FIN. This is indicated by the UIP_ACKDATA flag. */
   2151                if(uip_flags & UIP_ACKDATA) {
   2152                  uip_connr->tcpstateflags = UIP_CLOSED;
   2153                  uip_flags = UIP_CLOSE;
   2154                  UIP_APPCALL();
   2155                }
   2156                break;
   2157              
   2158              case UIP_FIN_WAIT_1:
   2159                /* The application has closed the connection, but the remote host
   2160                   hasn't closed its end yet. Thus we do nothing but wait for a
   2161                   FIN from the other side. */
   2162                if(uip_len > 0) {
   2163                  uip_add_rcv_nxt(uip_len);
   2164                }
   2165                if(UIP_TCP_BUF->flags & TCP_FIN) {
   2166                  if(uip_flags & UIP_ACKDATA) {
   2167                    uip_connr->tcpstateflags = UIP_TIME_WAIT;
   2168                    uip_connr->timer = 0;
   2169                    uip_connr->len = 0;
   2170                  } else {
   2171                    uip_connr->tcpstateflags = UIP_CLOSING;
   2172                  }
   2173                  uip_add_rcv_nxt(1);
   2174                  uip_flags = UIP_CLOSE;
   2175                  UIP_APPCALL();
   2176                  goto tcp_send_ack;
   2177                } else if(uip_flags & UIP_ACKDATA) {
   2178                  uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
   2179                  uip_connr->len = 0;
   2180                  goto drop;
   2181                }
   2182                if(uip_len > 0) {
   2183                  goto tcp_send_ack;
   2184                }
   2185                goto drop;
   2186                
   2187              case UIP_FIN_WAIT_2:
   2188                if(uip_len > 0) {
   2189                  uip_add_rcv_nxt(uip_len);
   2190                }
   2191                if(UIP_TCP_BUF->flags & TCP_FIN) {
   2192                  uip_connr->tcpstateflags = UIP_TIME_WAIT;
   2193                  uip_connr->timer = 0;
   2194                  uip_add_rcv_nxt(1);
   2195                  uip_flags = UIP_CLOSE;
   2196                  UIP_APPCALL();
   2197                  goto tcp_send_ack;
   2198                }
   2199                if(uip_len > 0) {
   2200                  goto tcp_send_ack;
   2201                }
   2202                goto drop;
   2203          
   2204              case UIP_TIME_WAIT:
   2205                goto tcp_send_ack;
   2206              
   2207              case UIP_CLOSING:
   2208                if(uip_flags & UIP_ACKDATA) {
   2209                  uip_connr->tcpstateflags = UIP_TIME_WAIT;
   2210                  uip_connr->timer = 0;
   2211                }
   2212            }
   2213            goto drop;
   2214            
   2215            /* We jump here when we are ready to send the packet, and just want
   2216               to set the appropriate TCP sequence numbers in the TCP header. */
   2217           tcp_send_ack:
   2218            UIP_TCP_BUF->flags = TCP_ACK;
   2219          
   2220           tcp_send_nodata:
   2221            uip_len = UIP_IPTCPH_LEN;
   2222          
   2223           tcp_send_noopts:
   2224            UIP_TCP_BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
   2225          
   2226            /* We're done with the input processing. We are now ready to send a
   2227               reply. Our job is to fill in all the fields of the TCP and IP
   2228               headers before calculating the checksum and finally send the
   2229               packet. */
   2230           tcp_send:
   2231            PRINTF("In tcp_send\n");
   2232             
   2233            UIP_TCP_BUF->ackno[0] = uip_connr->rcv_nxt[0];
   2234            UIP_TCP_BUF->ackno[1] = uip_connr->rcv_nxt[1];
   2235            UIP_TCP_BUF->ackno[2] = uip_connr->rcv_nxt[2];
   2236            UIP_TCP_BUF->ackno[3] = uip_connr->rcv_nxt[3];
   2237            
   2238            UIP_TCP_BUF->seqno[0] = uip_connr->snd_nxt[0];
   2239            UIP_TCP_BUF->seqno[1] = uip_connr->snd_nxt[1];
   2240            UIP_TCP_BUF->seqno[2] = uip_connr->snd_nxt[2];
   2241            UIP_TCP_BUF->seqno[3] = uip_connr->snd_nxt[3];
   2242          
   2243            UIP_IP_BUF->proto = UIP_PROTO_TCP;
   2244          
   2245            UIP_TCP_BUF->srcport  = uip_connr->lport;
   2246            UIP_TCP_BUF->destport = uip_connr->rport;
   2247          
   2248            uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_connr->ripaddr);
   2249            uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
   2250            PRINTF("Sending TCP packet to ");
   2251            PRINT6ADDR(&UIP_IP_BUF->destipaddr);
   2252            PRINTF(" from ");
   2253            PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
   2254            PRINTF("\n");
   2255          
   2256            if(uip_connr->tcpstateflags & UIP_STOPPED) {
   2257              /* If the connection has issued uip_stop(), we advertise a zero
   2258                 window so that the remote host will stop sending data. */
   2259              UIP_TCP_BUF->wnd[0] = UIP_TCP_BUF->wnd[1] = 0;
   2260            } else {
   2261              UIP_TCP_BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
   2262              UIP_TCP_BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
   2263            }
   2264          
   2265           tcp_send_noconn:
   2266            UIP_IP_BUF->ttl = uip_ds6_if.cur_hop_limit;
   2267            UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
   2268            UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
   2269          
   2270            UIP_TCP_BUF->urgp[0] = UIP_TCP_BUF->urgp[1] = 0;
   2271            
   2272            /* Calculate TCP checksum. */
   2273            UIP_TCP_BUF->tcpchksum = 0;
   2274            UIP_TCP_BUF->tcpchksum = ~(uip_tcpchksum());
   2275            UIP_STAT(++uip_stat.tcp.sent);
   2276          
   2277          #endif /* UIP_TCP */
   2278          #if UIP_UDP
   2279           ip_send_nolen:
   2280          #endif
   2281            UIP_IP_BUF->vtc = 0x60;
   2282            UIP_IP_BUF->tcflow = 0x00;
   2283            UIP_IP_BUF->flow = 0x00;
   2284           send:
   2285            PRINTF("Sending packet with length %d (%d)\n", uip_len,
   2286                   (UIP_IP_BUF->len[0] << 8) | UIP_IP_BUF->len[1]);
   2287            
   2288            UIP_STAT(++uip_stat.ip.sent);
   2289            /* Return and let the caller do the actual transmission. */
   2290            uip_flags = 0;
   2291            return;
   2292          
   2293           drop:
   2294            uip_len = 0;
   \                     ??uip_process_3:
   \   000091   90....       MOV     DPTR,#uip_len
   \   000094   7400         MOV     A,#0x0
   \   000096   F0           MOVX    @DPTR,A
   \   000097   A3           INC     DPTR
   \   000098   7400         MOV     A,#0x0
   \   00009A   F0           MOVX    @DPTR,A
   2295            uip_ext_len = 0;
   \   00009B   90....       MOV     DPTR,#uip_ext_len
   \   00009E   7400         MOV     A,#0x0
   \   0000A0   F0           MOVX    @DPTR,A
   2296            uip_ext_bitmap = 0;
   \   0000A1   90....       MOV     DPTR,#uip_ext_bitmap
   \   0000A4   7400         MOV     A,#0x0
   \   0000A6   F0           MOVX    @DPTR,A
   2297            uip_flags = 0;
   \   0000A7   90....       MOV     DPTR,#uip_flags
   \   0000AA   7400         MOV     A,#0x0
   \   0000AC   F0           MOVX    @DPTR,A
   2298            return;
   \                     ??uip_process_5:
   \   0000AD   7F04         MOV     R7,#0x4
   \   0000AF   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??uip_process_4:
   \   0000B2   90....       MOV     DPTR,#uip_aligned_buf
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   54F0         ANL     A,#0xf0
   \   0000B8   6460         XRL     A,#0x60
   \   0000BA   70D5         JNZ     ??uip_process_3
   \   0000BC   90....       MOV     DPTR,#uip_len
   \   0000BF   C082         PUSH    DPL
   \   0000C1   C083         PUSH    DPH
   \   0000C3   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F8           MOV     R0,A
   \   0000C8   7900         MOV     R1,#0x0
   \   0000CA   E4           CLR     A
   \   0000CB   C8           XCH     A,R0
   \   0000CC   F9           MOV     R1,A
   \   0000CD   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   FA           MOV     R2,A
   \   0000D2   7B00         MOV     R3,#0x0
   \   0000D4   E8           MOV     A,R0
   \   0000D5   2A           ADD     A,R2
   \   0000D6   F8           MOV     R0,A
   \   0000D7   E9           MOV     A,R1
   \   0000D8   3B           ADDC    A,R3
   \   0000D9   F9           MOV     R1,A
   \   0000DA   D083         POP     DPH
   \   0000DC   D082         POP     DPL
   \   0000DE   C3           CLR     C
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   98           SUBB    A,R0
   \   0000E1   A3           INC     DPTR
   \   0000E2   E0           MOVX    A,@DPTR
   \   0000E3   99           SUBB    A,R1
   \   0000E4   40AB         JC      ??uip_process_3
   \   0000E6   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   F8           MOV     R0,A
   \   0000EB   7900         MOV     R1,#0x0
   \   0000ED   E4           CLR     A
   \   0000EE   C8           XCH     A,R0
   \   0000EF   F9           MOV     R1,A
   \   0000F0   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FA           MOV     R2,A
   \   0000F5   7B00         MOV     R3,#0x0
   \   0000F7   E8           MOV     A,R0
   \   0000F8   2A           ADD     A,R2
   \   0000F9   F8           MOV     R0,A
   \   0000FA   E9           MOV     A,R1
   \   0000FB   3B           ADDC    A,R3
   \   0000FC   F9           MOV     R1,A
   \   0000FD   E8           MOV     A,R0
   \   0000FE   2428         ADD     A,#0x28
   \   000100   F8           MOV     R0,A
   \   000101   E9           MOV     A,R1
   \   000102   3400         ADDC    A,#0x0
   \   000104   F9           MOV     R1,A
   \   000105   90....       MOV     DPTR,#uip_len
   \   000108   E8           MOV     A,R0
   \   000109   F0           MOVX    @DPTR,A
   \   00010A   A3           INC     DPTR
   \   00010B   E9           MOV     A,R1
   \   00010C   F0           MOVX    @DPTR,A
   \   00010D   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   000110   E0           MOVX    A,@DPTR
   \   000111   64FF         XRL     A,#0xff
   \   000113   7003         JNZ     $+5
   \   000115   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   000118   90....       MOV     DPTR,#uip_next_hdr
   \   00011B   74..         MOV     A,#(uip_aligned_buf + 6) & 0xff
   \   00011D   F0           MOVX    @DPTR,A
   \   00011E   A3           INC     DPTR
   \   00011F   74..         MOV     A,#((uip_aligned_buf + 6) >> 8) & 0xff
   \   000121   F0           MOVX    @DPTR,A
   \   000122   90....       MOV     DPTR,#uip_ext_len
   \   000125   7400         MOV     A,#0x0
   \   000127   F0           MOVX    @DPTR,A
   \   000128   90....       MOV     DPTR,#uip_ext_bitmap
   \   00012B   7400         MOV     A,#0x0
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   90....       MOV     DPTR,#uip_next_hdr
   \   000131   E0           MOVX    A,@DPTR
   \   000132   F8           MOV     R0,A
   \   000133   A3           INC     DPTR
   \   000134   E0           MOVX    A,@DPTR
   \   000135   F583         MOV     DPH,A
   \   000137   8882         MOV     DPL,R0
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   7062         JNZ     ??uip_process_6
   \   00013C   90....       MOV     DPTR,#uip_ext_bitmap
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   D2E0         SETB    0xE0 /* A   */.0
   \   000142   F0           MOVX    @DPTR,A
   \   000143                ; Setup parameters for call to function ext_hdr_options_process
   \   000143   12....       LCALL   ??ext_hdr_options_process?relay
   \   000146   E9           MOV     A,R1
   \   000147   600E         JZ      ??uip_process_7
   \   000149   14           DEC     A
   \   00014A   7003         JNZ     $+5
   \   00014C   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   00014F   14           DEC     A
   \   000150   7003         JNZ     $+5
   \   000152   02....       LJMP    ??uip_process_8 & 0xFFFF
   \   000155   8047         SJMP    ??uip_process_6
   \                     ??uip_process_7:
   \   000157   90....       MOV     DPTR,#uip_ext_len
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F8           MOV     R0,A
   \   00015C   7900         MOV     R1,#0x0
   \   00015E   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000160   28           ADD     A,R0
   \   000161   F8           MOV     R0,A
   \   000162   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000164   39           ADDC    A,R1
   \   000165   F9           MOV     R1,A
   \   000166   E8           MOV     A,R0
   \   000167   2428         ADD     A,#0x28
   \   000169   F8           MOV     R0,A
   \   00016A   E9           MOV     A,R1
   \   00016B   3400         ADDC    A,#0x0
   \   00016D   F9           MOV     R1,A
   \   00016E   90....       MOV     DPTR,#uip_next_hdr
   \   000171   E8           MOV     A,R0
   \   000172   F0           MOVX    @DPTR,A
   \   000173   A3           INC     DPTR
   \   000174   E9           MOV     A,R1
   \   000175   F0           MOVX    @DPTR,A
   \   000176   90....       MOV     DPTR,#uip_ext_len
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   F8           MOV     R0,A
   \   00017B   7900         MOV     R1,#0x0
   \   00017D   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00017F   28           ADD     A,R0
   \   000180   F8           MOV     R0,A
   \   000181   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000183   39           ADDC    A,R1
   \   000184   F9           MOV     R1,A
   \   000185   E8           MOV     A,R0
   \   000186   2429         ADD     A,#0x29
   \   000188   F582         MOV     DPL,A
   \   00018A   E9           MOV     A,R1
   \   00018B   3400         ADDC    A,#0x0
   \   00018D   F583         MOV     DPH,A
   \   00018F   E0           MOVX    A,@DPTR
   \   000190   33           RLC     A
   \   000191   33           RLC     A
   \   000192   33           RLC     A
   \   000193   54F8         ANL     A,#0xf8
   \   000195   2408         ADD     A,#0x8
   \   000197   F8           MOV     R0,A
   \   000198   90....       MOV     DPTR,#uip_ext_len
   \   00019B   E0           MOVX    A,@DPTR
   \   00019C   28           ADD     A,R0
   \   00019D   F0           MOVX    @DPTR,A
   \                     ??uip_process_6:
   \   00019E                ; Setup parameters for call to function uip_ds6_addr_lookup
   \   00019E   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0001A0   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0001A2   12....       LCALL   ??uip_ds6_addr_lookup?relay
   \   0001A5   8A..         MOV     ?V0 + 0,R2
   \   0001A7   8B..         MOV     ?V0 + 1,R3
   \   0001A9   E5..         MOV     A,?V0 + 0
   \   0001AB   45..         ORL     A,?V0 + 1
   \   0001AD   6003         JZ      $+5
   \   0001AF   02....       LJMP    ??uip_process_9 & 0xFFFF
   \   0001B2                ; Setup parameters for call to function uip_ds6_maddr_lookup
   \   0001B2   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0001B4   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0001B6   12....       LCALL   ??uip_ds6_maddr_lookup?relay
   \   0001B9   8A..         MOV     ?V0 + 0,R2
   \   0001BB   8B..         MOV     ?V0 + 1,R3
   \   0001BD   E5..         MOV     A,?V0 + 0
   \   0001BF   45..         ORL     A,?V0 + 1
   \   0001C1   6003         JZ      $+5
   \   0001C3   02....       LJMP    ??uip_process_9 & 0xFFFF
   \   0001C6   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   0001C9   E0           MOVX    A,@DPTR
   \   0001CA   64FF         XRL     A,#0xff
   \   0001CC   7003         JNZ     $+5
   \   0001CE   02....       LJMP    ??uip_process_10 & 0xFFFF
   \   0001D1   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   0001D4   E0           MOVX    A,@DPTR
   \   0001D5   64FE         XRL     A,#0xfe
   \   0001D7   700B         JNZ     ??uip_process_11
   \   0001D9   90....       MOV     DPTR,#uip_aligned_buf + 25
   \   0001DC   E0           MOVX    A,@DPTR
   \   0001DD   6480         XRL     A,#0x80
   \   0001DF   7003         JNZ     $+5
   \   0001E1   02....       LJMP    ??uip_process_10 & 0xFFFF
   \                     ??uip_process_11:
   \   0001E4   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   0001E7   E0           MOVX    A,@DPTR
   \   0001E8   64FE         XRL     A,#0xfe
   \   0001EA   700B         JNZ     ??uip_process_12
   \   0001EC   90....       MOV     DPTR,#uip_aligned_buf + 9
   \   0001EF   E0           MOVX    A,@DPTR
   \   0001F0   6480         XRL     A,#0x80
   \   0001F2   7003         JNZ     $+5
   \   0001F4   02....       LJMP    ??uip_process_10 & 0xFFFF
   \                     ??uip_process_12:
   \   0001F7   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   0001FA   E0           MOVX    A,@DPTR
   \   0001FB   F8           MOV     R0,A
   \   0001FC   A3           INC     DPTR
   \   0001FD   E0           MOVX    A,@DPTR
   \   0001FE   F9           MOV     R1,A
   \   0001FF   E8           MOV     A,R0
   \   000200   49           ORL     A,R1
   \   000201   7057         JNZ     ??uip_process_13
   \   000203   90....       MOV     DPTR,#uip_aligned_buf + 10
   \   000206   E0           MOVX    A,@DPTR
   \   000207   F8           MOV     R0,A
   \   000208   A3           INC     DPTR
   \   000209   E0           MOVX    A,@DPTR
   \   00020A   F9           MOV     R1,A
   \   00020B   E8           MOV     A,R0
   \   00020C   49           ORL     A,R1
   \   00020D   704B         JNZ     ??uip_process_13
   \   00020F   90....       MOV     DPTR,#uip_aligned_buf + 12
   \   000212   E0           MOVX    A,@DPTR
   \   000213   F8           MOV     R0,A
   \   000214   A3           INC     DPTR
   \   000215   E0           MOVX    A,@DPTR
   \   000216   F9           MOV     R1,A
   \   000217   E8           MOV     A,R0
   \   000218   49           ORL     A,R1
   \   000219   703F         JNZ     ??uip_process_13
   \   00021B   90....       MOV     DPTR,#uip_aligned_buf + 14
   \   00021E   E0           MOVX    A,@DPTR
   \   00021F   F8           MOV     R0,A
   \   000220   A3           INC     DPTR
   \   000221   E0           MOVX    A,@DPTR
   \   000222   F9           MOV     R1,A
   \   000223   E8           MOV     A,R0
   \   000224   49           ORL     A,R1
   \   000225   7033         JNZ     ??uip_process_13
   \   000227   90....       MOV     DPTR,#uip_aligned_buf + 16
   \   00022A   E0           MOVX    A,@DPTR
   \   00022B   F8           MOV     R0,A
   \   00022C   A3           INC     DPTR
   \   00022D   E0           MOVX    A,@DPTR
   \   00022E   F9           MOV     R1,A
   \   00022F   E8           MOV     A,R0
   \   000230   49           ORL     A,R1
   \   000231   7027         JNZ     ??uip_process_13
   \   000233   90....       MOV     DPTR,#uip_aligned_buf + 18
   \   000236   E0           MOVX    A,@DPTR
   \   000237   F8           MOV     R0,A
   \   000238   A3           INC     DPTR
   \   000239   E0           MOVX    A,@DPTR
   \   00023A   F9           MOV     R1,A
   \   00023B   E8           MOV     A,R0
   \   00023C   49           ORL     A,R1
   \   00023D   701B         JNZ     ??uip_process_13
   \   00023F   90....       MOV     DPTR,#uip_aligned_buf + 20
   \   000242   E0           MOVX    A,@DPTR
   \   000243   F8           MOV     R0,A
   \   000244   A3           INC     DPTR
   \   000245   E0           MOVX    A,@DPTR
   \   000246   F9           MOV     R1,A
   \   000247   E8           MOV     A,R0
   \   000248   49           ORL     A,R1
   \   000249   700F         JNZ     ??uip_process_13
   \   00024B   90....       MOV     DPTR,#uip_aligned_buf + 22
   \   00024E   E0           MOVX    A,@DPTR
   \   00024F   F8           MOV     R0,A
   \   000250   A3           INC     DPTR
   \   000251   E0           MOVX    A,@DPTR
   \   000252   F9           MOV     R1,A
   \   000253   E8           MOV     A,R0
   \   000254   49           ORL     A,R1
   \   000255   7003         JNZ     $+5
   \   000257   02....       LJMP    ??uip_process_10 & 0xFFFF
   \                     ??uip_process_13:
   \   00025A   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   00025D   E0           MOVX    A,@DPTR
   \   00025E   F8           MOV     R0,A
   \   00025F   A3           INC     DPTR
   \   000260   E0           MOVX    A,@DPTR
   \   000261   F9           MOV     R1,A
   \   000262   E8           MOV     A,R0
   \   000263   49           ORL     A,R1
   \   000264   7056         JNZ     ??uip_process_14
   \   000266   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   000269   E0           MOVX    A,@DPTR
   \   00026A   F8           MOV     R0,A
   \   00026B   A3           INC     DPTR
   \   00026C   E0           MOVX    A,@DPTR
   \   00026D   F9           MOV     R1,A
   \   00026E   E8           MOV     A,R0
   \   00026F   49           ORL     A,R1
   \   000270   704A         JNZ     ??uip_process_14
   \   000272   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   000275   E0           MOVX    A,@DPTR
   \   000276   F8           MOV     R0,A
   \   000277   A3           INC     DPTR
   \   000278   E0           MOVX    A,@DPTR
   \   000279   F9           MOV     R1,A
   \   00027A   E8           MOV     A,R0
   \   00027B   49           ORL     A,R1
   \   00027C   703E         JNZ     ??uip_process_14
   \   00027E   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   000281   E0           MOVX    A,@DPTR
   \   000282   F8           MOV     R0,A
   \   000283   A3           INC     DPTR
   \   000284   E0           MOVX    A,@DPTR
   \   000285   F9           MOV     R1,A
   \   000286   E8           MOV     A,R0
   \   000287   49           ORL     A,R1
   \   000288   7032         JNZ     ??uip_process_14
   \   00028A   90....       MOV     DPTR,#uip_aligned_buf + 32
   \   00028D   E0           MOVX    A,@DPTR
   \   00028E   F8           MOV     R0,A
   \   00028F   A3           INC     DPTR
   \   000290   E0           MOVX    A,@DPTR
   \   000291   F9           MOV     R1,A
   \   000292   E8           MOV     A,R0
   \   000293   49           ORL     A,R1
   \   000294   7026         JNZ     ??uip_process_14
   \   000296   90....       MOV     DPTR,#uip_aligned_buf + 34
   \   000299   E0           MOVX    A,@DPTR
   \   00029A   F8           MOV     R0,A
   \   00029B   A3           INC     DPTR
   \   00029C   E0           MOVX    A,@DPTR
   \   00029D   F9           MOV     R1,A
   \   00029E   E8           MOV     A,R0
   \   00029F   49           ORL     A,R1
   \   0002A0   701A         JNZ     ??uip_process_14
   \   0002A2   90....       MOV     DPTR,#uip_aligned_buf + 36
   \   0002A5   E0           MOVX    A,@DPTR
   \   0002A6   F8           MOV     R0,A
   \   0002A7   A3           INC     DPTR
   \   0002A8   E0           MOVX    A,@DPTR
   \   0002A9   F9           MOV     R1,A
   \   0002AA   E8           MOV     A,R0
   \   0002AB   49           ORL     A,R1
   \   0002AC   700E         JNZ     ??uip_process_14
   \   0002AE   90....       MOV     DPTR,#uip_aligned_buf + 38
   \   0002B1   E0           MOVX    A,@DPTR
   \   0002B2   7008         JNZ     ??uip_process_14
   \   0002B4   90....       MOV     DPTR,#uip_aligned_buf + 39
   \   0002B7   E0           MOVX    A,@DPTR
   \   0002B8   6401         XRL     A,#0x1
   \   0002BA   604A         JZ      ??uip_process_10
   \                     ??uip_process_14:
   \   0002BC   90....       MOV     DPTR,#uip_len
   \   0002BF   C3           CLR     C
   \   0002C0   E0           MOVX    A,@DPTR
   \   0002C1   9401         SUBB    A,#0x1
   \   0002C3   A3           INC     DPTR
   \   0002C4   E0           MOVX    A,@DPTR
   \   0002C5   9405         SUBB    A,#0x5
   \   0002C7   4015         JC      ??uip_process_15
   \   0002C9                ; Setup parameters for call to function uip_icmp6_error_output
   \   0002C9   90....       MOV     DPTR,#__Constant_500
   \   0002CC   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0002CF   7A00         MOV     R2,#0x0
   \   0002D1   7902         MOV     R1,#0x2
   \   0002D3   12....       LCALL   ??uip_icmp6_error_output?relay
   \   0002D6   7404         MOV     A,#0x4
   \   0002D8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002DB   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_15:
   \   0002DE   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   0002E1   E0           MOVX    A,@DPTR
   \   0002E2   C3           CLR     C
   \   0002E3   9402         SUBB    A,#0x2
   \   0002E5   5015         JNC     ??uip_process_16
   \   0002E7                ; Setup parameters for call to function uip_icmp6_error_output
   \   0002E7   90....       MOV     DPTR,#__Constant_0
   \   0002EA   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0002ED   7A00         MOV     R2,#0x0
   \   0002EF   7903         MOV     R1,#0x3
   \   0002F1   12....       LCALL   ??uip_icmp6_error_output?relay
   \   0002F4   7404         MOV     A,#0x4
   \   0002F6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002F9   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_16:
   \   0002FC   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   0002FF   E0           MOVX    A,@DPTR
   \   000300   24FF         ADD     A,#-0x1
   \   000302   F0           MOVX    @DPTR,A
   \   000303   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_10:
   \   000306   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   000309   E0           MOVX    A,@DPTR
   \   00030A   64FE         XRL     A,#0xfe
   \   00030C   6003         JZ      $+5
   \   00030E   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   000311   90....       MOV     DPTR,#uip_aligned_buf + 9
   \   000314   E0           MOVX    A,@DPTR
   \   000315   6480         XRL     A,#0x80
   \   000317   6003         JZ      $+5
   \   000319   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   00031C   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   00031F   E0           MOVX    A,@DPTR
   \   000320   F8           MOV     R0,A
   \   000321   A3           INC     DPTR
   \   000322   E0           MOVX    A,@DPTR
   \   000323   F9           MOV     R1,A
   \   000324   E8           MOV     A,R0
   \   000325   49           ORL     A,R1
   \   000326   7057         JNZ     ??uip_process_17
   \   000328   90....       MOV     DPTR,#uip_aligned_buf + 10
   \   00032B   E0           MOVX    A,@DPTR
   \   00032C   F8           MOV     R0,A
   \   00032D   A3           INC     DPTR
   \   00032E   E0           MOVX    A,@DPTR
   \   00032F   F9           MOV     R1,A
   \   000330   E8           MOV     A,R0
   \   000331   49           ORL     A,R1
   \   000332   704B         JNZ     ??uip_process_17
   \   000334   90....       MOV     DPTR,#uip_aligned_buf + 12
   \   000337   E0           MOVX    A,@DPTR
   \   000338   F8           MOV     R0,A
   \   000339   A3           INC     DPTR
   \   00033A   E0           MOVX    A,@DPTR
   \   00033B   F9           MOV     R1,A
   \   00033C   E8           MOV     A,R0
   \   00033D   49           ORL     A,R1
   \   00033E   703F         JNZ     ??uip_process_17
   \   000340   90....       MOV     DPTR,#uip_aligned_buf + 14
   \   000343   E0           MOVX    A,@DPTR
   \   000344   F8           MOV     R0,A
   \   000345   A3           INC     DPTR
   \   000346   E0           MOVX    A,@DPTR
   \   000347   F9           MOV     R1,A
   \   000348   E8           MOV     A,R0
   \   000349   49           ORL     A,R1
   \   00034A   7033         JNZ     ??uip_process_17
   \   00034C   90....       MOV     DPTR,#uip_aligned_buf + 16
   \   00034F   E0           MOVX    A,@DPTR
   \   000350   F8           MOV     R0,A
   \   000351   A3           INC     DPTR
   \   000352   E0           MOVX    A,@DPTR
   \   000353   F9           MOV     R1,A
   \   000354   E8           MOV     A,R0
   \   000355   49           ORL     A,R1
   \   000356   7027         JNZ     ??uip_process_17
   \   000358   90....       MOV     DPTR,#uip_aligned_buf + 18
   \   00035B   E0           MOVX    A,@DPTR
   \   00035C   F8           MOV     R0,A
   \   00035D   A3           INC     DPTR
   \   00035E   E0           MOVX    A,@DPTR
   \   00035F   F9           MOV     R1,A
   \   000360   E8           MOV     A,R0
   \   000361   49           ORL     A,R1
   \   000362   701B         JNZ     ??uip_process_17
   \   000364   90....       MOV     DPTR,#uip_aligned_buf + 20
   \   000367   E0           MOVX    A,@DPTR
   \   000368   F8           MOV     R0,A
   \   000369   A3           INC     DPTR
   \   00036A   E0           MOVX    A,@DPTR
   \   00036B   F9           MOV     R1,A
   \   00036C   E8           MOV     A,R0
   \   00036D   49           ORL     A,R1
   \   00036E   700F         JNZ     ??uip_process_17
   \   000370   90....       MOV     DPTR,#uip_aligned_buf + 22
   \   000373   E0           MOVX    A,@DPTR
   \   000374   F8           MOV     R0,A
   \   000375   A3           INC     DPTR
   \   000376   E0           MOVX    A,@DPTR
   \   000377   F9           MOV     R1,A
   \   000378   E8           MOV     A,R0
   \   000379   49           ORL     A,R1
   \   00037A   7003         JNZ     $+5
   \   00037C   02....       LJMP    ??uip_process_3 & 0xFFFF
   \                     ??uip_process_17:
   \   00037F   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   000382   E0           MOVX    A,@DPTR
   \   000383   F8           MOV     R0,A
   \   000384   A3           INC     DPTR
   \   000385   E0           MOVX    A,@DPTR
   \   000386   F9           MOV     R1,A
   \   000387   E8           MOV     A,R0
   \   000388   49           ORL     A,R1
   \   000389   7056         JNZ     ??uip_process_18
   \   00038B   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   00038E   E0           MOVX    A,@DPTR
   \   00038F   F8           MOV     R0,A
   \   000390   A3           INC     DPTR
   \   000391   E0           MOVX    A,@DPTR
   \   000392   F9           MOV     R1,A
   \   000393   E8           MOV     A,R0
   \   000394   49           ORL     A,R1
   \   000395   704A         JNZ     ??uip_process_18
   \   000397   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   00039A   E0           MOVX    A,@DPTR
   \   00039B   F8           MOV     R0,A
   \   00039C   A3           INC     DPTR
   \   00039D   E0           MOVX    A,@DPTR
   \   00039E   F9           MOV     R1,A
   \   00039F   E8           MOV     A,R0
   \   0003A0   49           ORL     A,R1
   \   0003A1   703E         JNZ     ??uip_process_18
   \   0003A3   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   0003A6   E0           MOVX    A,@DPTR
   \   0003A7   F8           MOV     R0,A
   \   0003A8   A3           INC     DPTR
   \   0003A9   E0           MOVX    A,@DPTR
   \   0003AA   F9           MOV     R1,A
   \   0003AB   E8           MOV     A,R0
   \   0003AC   49           ORL     A,R1
   \   0003AD   7032         JNZ     ??uip_process_18
   \   0003AF   90....       MOV     DPTR,#uip_aligned_buf + 32
   \   0003B2   E0           MOVX    A,@DPTR
   \   0003B3   F8           MOV     R0,A
   \   0003B4   A3           INC     DPTR
   \   0003B5   E0           MOVX    A,@DPTR
   \   0003B6   F9           MOV     R1,A
   \   0003B7   E8           MOV     A,R0
   \   0003B8   49           ORL     A,R1
   \   0003B9   7026         JNZ     ??uip_process_18
   \   0003BB   90....       MOV     DPTR,#uip_aligned_buf + 34
   \   0003BE   E0           MOVX    A,@DPTR
   \   0003BF   F8           MOV     R0,A
   \   0003C0   A3           INC     DPTR
   \   0003C1   E0           MOVX    A,@DPTR
   \   0003C2   F9           MOV     R1,A
   \   0003C3   E8           MOV     A,R0
   \   0003C4   49           ORL     A,R1
   \   0003C5   701A         JNZ     ??uip_process_18
   \   0003C7   90....       MOV     DPTR,#uip_aligned_buf + 36
   \   0003CA   E0           MOVX    A,@DPTR
   \   0003CB   F8           MOV     R0,A
   \   0003CC   A3           INC     DPTR
   \   0003CD   E0           MOVX    A,@DPTR
   \   0003CE   F9           MOV     R1,A
   \   0003CF   E8           MOV     A,R0
   \   0003D0   49           ORL     A,R1
   \   0003D1   700E         JNZ     ??uip_process_18
   \   0003D3   90....       MOV     DPTR,#uip_aligned_buf + 38
   \   0003D6   E0           MOVX    A,@DPTR
   \   0003D7   7008         JNZ     ??uip_process_18
   \   0003D9   90....       MOV     DPTR,#uip_aligned_buf + 39
   \   0003DC   E0           MOVX    A,@DPTR
   \   0003DD   6401         XRL     A,#0x1
   \   0003DF   6027         JZ      ??uip_process_19
   \                     ??uip_process_18:
   \   0003E1   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   0003E4   E0           MOVX    A,@DPTR
   \   0003E5   64FF         XRL     A,#0xff
   \   0003E7   601F         JZ      ??uip_process_19
   \   0003E9                ; Setup parameters for call to function uip_ds6_is_addr_onlink
   \   0003E9   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0003EB   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0003ED   12....       LCALL   ??uip_ds6_is_addr_onlink?relay
   \   0003F0   E9           MOV     A,R1
   \   0003F1   7015         JNZ     ??uip_process_19
   \   0003F3                ; Setup parameters for call to function uip_icmp6_error_output
   \   0003F3   90....       MOV     DPTR,#__Constant_0
   \   0003F6   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0003F9   7A02         MOV     R2,#0x2
   \   0003FB   7901         MOV     R1,#0x1
   \   0003FD   12....       LCALL   ??uip_icmp6_error_output?relay
   \   000400   7404         MOV     A,#0x4
   \   000402   12....       LCALL   ?DEALLOC_XSTACK8
   \   000405   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_19:
   \   000408   02....       LJMP    ??uip_process_3 & 0xFFFF
   \                     ??uip_process_20:
   \   00040B                ; Setup parameters for call to function uip_icmp6chksum
   \   00040B   12....       LCALL   ??uip_icmp6chksum?relay
   \   00040E   8A..         MOV     ?V0 + 0,R2
   \   000410   8B..         MOV     ?V0 + 1,R3
   \   000412   74FF         MOV     A,#-0x1
   \   000414   65..         XRL     A,?V0 + 0
   \   000416   7004         JNZ     ??uip_process_21
   \   000418   74FF         MOV     A,#-0x1
   \   00041A   65..         XRL     A,?V0 + 1
   \                     ??uip_process_21:
   \   00041C   6003         JZ      $+5
   \   00041E   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   000421   90....       MOV     DPTR,#uip_ext_len
   \   000424   E0           MOVX    A,@DPTR
   \   000425   F8           MOV     R0,A
   \   000426   7900         MOV     R1,#0x0
   \   000428   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   00042A   28           ADD     A,R0
   \   00042B   F582         MOV     DPL,A
   \   00042D   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   00042F   39           ADDC    A,R1
   \   000430   F583         MOV     DPH,A
   \   000432   E0           MOVX    A,@DPTR
   \   000433   2480         ADD     A,#-0x80
   \   000435   7003         JNZ     $+5
   \   000437   02....       LJMP    ??uip_process_22 & 0xFFFF
   \   00043A   14           DEC     A
   \   00043B   7003         JNZ     $+5
   \   00043D   02....       LJMP    ??uip_process_23 & 0xFFFF
   \   000440   24FC         ADD     A,#-0x4
   \   000442   7003         JNZ     $+5
   \   000444   02....       LJMP    ??uip_process_24 & 0xFFFF
   \   000447   14           DEC     A
   \   000448   7003         JNZ     $+5
   \   00044A   02....       LJMP    ??uip_process_25 & 0xFFFF
   \   00044D   14           DEC     A
   \   00044E   6009         JZ      ??uip_process_26
   \   000450   14           DEC     A
   \   000451   7003         JNZ     $+5
   \   000453   02....       LJMP    ??uip_process_27 & 0xFFFF
   \   000456   02....       LJMP    ??uip_process_28 & 0xFFFF
   \                     ??uip_process_26:
   \   000459                ; Setup parameters for call to function uip_nd6_ns_input
   \   000459   12....       LCALL   ??uip_nd6_ns_input?relay
   \   00045C   02....       LJMP    ??uip_process_29 & 0xFFFF
   \                     ??uip_process_30:
   \   00045F   90....       MOV     DPTR,#uip_ext_bitmap
   \   000462   E0           MOVX    A,@DPTR
   \   000463   A2E0         MOV     C,0xE0 /* A   */.0
   \   000465   5003         JNC     $+5
   \   000467   02....       LJMP    ??uip_process_31 & 0xFFFF
   \   00046A   90....       MOV     DPTR,#uip_ext_bitmap
   \   00046D   E0           MOVX    A,@DPTR
   \   00046E   D2E0         SETB    0xE0 /* A   */.0
   \   000470   F0           MOVX    @DPTR,A
   \   000471                ; Setup parameters for call to function ext_hdr_options_process
   \   000471   12....       LCALL   ??ext_hdr_options_process?relay
   \   000474   E9           MOV     A,R1
   \   000475   600E         JZ      ??uip_process_32
   \   000477   14           DEC     A
   \   000478   7003         JNZ     $+5
   \   00047A   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   00047D   14           DEC     A
   \   00047E   7003         JNZ     $+5
   \   000480   02....       LJMP    ??uip_process_8 & 0xFFFF
   \   000483   8047         SJMP    ??uip_process_9
   \                     ??uip_process_32:
   \   000485   90....       MOV     DPTR,#uip_ext_len
   \   000488   E0           MOVX    A,@DPTR
   \   000489   F8           MOV     R0,A
   \   00048A   7900         MOV     R1,#0x0
   \   00048C   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00048E   28           ADD     A,R0
   \   00048F   F8           MOV     R0,A
   \   000490   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000492   39           ADDC    A,R1
   \   000493   F9           MOV     R1,A
   \   000494   E8           MOV     A,R0
   \   000495   2428         ADD     A,#0x28
   \   000497   F8           MOV     R0,A
   \   000498   E9           MOV     A,R1
   \   000499   3400         ADDC    A,#0x0
   \   00049B   F9           MOV     R1,A
   \   00049C   90....       MOV     DPTR,#uip_next_hdr
   \   00049F   E8           MOV     A,R0
   \   0004A0   F0           MOVX    @DPTR,A
   \   0004A1   A3           INC     DPTR
   \   0004A2   E9           MOV     A,R1
   \   0004A3   F0           MOVX    @DPTR,A
   \   0004A4   90....       MOV     DPTR,#uip_ext_len
   \   0004A7   E0           MOVX    A,@DPTR
   \   0004A8   F8           MOV     R0,A
   \   0004A9   7900         MOV     R1,#0x0
   \   0004AB   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0004AD   28           ADD     A,R0
   \   0004AE   F8           MOV     R0,A
   \   0004AF   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0004B1   39           ADDC    A,R1
   \   0004B2   F9           MOV     R1,A
   \   0004B3   E8           MOV     A,R0
   \   0004B4   2429         ADD     A,#0x29
   \   0004B6   F582         MOV     DPL,A
   \   0004B8   E9           MOV     A,R1
   \   0004B9   3400         ADDC    A,#0x0
   \   0004BB   F583         MOV     DPH,A
   \   0004BD   E0           MOVX    A,@DPTR
   \   0004BE   33           RLC     A
   \   0004BF   33           RLC     A
   \   0004C0   33           RLC     A
   \   0004C1   54F8         ANL     A,#0xf8
   \   0004C3   2408         ADD     A,#0x8
   \   0004C5   F8           MOV     R0,A
   \   0004C6   90....       MOV     DPTR,#uip_ext_len
   \   0004C9   E0           MOVX    A,@DPTR
   \   0004CA   28           ADD     A,R0
   \   0004CB   F0           MOVX    @DPTR,A
   \                     ??uip_process_9:
   \   0004CC   90....       MOV     DPTR,#uip_next_hdr
   \   0004CF   E0           MOVX    A,@DPTR
   \   0004D0   F8           MOV     R0,A
   \   0004D1   A3           INC     DPTR
   \   0004D2   E0           MOVX    A,@DPTR
   \   0004D3   F583         MOV     DPH,A
   \   0004D5   8882         MOV     DPL,R0
   \   0004D7   E0           MOVX    A,@DPTR
   \   0004D8   6085         JZ      ??uip_process_30
   \   0004DA   24EF         ADD     A,#-0x11
   \   0004DC   6020         JZ      ??uip_process_33
   \   0004DE   24E6         ADD     A,#-0x1a
   \   0004E0   7003         JNZ     $+5
   \   0004E2   02....       LJMP    ??uip_process_34 & 0xFFFF
   \   0004E5   14           DEC     A
   \   0004E6   7003         JNZ     $+5
   \   0004E8   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   0004EB   24F2         ADD     A,#-0xe
   \   0004ED   7003         JNZ     $+5
   \   0004EF   02....       LJMP    ??uip_process_20 & 0xFFFF
   \   0004F2   14           DEC     A
   \   0004F3   7003         JNZ     $+5
   \   0004F5   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   0004F8   14           DEC     A
   \   0004F9   603D         JZ      ??uip_process_35
   \   0004FB   02....       LJMP    ??uip_process_31 & 0xFFFF
   \                     ??uip_process_33:
   \   0004FE                ; Setup parameters for call to function remove_ext_hdr
   \   0004FE   12....       LCALL   ??remove_ext_hdr?relay
   \   000501   90....       MOV     DPTR,#uip_len
   \   000504   E0           MOVX    A,@DPTR
   \   000505   24D0         ADD     A,#-0x30
   \   000507   F0           MOVX    @DPTR,A
   \   000508   A3           INC     DPTR
   \   000509   E0           MOVX    A,@DPTR
   \   00050A   34FF         ADDC    A,#-0x1
   \   00050C   F0           MOVX    @DPTR,A
   \   00050D   90....       MOV     DPTR,#uip_appdata
   \   000510   74..         MOV     A,#(uip_aligned_buf + 48) & 0xff
   \   000512   F0           MOVX    @DPTR,A
   \   000513   A3           INC     DPTR
   \   000514   74..         MOV     A,#((uip_aligned_buf + 48) >> 8) & 0xff
   \   000516   F0           MOVX    @DPTR,A
   \   000517   90....       MOV     DPTR,#uip_aligned_buf + 46
   \   00051A   E0           MOVX    A,@DPTR
   \   00051B   F8           MOV     R0,A
   \   00051C   A3           INC     DPTR
   \   00051D   E0           MOVX    A,@DPTR
   \   00051E   F9           MOV     R1,A
   \   00051F   E8           MOV     A,R0
   \   000520   49           ORL     A,R1
   \   000521   6003         JZ      $+5
   \   000523   02....       LJMP    ??uip_process_36 & 0xFFFF
   \                     ??uip_process_37:
   \   000526   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000529   E0           MOVX    A,@DPTR
   \   00052A   F8           MOV     R0,A
   \   00052B   A3           INC     DPTR
   \   00052C   E0           MOVX    A,@DPTR
   \   00052D   F9           MOV     R1,A
   \   00052E   E8           MOV     A,R0
   \   00052F   49           ORL     A,R1
   \   000530   6003         JZ      $+5
   \   000532   02....       LJMP    ??uip_process_38 & 0xFFFF
   \   000535   02....       LJMP    ??uip_process_3 & 0xFFFF
   \                     ??uip_process_35:
   \   000538   90....       MOV     DPTR,#uip_ext_bitmap
   \   00053B   E0           MOVX    A,@DPTR
   \   00053C   A2E1         MOV     C,0xE0 /* A   */.1
   \   00053E   5014         JNC     ??uip_process_39
   \   000540   90....       MOV     DPTR,#uip_ext_bitmap
   \   000543   E0           MOVX    A,@DPTR
   \   000544   A2E6         MOV     C,0xE0 /* A   */.6
   \   000546   5003         JNC     $+5
   \   000548   02....       LJMP    ??uip_process_31 & 0xFFFF
   \   00054B   90....       MOV     DPTR,#uip_ext_bitmap
   \   00054E   E0           MOVX    A,@DPTR
   \   00054F   D2E6         SETB    0xE0 /* A   */.6
   \   000551   F0           MOVX    @DPTR,A
   \   000552   8007         SJMP    ??uip_process_40
   \                     ??uip_process_39:
   \   000554   90....       MOV     DPTR,#uip_ext_bitmap
   \   000557   E0           MOVX    A,@DPTR
   \   000558   D2E1         SETB    0xE0 /* A   */.1
   \   00055A   F0           MOVX    @DPTR,A
   \                     ??uip_process_40:
   \   00055B                ; Setup parameters for call to function ext_hdr_options_process
   \   00055B   12....       LCALL   ??ext_hdr_options_process?relay
   \   00055E   E9           MOV     A,R1
   \   00055F   6008         JZ      ??uip_process_41
   \   000561   14           DEC     A
   \   000562   604F         JZ      ??uip_process_42
   \   000564   14           DEC     A
   \   000565   604F         JZ      ??uip_process_43
   \   000567   8047         SJMP    ??uip_process_44
   \                     ??uip_process_41:
   \   000569   90....       MOV     DPTR,#uip_ext_len
   \   00056C   E0           MOVX    A,@DPTR
   \   00056D   F8           MOV     R0,A
   \   00056E   7900         MOV     R1,#0x0
   \   000570   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000572   28           ADD     A,R0
   \   000573   F8           MOV     R0,A
   \   000574   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000576   39           ADDC    A,R1
   \   000577   F9           MOV     R1,A
   \   000578   E8           MOV     A,R0
   \   000579   2428         ADD     A,#0x28
   \   00057B   F8           MOV     R0,A
   \   00057C   E9           MOV     A,R1
   \   00057D   3400         ADDC    A,#0x0
   \   00057F   F9           MOV     R1,A
   \   000580   90....       MOV     DPTR,#uip_next_hdr
   \   000583   E8           MOV     A,R0
   \   000584   F0           MOVX    @DPTR,A
   \   000585   A3           INC     DPTR
   \   000586   E9           MOV     A,R1
   \   000587   F0           MOVX    @DPTR,A
   \   000588   90....       MOV     DPTR,#uip_ext_len
   \   00058B   E0           MOVX    A,@DPTR
   \   00058C   F8           MOV     R0,A
   \   00058D   7900         MOV     R1,#0x0
   \   00058F   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000591   28           ADD     A,R0
   \   000592   F8           MOV     R0,A
   \   000593   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000595   39           ADDC    A,R1
   \   000596   F9           MOV     R1,A
   \   000597   E8           MOV     A,R0
   \   000598   2429         ADD     A,#0x29
   \   00059A   F582         MOV     DPL,A
   \   00059C   E9           MOV     A,R1
   \   00059D   3400         ADDC    A,#0x0
   \   00059F   F583         MOV     DPH,A
   \   0005A1   E0           MOVX    A,@DPTR
   \   0005A2   33           RLC     A
   \   0005A3   33           RLC     A
   \   0005A4   33           RLC     A
   \   0005A5   54F8         ANL     A,#0xf8
   \   0005A7   2408         ADD     A,#0x8
   \   0005A9   F8           MOV     R0,A
   \   0005AA   90....       MOV     DPTR,#uip_ext_len
   \   0005AD   E0           MOVX    A,@DPTR
   \   0005AE   28           ADD     A,R0
   \   0005AF   F0           MOVX    @DPTR,A
   \                     ??uip_process_44:
   \   0005B0   02....       LJMP    ??uip_process_9 & 0xFFFF
   \                     ??uip_process_42:
   \   0005B3   02....       LJMP    ??uip_process_3 & 0xFFFF
   \                     ??uip_process_43:
   \   0005B6   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_34:
   \   0005B9   90....       MOV     DPTR,#uip_ext_bitmap
   \   0005BC   E0           MOVX    A,@DPTR
   \   0005BD   A2E2         MOV     C,0xE0 /* A   */.2
   \   0005BF   5003         JNC     $+5
   \   0005C1   02....       LJMP    ??uip_process_31 & 0xFFFF
   \   0005C4   90....       MOV     DPTR,#uip_ext_bitmap
   \   0005C7   E0           MOVX    A,@DPTR
   \   0005C8   D2E2         SETB    0xE0 /* A   */.2
   \   0005CA   F0           MOVX    @DPTR,A
   \   0005CB   90....       MOV     DPTR,#uip_ext_len
   \   0005CE   E0           MOVX    A,@DPTR
   \   0005CF   F8           MOV     R0,A
   \   0005D0   7900         MOV     R1,#0x0
   \   0005D2   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0005D4   28           ADD     A,R0
   \   0005D5   F8           MOV     R0,A
   \   0005D6   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0005D8   39           ADDC    A,R1
   \   0005D9   F9           MOV     R1,A
   \   0005DA   E8           MOV     A,R0
   \   0005DB   242B         ADD     A,#0x2b
   \   0005DD   F582         MOV     DPL,A
   \   0005DF   E9           MOV     A,R1
   \   0005E0   3400         ADDC    A,#0x0
   \   0005E2   F583         MOV     DPH,A
   \   0005E4   E0           MOVX    A,@DPTR
   \   0005E5   C3           CLR     C
   \   0005E6   9401         SUBB    A,#0x1
   \   0005E8   402D         JC      ??uip_process_45
   \   0005EA                ; Setup parameters for call to function uip_icmp6_error_output
   \   0005EA   90....       MOV     DPTR,#uip_ext_len
   \   0005ED   E0           MOVX    A,@DPTR
   \   0005EE   F8           MOV     R0,A
   \   0005EF   7900         MOV     R1,#0x0
   \   0005F1   242A         ADD     A,#0x2a
   \   0005F3   F5..         MOV     ?V0 + 0,A
   \   0005F5   E9           MOV     A,R1
   \   0005F6   3400         ADDC    A,#0x0
   \   0005F8   F5..         MOV     ?V0 + 1,A
   \   0005FA   E5..         MOV     A,?V0 + 1
   \   0005FC   33           RLC     A
   \   0005FD   95E0         SUBB    A,0xE0 /* A   */
   \   0005FF   F5..         MOV     ?V0 + 2,A
   \   000601   F5..         MOV     ?V0 + 3,A
   \   000603   78..         MOV     R0,#?V0 + 0
   \   000605   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000608   7A00         MOV     R2,#0x0
   \   00060A   7904         MOV     R1,#0x4
   \   00060C   12....       LCALL   ??uip_icmp6_error_output?relay
   \   00060F   7404         MOV     A,#0x4
   \   000611   12....       LCALL   ?DEALLOC_XSTACK8
   \   000614   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_45:
   \   000617   90....       MOV     DPTR,#uip_ext_len
   \   00061A   E0           MOVX    A,@DPTR
   \   00061B   F8           MOV     R0,A
   \   00061C   7900         MOV     R1,#0x0
   \   00061E   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000620   28           ADD     A,R0
   \   000621   F8           MOV     R0,A
   \   000622   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000624   39           ADDC    A,R1
   \   000625   F9           MOV     R1,A
   \   000626   E8           MOV     A,R0
   \   000627   2428         ADD     A,#0x28
   \   000629   F8           MOV     R0,A
   \   00062A   E9           MOV     A,R1
   \   00062B   3400         ADDC    A,#0x0
   \   00062D   F9           MOV     R1,A
   \   00062E   90....       MOV     DPTR,#uip_next_hdr
   \   000631   E8           MOV     A,R0
   \   000632   F0           MOVX    @DPTR,A
   \   000633   A3           INC     DPTR
   \   000634   E9           MOV     A,R1
   \   000635   F0           MOVX    @DPTR,A
   \   000636   90....       MOV     DPTR,#uip_ext_len
   \   000639   E0           MOVX    A,@DPTR
   \   00063A   F8           MOV     R0,A
   \   00063B   7900         MOV     R1,#0x0
   \   00063D   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00063F   28           ADD     A,R0
   \   000640   F8           MOV     R0,A
   \   000641   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000643   39           ADDC    A,R1
   \   000644   F9           MOV     R1,A
   \   000645   E8           MOV     A,R0
   \   000646   2429         ADD     A,#0x29
   \   000648   F582         MOV     DPL,A
   \   00064A   E9           MOV     A,R1
   \   00064B   3400         ADDC    A,#0x0
   \   00064D   F583         MOV     DPH,A
   \   00064F   E0           MOVX    A,@DPTR
   \   000650   33           RLC     A
   \   000651   33           RLC     A
   \   000652   33           RLC     A
   \   000653   54F8         ANL     A,#0xf8
   \   000655   2408         ADD     A,#0x8
   \   000657   F8           MOV     R0,A
   \   000658   90....       MOV     DPTR,#uip_ext_len
   \   00065B   E0           MOVX    A,@DPTR
   \   00065C   28           ADD     A,R0
   \   00065D   F0           MOVX    @DPTR,A
   \   00065E   02....       LJMP    ??uip_process_9 & 0xFFFF
   \                     ??uip_process_31:
   \   000661                ; Setup parameters for call to function uip_icmp6_error_output
   \   000661   90....       MOV     DPTR,#uip_next_hdr
   \   000664   E0           MOVX    A,@DPTR
   \   000665   C3           CLR     C
   \   000666   94..         SUBB    A,#uip_aligned_buf & 0xff
   \   000668   F5..         MOV     ?V0 + 0,A
   \   00066A   A3           INC     DPTR
   \   00066B   E0           MOVX    A,@DPTR
   \   00066C   94..         SUBB    A,#(uip_aligned_buf >> 8) & 0xff
   \   00066E   F5..         MOV     ?V0 + 1,A
   \   000670   E5..         MOV     A,?V0 + 1
   \   000672   33           RLC     A
   \   000673   95E0         SUBB    A,0xE0 /* A   */
   \   000675   F5..         MOV     ?V0 + 2,A
   \   000677   F5..         MOV     ?V0 + 3,A
   \   000679   78..         MOV     R0,#?V0 + 0
   \   00067B   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00067E   7A01         MOV     R2,#0x1
   \   000680   7904         MOV     R1,#0x4
   \   000682   12....       LCALL   ??uip_icmp6_error_output?relay
   \   000685   7404         MOV     A,#0x4
   \   000687   12....       LCALL   ?DEALLOC_XSTACK8
   \   00068A   02....       LJMP    ??uip_process_8 & 0xFFFF
   \                     ??uip_process_27:
   \   00068D                ; Setup parameters for call to function uip_nd6_na_input
   \   00068D   12....       LCALL   ??uip_nd6_na_input?relay
   \   000690   8033         SJMP    ??uip_process_29
   \                     ??uip_process_24:
   \   000692   90....       MOV     DPTR,#uip_len
   \   000695   7400         MOV     A,#0x0
   \   000697   F0           MOVX    @DPTR,A
   \   000698   A3           INC     DPTR
   \   000699   7400         MOV     A,#0x0
   \   00069B   F0           MOVX    @DPTR,A
   \   00069C   8027         SJMP    ??uip_process_29
   \                     ??uip_process_25:
   \   00069E   90....       MOV     DPTR,#uip_len
   \   0006A1   7400         MOV     A,#0x0
   \   0006A3   F0           MOVX    @DPTR,A
   \   0006A4   A3           INC     DPTR
   \   0006A5   7400         MOV     A,#0x0
   \   0006A7   F0           MOVX    @DPTR,A
   \   0006A8   801B         SJMP    ??uip_process_29
   \                     ??uip_process_22:
   \   0006AA                ; Setup parameters for call to function uip_icmp6_echo_request_input
   \   0006AA   12....       LCALL   ??uip_icmp6_echo_request_input?relay
   \   0006AD   8016         SJMP    ??uip_process_29
   \                     ??uip_process_23:
   \   0006AF   90....       MOV     DPTR,#uip_len
   \   0006B2   7400         MOV     A,#0x0
   \   0006B4   F0           MOVX    @DPTR,A
   \   0006B5   A3           INC     DPTR
   \   0006B6   7400         MOV     A,#0x0
   \   0006B8   F0           MOVX    @DPTR,A
   \   0006B9   800A         SJMP    ??uip_process_29
   \                     ??uip_process_28:
   \   0006BB   90....       MOV     DPTR,#uip_len
   \   0006BE   7400         MOV     A,#0x0
   \   0006C0   F0           MOVX    @DPTR,A
   \   0006C1   A3           INC     DPTR
   \   0006C2   7400         MOV     A,#0x0
   \   0006C4   F0           MOVX    @DPTR,A
   \                     ??uip_process_29:
   \   0006C5   90....       MOV     DPTR,#uip_len
   \   0006C8   E0           MOVX    A,@DPTR
   \   0006C9   F8           MOV     R0,A
   \   0006CA   A3           INC     DPTR
   \   0006CB   E0           MOVX    A,@DPTR
   \   0006CC   F9           MOV     R1,A
   \   0006CD   E8           MOV     A,R0
   \   0006CE   49           ORL     A,R1
   \   0006CF   6003         JZ      $+5
   \   0006D1   02....       LJMP    ??uip_process_8 & 0xFFFF
   \   0006D4   02....       LJMP    ??uip_process_3 & 0xFFFF
   \                     ??uip_process_36:
   \   0006D7                ; Setup parameters for call to function uip_udpchksum
   \   0006D7   12....       LCALL   ??uip_udpchksum?relay
   \   0006DA   8A..         MOV     ?V0 + 0,R2
   \   0006DC   8B..         MOV     ?V0 + 1,R3
   \   0006DE   74FF         MOV     A,#-0x1
   \   0006E0   65..         XRL     A,?V0 + 0
   \   0006E2   7004         JNZ     ??uip_process_46
   \   0006E4   74FF         MOV     A,#-0x1
   \   0006E6   65..         XRL     A,?V0 + 1
   \                     ??uip_process_46:
   \   0006E8   7003         JNZ     $+5
   \   0006EA   02....       LJMP    ??uip_process_37 & 0xFFFF
   \   0006ED   02....       LJMP    ??uip_process_3 & 0xFFFF
   \                     ??uip_process_38:
   \   0006F0   90....       MOV     DPTR,#uip_udp_conn
   \   0006F3   74..         MOV     A,#uip_udp_conns & 0xff
   \   0006F5   F0           MOVX    @DPTR,A
   \   0006F6   A3           INC     DPTR
   \   0006F7   74..         MOV     A,#(uip_udp_conns >> 8) & 0xff
   \   0006F9   F0           MOVX    @DPTR,A
   \   0006FA   8014         SJMP    ??uip_process_47
   \                     ??uip_process_48:
   \   0006FC   90....       MOV     DPTR,#uip_udp_conn
   \   0006FF   E0           MOVX    A,@DPTR
   \   000700   2419         ADD     A,#0x19
   \   000702   F8           MOV     R0,A
   \   000703   A3           INC     DPTR
   \   000704   E0           MOVX    A,@DPTR
   \   000705   3400         ADDC    A,#0x0
   \   000707   F9           MOV     R1,A
   \   000708   90....       MOV     DPTR,#uip_udp_conn
   \   00070B   E8           MOV     A,R0
   \   00070C   F0           MOVX    @DPTR,A
   \   00070D   A3           INC     DPTR
   \   00070E   E9           MOV     A,R1
   \   00070F   F0           MOVX    @DPTR,A
   \                     ??uip_process_47:
   \   000710   90....       MOV     DPTR,#uip_udp_conn
   \   000713   C3           CLR     C
   \   000714   E0           MOVX    A,@DPTR
   \   000715   94..         SUBB    A,#(uip_udp_conns + 250) & 0xff
   \   000717   A3           INC     DPTR
   \   000718   E0           MOVX    A,@DPTR
   \   000719   94..         SUBB    A,#((uip_udp_conns + 250) >> 8) & 0xff
   \   00071B   4003         JC      $+5
   \   00071D   02....       LJMP    ??uip_process_3 & 0xFFFF
   \   000720   90....       MOV     DPTR,#uip_udp_conn
   \   000723   E0           MOVX    A,@DPTR
   \   000724   F8           MOV     R0,A
   \   000725   A3           INC     DPTR
   \   000726   E0           MOVX    A,@DPTR
   \   000727   C8           XCH     A,R0
   \   000728   2410         ADD     A,#0x10
   \   00072A   F582         MOV     DPL,A
   \   00072C   E8           MOV     A,R0
   \   00072D   3400         ADDC    A,#0x0
   \   00072F   F583         MOV     DPH,A
   \   000731   E0           MOVX    A,@DPTR
   \   000732   F8           MOV     R0,A
   \   000733   A3           INC     DPTR
   \   000734   E0           MOVX    A,@DPTR
   \   000735   F9           MOV     R1,A
   \   000736   E8           MOV     A,R0
   \   000737   49           ORL     A,R1
   \   000738   60C2         JZ      ??uip_process_48
   \   00073A   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   00073D   E0           MOVX    A,@DPTR
   \   00073E   F8           MOV     R0,A
   \   00073F   A3           INC     DPTR
   \   000740   E0           MOVX    A,@DPTR
   \   000741   F9           MOV     R1,A
   \   000742   90....       MOV     DPTR,#uip_udp_conn
   \   000745   E0           MOVX    A,@DPTR
   \   000746   FA           MOV     R2,A
   \   000747   A3           INC     DPTR
   \   000748   E0           MOVX    A,@DPTR
   \   000749   CA           XCH     A,R2
   \   00074A   2410         ADD     A,#0x10
   \   00074C   F582         MOV     DPL,A
   \   00074E   EA           MOV     A,R2
   \   00074F   3400         ADDC    A,#0x0
   \   000751   F583         MOV     DPH,A
   \   000753   E0           MOVX    A,@DPTR
   \   000754   68           XRL     A,R0
   \   000755   7003         JNZ     ??uip_process_49
   \   000757   A3           INC     DPTR
   \   000758   E0           MOVX    A,@DPTR
   \   000759   69           XRL     A,R1
   \                     ??uip_process_49:
   \   00075A   70A0         JNZ     ??uip_process_48
   \   00075C   90....       MOV     DPTR,#uip_udp_conn
   \   00075F   E0           MOVX    A,@DPTR
   \   000760   F8           MOV     R0,A
   \   000761   A3           INC     DPTR
   \   000762   E0           MOVX    A,@DPTR
   \   000763   C8           XCH     A,R0
   \   000764   2412         ADD     A,#0x12
   \   000766   F582         MOV     DPL,A
   \   000768   E8           MOV     A,R0
   \   000769   3400         ADDC    A,#0x0
   \   00076B   F583         MOV     DPH,A
   \   00076D   E0           MOVX    A,@DPTR
   \   00076E   F8           MOV     R0,A
   \   00076F   A3           INC     DPTR
   \   000770   E0           MOVX    A,@DPTR
   \   000771   F9           MOV     R1,A
   \   000772   E8           MOV     A,R0
   \   000773   49           ORL     A,R1
   \   000774   6025         JZ      ??uip_process_50
   \   000776   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   000779   E0           MOVX    A,@DPTR
   \   00077A   F8           MOV     R0,A
   \   00077B   A3           INC     DPTR
   \   00077C   E0           MOVX    A,@DPTR
   \   00077D   F9           MOV     R1,A
   \   00077E   90....       MOV     DPTR,#uip_udp_conn
   \   000781   E0           MOVX    A,@DPTR
   \   000782   FA           MOV     R2,A
   \   000783   A3           INC     DPTR
   \   000784   E0           MOVX    A,@DPTR
   \   000785   CA           XCH     A,R2
   \   000786   2412         ADD     A,#0x12
   \   000788   F582         MOV     DPL,A
   \   00078A   EA           MOV     A,R2
   \   00078B   3400         ADDC    A,#0x0
   \   00078D   F583         MOV     DPH,A
   \   00078F   E0           MOVX    A,@DPTR
   \   000790   68           XRL     A,R0
   \   000791   7003         JNZ     ??uip_process_51
   \   000793   A3           INC     DPTR
   \   000794   E0           MOVX    A,@DPTR
   \   000795   69           XRL     A,R1
   \                     ??uip_process_51:
   \   000796   6003         JZ      $+5
   \   000798   02....       LJMP    ??uip_process_48 & 0xFFFF
   \                     ??uip_process_50:
   \   00079B   90....       MOV     DPTR,#uip_udp_conn
   \   00079E   E0           MOVX    A,@DPTR
   \   00079F   F8           MOV     R0,A
   \   0007A0   A3           INC     DPTR
   \   0007A1   E0           MOVX    A,@DPTR
   \   0007A2   F583         MOV     DPH,A
   \   0007A4   8882         MOV     DPL,R0
   \   0007A6   E0           MOVX    A,@DPTR
   \   0007A7   F8           MOV     R0,A
   \   0007A8   A3           INC     DPTR
   \   0007A9   E0           MOVX    A,@DPTR
   \   0007AA   F9           MOV     R1,A
   \   0007AB   E8           MOV     A,R0
   \   0007AC   49           ORL     A,R1
   \   0007AD   6003         JZ      $+5
   \   0007AF   02....       LJMP    ??uip_process_52 & 0xFFFF
   \   0007B2   90....       MOV     DPTR,#uip_udp_conn
   \   0007B5   E0           MOVX    A,@DPTR
   \   0007B6   F8           MOV     R0,A
   \   0007B7   A3           INC     DPTR
   \   0007B8   E0           MOVX    A,@DPTR
   \   0007B9   F583         MOV     DPH,A
   \   0007BB   8882         MOV     DPL,R0
   \   0007BD   A3           INC     DPTR
   \   0007BE   A3           INC     DPTR
   \   0007BF   E0           MOVX    A,@DPTR
   \   0007C0   F8           MOV     R0,A
   \   0007C1   A3           INC     DPTR
   \   0007C2   E0           MOVX    A,@DPTR
   \   0007C3   F9           MOV     R1,A
   \   0007C4   E8           MOV     A,R0
   \   0007C5   49           ORL     A,R1
   \   0007C6   6003         JZ      $+5
   \   0007C8   02....       LJMP    ??uip_process_52 & 0xFFFF
   \   0007CB   90....       MOV     DPTR,#uip_udp_conn
   \   0007CE   E0           MOVX    A,@DPTR
   \   0007CF   F8           MOV     R0,A
   \   0007D0   A3           INC     DPTR
   \   0007D1   E0           MOVX    A,@DPTR
   \   0007D2   F583         MOV     DPH,A
   \   0007D4   8882         MOV     DPL,R0
   \   0007D6   A3           INC     DPTR
   \   0007D7   A3           INC     DPTR
   \   0007D8   A3           INC     DPTR
   \   0007D9   A3           INC     DPTR
   \   0007DA   E0           MOVX    A,@DPTR
   \   0007DB   F8           MOV     R0,A
   \   0007DC   A3           INC     DPTR
   \   0007DD   E0           MOVX    A,@DPTR
   \   0007DE   F9           MOV     R1,A
   \   0007DF   E8           MOV     A,R0
   \   0007E0   49           ORL     A,R1
   \   0007E1   6003         JZ      $+5
   \   0007E3   02....       LJMP    ??uip_process_52 & 0xFFFF
   \   0007E6   90....       MOV     DPTR,#uip_udp_conn
   \   0007E9   E0           MOVX    A,@DPTR
   \   0007EA   F8           MOV     R0,A
   \   0007EB   A3           INC     DPTR
   \   0007EC   E0           MOVX    A,@DPTR
   \   0007ED   C8           XCH     A,R0
   \   0007EE   2406         ADD     A,#0x6
   \   0007F0   F582         MOV     DPL,A
   \   0007F2   E8           MOV     A,R0
   \   0007F3   3400         ADDC    A,#0x0
   \   0007F5   F583         MOV     DPH,A
   \   0007F7   E0           MOVX    A,@DPTR
   \   0007F8   F8           MOV     R0,A
   \   0007F9   A3           INC     DPTR
   \   0007FA   E0           MOVX    A,@DPTR
   \   0007FB   F9           MOV     R1,A
   \   0007FC   E8           MOV     A,R0
   \   0007FD   49           ORL     A,R1
   \   0007FE   7068         JNZ     ??uip_process_52
   \   000800   90....       MOV     DPTR,#uip_udp_conn
   \   000803   E0           MOVX    A,@DPTR
   \   000804   F8           MOV     R0,A
   \   000805   A3           INC     DPTR
   \   000806   E0           MOVX    A,@DPTR
   \   000807   C8           XCH     A,R0
   \   000808   2408         ADD     A,#0x8
   \   00080A   F582         MOV     DPL,A
   \   00080C   E8           MOV     A,R0
   \   00080D   3400         ADDC    A,#0x0
   \   00080F   F583         MOV     DPH,A
   \   000811   E0           MOVX    A,@DPTR
   \   000812   F8           MOV     R0,A
   \   000813   A3           INC     DPTR
   \   000814   E0           MOVX    A,@DPTR
   \   000815   F9           MOV     R1,A
   \   000816   E8           MOV     A,R0
   \   000817   49           ORL     A,R1
   \   000818   704E         JNZ     ??uip_process_52
   \   00081A   90....       MOV     DPTR,#uip_udp_conn
   \   00081D   E0           MOVX    A,@DPTR
   \   00081E   F8           MOV     R0,A
   \   00081F   A3           INC     DPTR
   \   000820   E0           MOVX    A,@DPTR
   \   000821   C8           XCH     A,R0
   \   000822   240A         ADD     A,#0xa
   \   000824   F582         MOV     DPL,A
   \   000826   E8           MOV     A,R0
   \   000827   3400         ADDC    A,#0x0
   \   000829   F583         MOV     DPH,A
   \   00082B   E0           MOVX    A,@DPTR
   \   00082C   F8           MOV     R0,A
   \   00082D   A3           INC     DPTR
   \   00082E   E0           MOVX    A,@DPTR
   \   00082F   F9           MOV     R1,A
   \   000830   E8           MOV     A,R0
   \   000831   49           ORL     A,R1
   \   000832   7034         JNZ     ??uip_process_52
   \   000834   90....       MOV     DPTR,#uip_udp_conn
   \   000837   E0           MOVX    A,@DPTR
   \   000838   F8           MOV     R0,A
   \   000839   A3           INC     DPTR
   \   00083A   E0           MOVX    A,@DPTR
   \   00083B   C8           XCH     A,R0
   \   00083C   240C         ADD     A,#0xc
   \   00083E   F582         MOV     DPL,A
   \   000840   E8           MOV     A,R0
   \   000841   3400         ADDC    A,#0x0
   \   000843   F583         MOV     DPH,A
   \   000845   E0           MOVX    A,@DPTR
   \   000846   F8           MOV     R0,A
   \   000847   A3           INC     DPTR
   \   000848   E0           MOVX    A,@DPTR
   \   000849   F9           MOV     R1,A
   \   00084A   E8           MOV     A,R0
   \   00084B   49           ORL     A,R1
   \   00084C   701A         JNZ     ??uip_process_52
   \   00084E   90....       MOV     DPTR,#uip_udp_conn
   \   000851   E0           MOVX    A,@DPTR
   \   000852   F8           MOV     R0,A
   \   000853   A3           INC     DPTR
   \   000854   E0           MOVX    A,@DPTR
   \   000855   C8           XCH     A,R0
   \   000856   240E         ADD     A,#0xe
   \   000858   F582         MOV     DPL,A
   \   00085A   E8           MOV     A,R0
   \   00085B   3400         ADDC    A,#0x0
   \   00085D   F583         MOV     DPH,A
   \   00085F   E0           MOVX    A,@DPTR
   \   000860   F8           MOV     R0,A
   \   000861   A3           INC     DPTR
   \   000862   E0           MOVX    A,@DPTR
   \   000863   F9           MOV     R1,A
   \   000864   E8           MOV     A,R0
   \   000865   49           ORL     A,R1
   \   000866   602C         JZ      ??uip_process_53
   \                     ??uip_process_52:
   \   000868                ; Setup parameters for call to function memcmp
   \   000868   75..10       MOV     ?V0 + 0,#0x10
   \   00086B   75..00       MOV     ?V0 + 1,#0x0
   \   00086E   78..         MOV     R0,#?V0 + 0
   \   000870   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000873   90....       MOV     DPTR,#uip_udp_conn
   \   000876   E0           MOVX    A,@DPTR
   \   000877   FC           MOV     R4,A
   \   000878   A3           INC     DPTR
   \   000879   E0           MOVX    A,@DPTR
   \   00087A   FD           MOV     R5,A
   \   00087B   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   00087D   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   00087F   12....       LCALL   ??memcmp?relay
   \   000882   7402         MOV     A,#0x2
   \   000884   12....       LCALL   ?DEALLOC_XSTACK8
   \   000887   8A..         MOV     ?V0 + 0,R2
   \   000889   8B..         MOV     ?V0 + 1,R3
   \   00088B   E5..         MOV     A,?V0 + 0
   \   00088D   45..         ORL     A,?V0 + 1
   \   00088F   6003         JZ      $+5
   \   000891   02....       LJMP    ??uip_process_48 & 0xFFFF
   \                     ??uip_process_53:
   \   000894   90....       MOV     DPTR,#uip_conn
   \   000897   7400         MOV     A,#0x0
   \   000899   F0           MOVX    @DPTR,A
   \   00089A   A3           INC     DPTR
   \   00089B   7400         MOV     A,#0x0
   \   00089D   F0           MOVX    @DPTR,A
   \   00089E   90....       MOV     DPTR,#uip_flags
   \   0008A1   7402         MOV     A,#0x2
   \   0008A3   F0           MOVX    @DPTR,A
   \   0008A4   78..         MOV     R0,#(uip_aligned_buf + 48) & 0xff
   \   0008A6   79..         MOV     R1,#((uip_aligned_buf + 48) >> 8) & 0xff
   \   0008A8   90....       MOV     DPTR,#uip_appdata
   \   0008AB   E8           MOV     A,R0
   \   0008AC   F0           MOVX    @DPTR,A
   \   0008AD   A3           INC     DPTR
   \   0008AE   E9           MOV     A,R1
   \   0008AF   F0           MOVX    @DPTR,A
   \   0008B0   90....       MOV     DPTR,#uip_sappdata
   \   0008B3   E8           MOV     A,R0
   \   0008B4   F0           MOVX    @DPTR,A
   \   0008B5   A3           INC     DPTR
   \   0008B6   E9           MOV     A,R1
   \   0008B7   F0           MOVX    @DPTR,A
   \   0008B8   90....       MOV     DPTR,#uip_slen
   \   0008BB   7400         MOV     A,#0x0
   \   0008BD   F0           MOVX    @DPTR,A
   \   0008BE   A3           INC     DPTR
   \   0008BF   7400         MOV     A,#0x0
   \   0008C1   F0           MOVX    @DPTR,A
   \   0008C2                ; Setup parameters for call to function tcpip_uipcall
   \   0008C2   12....       LCALL   ??tcpip_uipcall?relay
   \   0008C5   02....       LJMP    ??uip_process_1 & 0xFFFF
   \                     ??uip_process_2:
   \   0008C8   90....       MOV     DPTR,#uip_slen
   \   0008CB   E0           MOVX    A,@DPTR
   \   0008CC   2430         ADD     A,#0x30
   \   0008CE   F8           MOV     R0,A
   \   0008CF   A3           INC     DPTR
   \   0008D0   E0           MOVX    A,@DPTR
   \   0008D1   3400         ADDC    A,#0x0
   \   0008D3   F9           MOV     R1,A
   \   0008D4   90....       MOV     DPTR,#uip_len
   \   0008D7   E8           MOV     A,R0
   \   0008D8   F0           MOVX    @DPTR,A
   \   0008D9   A3           INC     DPTR
   \   0008DA   E9           MOV     A,R1
   \   0008DB   F0           MOVX    @DPTR,A
   \   0008DC   90....       MOV     DPTR,#uip_len
   \   0008DF   E0           MOVX    A,@DPTR
   \   0008E0   24D8         ADD     A,#-0x28
   \   0008E2   F8           MOV     R0,A
   \   0008E3   A3           INC     DPTR
   \   0008E4   E0           MOVX    A,@DPTR
   \   0008E5   34FF         ADDC    A,#-0x1
   \   0008E7   F9           MOV     R1,A
   \   0008E8   E4           CLR     A
   \   0008E9   E9           MOV     A,R1
   \   0008EA   F8           MOV     R0,A
   \   0008EB   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   0008EE   F0           MOVX    @DPTR,A
   \   0008EF   90....       MOV     DPTR,#uip_len
   \   0008F2   E0           MOVX    A,@DPTR
   \   0008F3   F8           MOV     R0,A
   \   0008F4   A3           INC     DPTR
   \   0008F5   E0           MOVX    A,@DPTR
   \   0008F6   F9           MOV     R1,A
   \   0008F7   E8           MOV     A,R0
   \   0008F8   24D8         ADD     A,#-0x28
   \   0008FA   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   0008FD   F0           MOVX    @DPTR,A
   \   0008FE   90....       MOV     DPTR,#uip_udp_conn
   \   000901   E0           MOVX    A,@DPTR
   \   000902   F8           MOV     R0,A
   \   000903   A3           INC     DPTR
   \   000904   E0           MOVX    A,@DPTR
   \   000905   C8           XCH     A,R0
   \   000906   2414         ADD     A,#0x14
   \   000908   F582         MOV     DPL,A
   \   00090A   E8           MOV     A,R0
   \   00090B   3400         ADDC    A,#0x0
   \   00090D   F583         MOV     DPH,A
   \   00090F   E0           MOVX    A,@DPTR
   \   000910   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   000913   F0           MOVX    @DPTR,A
   \   000914   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000917   7411         MOV     A,#0x11
   \   000919   F0           MOVX    @DPTR,A
   \   00091A   90....       MOV     DPTR,#uip_slen
   \   00091D   E0           MOVX    A,@DPTR
   \   00091E   2408         ADD     A,#0x8
   \   000920   FA           MOV     R2,A
   \   000921   A3           INC     DPTR
   \   000922   E0           MOVX    A,@DPTR
   \   000923   3400         ADDC    A,#0x0
   \   000925   FB           MOV     R3,A
   \   000926   E4           CLR     A
   \   000927   CA           XCH     A,R2
   \   000928   FB           MOV     R3,A
   \   000929   90....       MOV     DPTR,#uip_slen
   \   00092C   E0           MOVX    A,@DPTR
   \   00092D   2408         ADD     A,#0x8
   \   00092F   F8           MOV     R0,A
   \   000930   A3           INC     DPTR
   \   000931   E0           MOVX    A,@DPTR
   \   000932   3400         ADDC    A,#0x0
   \   000934   F9           MOV     R1,A
   \   000935   E4           CLR     A
   \   000936   C9           XCH     A,R1
   \   000937   F8           MOV     R0,A
   \   000938   EA           MOV     A,R2
   \   000939   48           ORL     A,R0
   \   00093A   F8           MOV     R0,A
   \   00093B   EB           MOV     A,R3
   \   00093C   49           ORL     A,R1
   \   00093D   F9           MOV     R1,A
   \   00093E   90....       MOV     DPTR,#uip_aligned_buf + 44
   \   000941   E8           MOV     A,R0
   \   000942   F0           MOVX    @DPTR,A
   \   000943   A3           INC     DPTR
   \   000944   E9           MOV     A,R1
   \   000945   F0           MOVX    @DPTR,A
   \   000946   90....       MOV     DPTR,#uip_aligned_buf + 46
   \   000949   7400         MOV     A,#0x0
   \   00094B   F0           MOVX    @DPTR,A
   \   00094C   A3           INC     DPTR
   \   00094D   7400         MOV     A,#0x0
   \   00094F   F0           MOVX    @DPTR,A
   \   000950   90....       MOV     DPTR,#uip_udp_conn
   \   000953   E0           MOVX    A,@DPTR
   \   000954   F8           MOV     R0,A
   \   000955   A3           INC     DPTR
   \   000956   E0           MOVX    A,@DPTR
   \   000957   C8           XCH     A,R0
   \   000958   2410         ADD     A,#0x10
   \   00095A   F582         MOV     DPL,A
   \   00095C   E8           MOV     A,R0
   \   00095D   3400         ADDC    A,#0x0
   \   00095F   F583         MOV     DPH,A
   \   000961   E0           MOVX    A,@DPTR
   \   000962   F8           MOV     R0,A
   \   000963   A3           INC     DPTR
   \   000964   E0           MOVX    A,@DPTR
   \   000965   F9           MOV     R1,A
   \   000966   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   000969   E8           MOV     A,R0
   \   00096A   F0           MOVX    @DPTR,A
   \   00096B   A3           INC     DPTR
   \   00096C   E9           MOV     A,R1
   \   00096D   F0           MOVX    @DPTR,A
   \   00096E   90....       MOV     DPTR,#uip_udp_conn
   \   000971   E0           MOVX    A,@DPTR
   \   000972   F8           MOV     R0,A
   \   000973   A3           INC     DPTR
   \   000974   E0           MOVX    A,@DPTR
   \   000975   C8           XCH     A,R0
   \   000976   2412         ADD     A,#0x12
   \   000978   F582         MOV     DPL,A
   \   00097A   E8           MOV     A,R0
   \   00097B   3400         ADDC    A,#0x0
   \   00097D   F583         MOV     DPH,A
   \   00097F   E0           MOVX    A,@DPTR
   \   000980   F8           MOV     R0,A
   \   000981   A3           INC     DPTR
   \   000982   E0           MOVX    A,@DPTR
   \   000983   F9           MOV     R1,A
   \   000984   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000987   E8           MOV     A,R0
   \   000988   F0           MOVX    @DPTR,A
   \   000989   A3           INC     DPTR
   \   00098A   E9           MOV     A,R1
   \   00098B   F0           MOVX    @DPTR,A
   \   00098C                ; Setup parameters for call to function memcpy
   \   00098C   75..10       MOV     ?V0 + 0,#0x10
   \   00098F   75..00       MOV     ?V0 + 1,#0x0
   \   000992   78..         MOV     R0,#?V0 + 0
   \   000994   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000997   90....       MOV     DPTR,#uip_udp_conn
   \   00099A   E0           MOVX    A,@DPTR
   \   00099B   FC           MOV     R4,A
   \   00099C   A3           INC     DPTR
   \   00099D   E0           MOVX    A,@DPTR
   \   00099E   FD           MOV     R5,A
   \   00099F   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0009A1   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0009A3   12....       LCALL   ??memcpy?relay
   \   0009A6   7402         MOV     A,#0x2
   \   0009A8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0009AB                ; Setup parameters for call to function uip_ds6_select_src
   \   0009AB   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   0009AD   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0009AF   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   0009B1   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   0009B3   12....       LCALL   ??uip_ds6_select_src?relay
   \   0009B6   90....       MOV     DPTR,#uip_appdata
   \   0009B9   74..         MOV     A,#(uip_aligned_buf + 60) & 0xff
   \   0009BB   F0           MOVX    @DPTR,A
   \   0009BC   A3           INC     DPTR
   \   0009BD   74..         MOV     A,#((uip_aligned_buf + 60) >> 8) & 0xff
   \   0009BF   F0           MOVX    @DPTR,A
   \   0009C0                ; Setup parameters for call to function uip_udpchksum
   \   0009C0   12....       LCALL   ??uip_udpchksum?relay
   \   0009C3   EA           MOV     A,R2
   \   0009C4   F4           CPL     A
   \   0009C5   F8           MOV     R0,A
   \   0009C6   EB           MOV     A,R3
   \   0009C7   F4           CPL     A
   \   0009C8   F9           MOV     R1,A
   \   0009C9   90....       MOV     DPTR,#uip_aligned_buf + 46
   \   0009CC   E8           MOV     A,R0
   \   0009CD   F0           MOVX    @DPTR,A
   \   0009CE   A3           INC     DPTR
   \   0009CF   E9           MOV     A,R1
   \   0009D0   F0           MOVX    @DPTR,A
   \   0009D1   90....       MOV     DPTR,#uip_aligned_buf + 46
   \   0009D4   E0           MOVX    A,@DPTR
   \   0009D5   F8           MOV     R0,A
   \   0009D6   A3           INC     DPTR
   \   0009D7   E0           MOVX    A,@DPTR
   \   0009D8   F9           MOV     R1,A
   \   0009D9   E8           MOV     A,R0
   \   0009DA   49           ORL     A,R1
   \   0009DB   700A         JNZ     ??uip_process_54
   \   0009DD   90....       MOV     DPTR,#uip_aligned_buf + 46
   \   0009E0   74FF         MOV     A,#-0x1
   \   0009E2   F0           MOVX    @DPTR,A
   \   0009E3   A3           INC     DPTR
   \   0009E4   74FF         MOV     A,#-0x1
   \   0009E6   F0           MOVX    @DPTR,A
   \                     ??uip_process_54:
   \   0009E7   90....       MOV     DPTR,#uip_aligned_buf
   \   0009EA   7460         MOV     A,#0x60
   \   0009EC   F0           MOVX    @DPTR,A
   \   0009ED   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   0009F0   7400         MOV     A,#0x0
   \   0009F2   F0           MOVX    @DPTR,A
   \   0009F3   90....       MOV     DPTR,#uip_aligned_buf + 2
   \   0009F6   7400         MOV     A,#0x0
   \   0009F8   F0           MOVX    @DPTR,A
   \   0009F9   A3           INC     DPTR
   \   0009FA   7400         MOV     A,#0x0
   \   0009FC   F0           MOVX    @DPTR,A
   \                     ??uip_process_8:
   \   0009FD   90....       MOV     DPTR,#uip_flags
   \   000A00   7400         MOV     A,#0x0
   \   000A02   F0           MOVX    @DPTR,A
   \   000A03   02....       LJMP    ??uip_process_5 & 0xFFFF
   2299          }
   2300          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2301          uint16_t
   2302          uip_htons(uint16_t val)
   \                     uip_htons:
   2303          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2304            return UIP_HTONS(val);
   \   000000   EA           MOV     A,R2
   \   000001   F8           MOV     R0,A
   \   000002   EB           MOV     A,R3
   \   000003   F9           MOV     R1,A
   \   000004   E4           CLR     A
   \   000005   C8           XCH     A,R0
   \   000006   F9           MOV     R1,A
   \   000007   E4           CLR     A
   \   000008   CB           XCH     A,R3
   \   000009   FA           MOV     R2,A
   \   00000A   E8           MOV     A,R0
   \   00000B   4A           ORL     A,R2
   \   00000C   FA           MOV     R2,A
   \   00000D   E9           MOV     A,R1
   \   00000E   4B           ORL     A,R3
   \   00000F   FB           MOV     R3,A
   \   000010   02....       LJMP    ?BRET
   2305          }
   2306          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2307          uint32_t
   2308          uip_htonl(uint32_t val)
   \                     uip_htonl:
   2309          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 8,R2
   \   000007   8B..         MOV     ?V0 + 9,R3
   \   000009   8C..         MOV     ?V0 + 10,R4
   \   00000B   8D..         MOV     ?V0 + 11,R5
   2310            return UIP_HTONL(val);
   \   00000D   85....       MOV     ?V0 + 4,?V0 + 8
   \   000010   85....       MOV     ?V0 + 5,?V0 + 9
   \   000013   E4           CLR     A
   \   000014   C5..         XCH     A,?V0 + 4
   \   000016   F5..         MOV     ?V0 + 5,A
   \   000018   85....       MOV     ?V0 + 0,?V0 + 8
   \   00001B   85....       MOV     ?V0 + 1,?V0 + 9
   \   00001E   E4           CLR     A
   \   00001F   C5..         XCH     A,?V0 + 1
   \   000021   F5..         MOV     ?V0 + 0,A
   \   000023   E5..         MOV     A,?V0 + 4
   \   000025   45..         ORL     A,?V0 + 0
   \   000027   F5..         MOV     ?V0 + 12,A
   \   000029   E5..         MOV     A,?V0 + 5
   \   00002B   45..         ORL     A,?V0 + 1
   \   00002D   F5..         MOV     ?V0 + 13,A
   \   00002F   E4           CLR     A
   \   000030   F5..         MOV     ?V0 + 14,A
   \   000032   F5..         MOV     ?V0 + 15,A
   \   000034   7410         MOV     A,#0x10
   \   000036   78..         MOV     R0,#?V0 + 12
   \   000038   12....       LCALL   ?L_SHL
   \   00003B   85....       MOV     ?V0 + 4,?V0 + 8
   \   00003E   85....       MOV     ?V0 + 5,?V0 + 9
   \   000041   85....       MOV     ?V0 + 6,?V0 + 10
   \   000044   85....       MOV     ?V0 + 7,?V0 + 11
   \   000047   7410         MOV     A,#0x10
   \   000049   78..         MOV     R0,#?V0 + 4
   \   00004B   12....       LCALL   ?UL_SHR
   \   00004E   E4           CLR     A
   \   00004F   C5..         XCH     A,?V0 + 4
   \   000051   F5..         MOV     ?V0 + 5,A
   \   000053   7410         MOV     A,#0x10
   \   000055   78..         MOV     R0,#?V0 + 8
   \   000057   12....       LCALL   ?UL_SHR
   \   00005A   85....       MOV     ?V0 + 0,?V0 + 8
   \   00005D   85....       MOV     ?V0 + 1,?V0 + 9
   \   000060   E4           CLR     A
   \   000061   C5..         XCH     A,?V0 + 1
   \   000063   F5..         MOV     ?V0 + 0,A
   \   000065   E5..         MOV     A,?V0 + 4
   \   000067   45..         ORL     A,?V0 + 0
   \   000069   F5..         MOV     ?V0 + 0,A
   \   00006B   E5..         MOV     A,?V0 + 5
   \   00006D   45..         ORL     A,?V0 + 1
   \   00006F   F5..         MOV     ?V0 + 1,A
   \   000071   E4           CLR     A
   \   000072   F5..         MOV     ?V0 + 2,A
   \   000074   F5..         MOV     ?V0 + 3,A
   \   000076   78..         MOV     R0,#?V0 + 12
   \   000078   79..         MOV     R1,#?V0 + 0
   \   00007A   12....       LCALL   ?L_IOR
   \   00007D   AA..         MOV     R2,?V0 + 12
   \   00007F   AB..         MOV     R3,?V0 + 13
   \   000081   AC..         MOV     R4,?V0 + 14
   \   000083   AD..         MOV     R5,?V0 + 15
   \   000085   7F10         MOV     R7,#0x10
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
   2311          }
   2312          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2313          void
   2314          uip_send(const void *data, int len)
   \                     uip_send:
   2315          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2316            int copylen;
   2317          #define MIN(a,b) ((a) < (b)? (a): (b))
   2318            copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
   2319                          (int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
   \   000004   90....       MOV     DPTR,#uip_sappdata
   \   000007   E0           MOVX    A,@DPTR
   \   000008   C3           CLR     C
   \   000009   94..         SUBB    A,#(uip_aligned_buf + 60) & 0xff
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   94..         SUBB    A,#((uip_aligned_buf + 60) >> 8) & 0xff
   \   000010   F9           MOV     R1,A
   \   000011   74B4         MOV     A,#-0x4c
   \   000013   C3           CLR     C
   \   000014   98           SUBB    A,R0
   \   000015   F8           MOV     R0,A
   \   000016   7400         MOV     A,#0x0
   \   000018   99           SUBB    A,R1
   \   000019   F9           MOV     R1,A
   \   00001A   C3           CLR     C
   \   00001B   EC           MOV     A,R4
   \   00001C   98           SUBB    A,R0
   \   00001D   ED           MOV     A,R5
   \   00001E   99           SUBB    A,R1
   \   00001F   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000021   65D0         XRL     A,PSW
   \   000023   33           RLC     A
   \   000024   5006         JNC     ??uip_send_0
   \   000026   EC           MOV     A,R4
   \   000027   F8           MOV     R0,A
   \   000028   ED           MOV     A,R5
   \   000029   F9           MOV     R1,A
   \   00002A   8016         SJMP    ??uip_send_1
   \                     ??uip_send_0:
   \   00002C   90....       MOV     DPTR,#uip_sappdata
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   C3           CLR     C
   \   000031   94..         SUBB    A,#(uip_aligned_buf + 60) & 0xff
   \   000033   F8           MOV     R0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   94..         SUBB    A,#((uip_aligned_buf + 60) >> 8) & 0xff
   \   000038   F9           MOV     R1,A
   \   000039   74B4         MOV     A,#-0x4c
   \   00003B   C3           CLR     C
   \   00003C   98           SUBB    A,R0
   \   00003D   F8           MOV     R0,A
   \   00003E   7400         MOV     A,#0x0
   \   000040   99           SUBB    A,R1
   \   000041   F9           MOV     R1,A
   2320            if(copylen > 0) {
   \                     ??uip_send_1:
   \   000042   C3           CLR     C
   \   000043   E8           MOV     A,R0
   \   000044   9401         SUBB    A,#0x1
   \   000046   E9           MOV     A,R1
   \   000047   9400         SUBB    A,#0x0
   \   000049   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00004B   65D0         XRL     A,PSW
   \   00004D   33           RLC     A
   \   00004E   4032         JC      ??uip_send_2
   2321              uip_slen = copylen;
   \   000050   90....       MOV     DPTR,#uip_slen
   \   000053   E8           MOV     A,R0
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   E9           MOV     A,R1
   \   000057   F0           MOVX    @DPTR,A
   2322              if(data != uip_sappdata) {
   \   000058   90....       MOV     DPTR,#uip_sappdata
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   EA           MOV     A,R2
   \   000061   68           XRL     A,R0
   \   000062   7002         JNZ     ??uip_send_3
   \   000064   EB           MOV     A,R3
   \   000065   69           XRL     A,R1
   \                     ??uip_send_3:
   \   000066   601A         JZ      ??uip_send_2
   2323                memcpy(uip_sappdata, (data), uip_slen);
   \   000068                ; Setup parameters for call to function memcpy
   \   000068   90....       MOV     DPTR,#uip_slen
   \   00006B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00006E   EA           MOV     A,R2
   \   00006F   FC           MOV     R4,A
   \   000070   EB           MOV     A,R3
   \   000071   FD           MOV     R5,A
   \   000072   90....       MOV     DPTR,#uip_sappdata
   \   000075   E0           MOVX    A,@DPTR
   \   000076   FA           MOV     R2,A
   \   000077   A3           INC     DPTR
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FB           MOV     R3,A
   \   00007A   12....       LCALL   ??memcpy?relay
   \   00007D   7402         MOV     A,#0x2
   \   00007F   12....       LCALL   ?DEALLOC_XSTACK8
   2324              }
   2325            }
   2326          }
   \                     ??uip_send_2:
   \   000082   D083         POP     DPH
   \   000084   D082         POP     DPL
   \   000086   02....       LJMP    ?BRET

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_28:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_28>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_28>`:
   \   000000   28000000     DD 40

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_500:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_500>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_500>`:
   \   000000   00050000     DD 1280

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_0:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_0>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_0>`:
   \   000000   00000000     DD 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??chksum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    chksum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_chksum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_chksum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_ipchksum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_ipchksum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??upper_layer_chksum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    upper_layer_chksum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_icmp6chksum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_icmp6chksum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_udpchksum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_udpchksum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??remove_ext_hdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    remove_ext_hdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_udp_new?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_udp_new

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ext_hdr_options_process?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ext_hdr_options_process

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_process?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_process

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_htons?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_htons

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_htonl?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_htonl

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_send
   2327          /*---------------------------------------------------------------------------*/
   2328          /** @} */
   2329          #endif /* UIP_CONF_IPV6 */

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     24  chksum
       0      0     32  ext_hdr_options_process
                          0 0 20 -> uip_icmp6_error_output
       2      0     24  remove_ext_hdr
                          0 0 12 -> memmove
       0      0     12  uip_chksum
                          0 0 12 -> chksum
                          0 0 10 -> uip_htons
       0      0     24  uip_htonl
       0      0     14  uip_htons
       2      0     12  uip_icmp6chksum
                          2 0  0 -> upper_layer_chksum
       2      0      0  uip_init
                          2 0  0 -> uip_ds6_init
       0      0     12  uip_ipchksum
                          0 0 12 -> chksum
                          0 0 10 -> uip_htons
       2      0     16  uip_process
                          0 0 12 -> ext_hdr_options_process
                          0 0 14 -> memcmp
                          0 0 14 -> memcpy
                          0 0 12 -> remove_ext_hdr
                          0 0 12 -> tcpip_uipcall
                          0 0 12 -> uip_ds6_addr_lookup
                          0 0 12 -> uip_ds6_is_addr_onlink
                          0 0 12 -> uip_ds6_maddr_lookup
                          0 0 12 -> uip_ds6_select_src
                          0 0 12 -> uip_icmp6_echo_request_input
                          0 0 16 -> uip_icmp6_error_output
                          0 0 12 -> uip_icmp6chksum
                          0 0 12 -> uip_nd6_na_input
                          0 0 12 -> uip_nd6_ns_input
                          0 0 12 -> uip_udpchksum
       2      0      2  uip_send
                          2 0  2 -> memcpy
       2      0     16  uip_udp_new
                          0 0 16 -> memcpy
                          0 0 16 -> memset
                          2 0 14 -> uip_htons
       2      0     12  uip_udpchksum
                          2 0  0 -> upper_layer_chksum
       0      0     14  upper_layer_chksum
                          0 0 14 -> chksum
                          0 0 12 -> uip_htons


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Initializer for __Constant_0>
       4  ?<Initializer for __Constant_28>
       4  ?<Initializer for __Constant_500>
       6  ??chksum?relay
       6  ??ext_hdr_options_process?relay
       6  ??remove_ext_hdr?relay
       6  ??uip_chksum?relay
       6  ??uip_htonl?relay
       6  ??uip_htons?relay
       6  ??uip_icmp6chksum?relay
       6  ??uip_init?relay
       6  ??uip_ipchksum?relay
       6  ??uip_process?relay
       6  ??uip_send?relay
       6  ??uip_udp_new?relay
       6  ??uip_udpchksum?relay
       6  ??upper_layer_chksum?relay
       4  __Constant_0
       4  __Constant_28
       4  __Constant_500
       1  c
     150  chksum
     428  ext_hdr_options_process
       2  lastport
     199  remove_ext_hdr
     240  uip_aligned_buf
       2  uip_appdata
      38  uip_chksum
       2  uip_conn
       1  uip_ext_bitmap
       1  uip_ext_len
       1  uip_ext_opt_offset
       1  uip_flags
     138  uip_htonl
      19  uip_htons
      16  uip_icmp6chksum
      93  uip_init
      66  uip_ipchksum
       2  uip_len
       8  uip_lladdr
       2  uip_next_hdr
    2566  uip_process
       2  uip_sappdata
     137  uip_send
       2  uip_slen
       2  uip_udp_conn
     250  uip_udp_conns
     421  uip_udp_new
      16  uip_udpchksum
     182  upper_layer_chksum

 
 4 469 bytes in segment BANKED_CODE
    84 bytes in segment BANK_RELAYS
    12 bytes in segment XDATA_I
    12 bytes in segment XDATA_ID
   519 bytes in segment XDATA_Z
 
 4 553 bytes of CODE  memory (+ 12 bytes shared)
   519 bytes of XDATA memory (+ 12 bytes shared)

Errors: none
Warnings: none
