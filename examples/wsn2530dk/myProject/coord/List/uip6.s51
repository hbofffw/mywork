///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.20.2.41139 for 8051            03/Apr/2014  10:45:55 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  D:\myWork\myWork\core\net\uip6.c                  /
//    Command line       =  D:\myWork\myWork\core\net\uip6.c -D               /
//                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC            /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\List\ -lA D:\myWork\myWork\examples\wsn2530dk\ /
//                          myProject\coord\List\ --diag_suppress             /
//                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o         /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\Obj\ -e --no_cse --no_unroll --no_inline       /
//                          --no_code_motion --no_tbaa --debug --core=plain   /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data --nr_virtual_regs  /
//                          16 --preinclude D:\myWork\myWork\examples\wsn2530 /
//                          dk\myProject\..\..\..\cpu\cc253x\cc253x.h -I      /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\ /
//                          ..\..\cpu\cc253x\ -I D:\myWork\myWork\examples\ws /
//                          n2530dk\myProject\..\..\..\platform\wsn2530dk\    /
//                          -I D:\myWork\myWork\examples\wsn2530dk\myProject\ /
//                          ..\..\..\core\ -I D:\myWork\myWork\examples\wsn25 /
//                          30dk\myProject\..\..\..\apps\ -I                  /
//                          D:\myWork\myWork\examples\wsn2530dk\myProject\    /
//                          -Ol                                               /
//    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coo /
//                          rd\List\uip6.s51                                  /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME uip6

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?L_ADD
        EXTERN ?L_ADD_X
        EXTERN ?L_IOR
        EXTERN ?L_SHL
        EXTERN ?PUSH_XSTACK8_X_FOUR
        EXTERN ?PUSH_XSTACK8_X_TWO
        EXTERN ?PUSH_XSTACK_I_FOUR
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?S_SHL
        EXTERN ?UL_SHR
        EXTERN ?V0
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN __INIT_XDATA_I
        EXTERN __INIT_XDATA_Z

        FUNCTION ??chksum?relay,0203H
        FUNCTION ??ext_hdr_options_process?relay,0203H
        PUBLIC ??remove_ext_hdr?relay
        FUNCTION ??remove_ext_hdr?relay,0203H
        PUBLIC ??uip_chksum?relay
        FUNCTION ??uip_chksum?relay,0203H
        PUBLIC ??uip_htonl?relay
        FUNCTION ??uip_htonl?relay,0203H
        PUBLIC ??uip_htons?relay
        FUNCTION ??uip_htons?relay,0203H
        PUBLIC ??uip_icmp6chksum?relay
        FUNCTION ??uip_icmp6chksum?relay,0203H
        PUBLIC ??uip_init?relay
        FUNCTION ??uip_init?relay,0203H
        PUBLIC ??uip_ipchksum?relay
        FUNCTION ??uip_ipchksum?relay,0203H
        PUBLIC ??uip_process?relay
        FUNCTION ??uip_process?relay,0203H
        PUBLIC ??uip_send?relay
        FUNCTION ??uip_send?relay,0203H
        PUBLIC ??uip_udp_new?relay
        FUNCTION ??uip_udp_new?relay,0203H
        PUBLIC ??uip_udpchksum?relay
        FUNCTION ??uip_udpchksum?relay,0203H
        FUNCTION ??upper_layer_chksum?relay,0203H
        PUBWEAK __Constant_0
        PUBWEAK __Constant_28
        PUBWEAK __Constant_500
        FUNCTION chksum,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 10, STACK
        FUNCTION ext_hdr_options_process,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 20, STACK
        PUBLIC remove_ext_hdr
        FUNCTION remove_ext_hdr,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC uip_aligned_buf
        PUBLIC uip_appdata
        PUBLIC uip_chksum
        FUNCTION uip_chksum,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC uip_conn
        PUBLIC uip_ext_bitmap
        PUBLIC uip_ext_len
        PUBLIC uip_ext_opt_offset
        PUBLIC uip_flags
        PUBLIC uip_htonl
        FUNCTION uip_htonl,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 24, STACK
        PUBLIC uip_htons
        FUNCTION uip_htons,0203H
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUBLIC uip_icmp6chksum
        FUNCTION uip_icmp6chksum,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        PUBLIC uip_init
        FUNCTION uip_init,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC uip_ipchksum
        FUNCTION uip_ipchksum,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC uip_len
        PUBLIC uip_lladdr
        PUBLIC uip_next_hdr
        PUBLIC uip_process
        FUNCTION uip_process,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC uip_sappdata
        PUBLIC uip_send
        FUNCTION uip_send,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 2, STACK
        PUBLIC uip_slen
        PUBLIC uip_udp_conn
        PUBLIC uip_udp_conns
        PUBLIC uip_udp_new
        FUNCTION uip_udp_new,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 16, STACK
        PUBLIC uip_udpchksum
        FUNCTION uip_udpchksum,021203H
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 2, STACK
        FUNCTION upper_layer_chksum,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 14, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
          CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI V8 SameValue
          CFI V9 SameValue
          CFI V10 SameValue
          CFI V11 SameValue
          CFI V12 SameValue
          CFI V13 SameValue
          CFI V14 SameValue
          CFI V15 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
memcmp              SYMBOL "memcmp"
??memcmp?relay      SYMBOL "?relay", memcmp
memcpy              SYMBOL "memcpy"
??memcpy?relay      SYMBOL "?relay", memcpy
memmove             SYMBOL "memmove"
??memmove?relay     SYMBOL "?relay", memmove
memset              SYMBOL "memset"
??memset?relay      SYMBOL "?relay", memset
tcpip_uipcall       SYMBOL "tcpip_uipcall"
??tcpip_uipcall?relay SYMBOL "?relay", tcpip_uipcall
uip_ds6_addr_lookup SYMBOL "uip_ds6_addr_lookup"
??uip_ds6_addr_lookup?relay SYMBOL "?relay", uip_ds6_addr_lookup
uip_ds6_init        SYMBOL "uip_ds6_init"
??uip_ds6_init?relay SYMBOL "?relay", uip_ds6_init
uip_ds6_is_addr_onlink SYMBOL "uip_ds6_is_addr_onlink"
??uip_ds6_is_addr_onlink?relay SYMBOL "?relay", uip_ds6_is_addr_onlink
uip_ds6_maddr_lookup SYMBOL "uip_ds6_maddr_lookup"
??uip_ds6_maddr_lookup?relay SYMBOL "?relay", uip_ds6_maddr_lookup
uip_ds6_select_src  SYMBOL "uip_ds6_select_src"
??uip_ds6_select_src?relay SYMBOL "?relay", uip_ds6_select_src
uip_icmp6_echo_request_input SYMBOL "uip_icmp6_echo_request_input"
??uip_icmp6_echo_request_input?relay SYMBOL "?relay", uip_icmp6_echo_request_input
uip_icmp6_error_output SYMBOL "uip_icmp6_error_output"
??uip_icmp6_error_output?relay SYMBOL "?relay", uip_icmp6_error_output
uip_nd6_na_input    SYMBOL "uip_nd6_na_input"
??uip_nd6_na_input?relay SYMBOL "?relay", uip_nd6_na_input
uip_nd6_ns_input    SYMBOL "uip_nd6_ns_input"
??uip_nd6_ns_input?relay SYMBOL "?relay", uip_nd6_ns_input
remove_ext_hdr      SYMBOL "remove_ext_hdr"
??remove_ext_hdr?relay SYMBOL "?relay", remove_ext_hdr
uip_chksum          SYMBOL "uip_chksum"
??uip_chksum?relay  SYMBOL "?relay", uip_chksum
uip_htonl           SYMBOL "uip_htonl"
??uip_htonl?relay   SYMBOL "?relay", uip_htonl
uip_htons           SYMBOL "uip_htons"
??uip_htons?relay   SYMBOL "?relay", uip_htons
uip_icmp6chksum     SYMBOL "uip_icmp6chksum"
??uip_icmp6chksum?relay SYMBOL "?relay", uip_icmp6chksum
uip_init            SYMBOL "uip_init"
??uip_init?relay    SYMBOL "?relay", uip_init
uip_ipchksum        SYMBOL "uip_ipchksum"
??uip_ipchksum?relay SYMBOL "?relay", uip_ipchksum
uip_process         SYMBOL "uip_process"
??uip_process?relay SYMBOL "?relay", uip_process
uip_send            SYMBOL "uip_send"
??uip_send?relay    SYMBOL "?relay", uip_send
uip_udp_new         SYMBOL "uip_udp_new"
??uip_udp_new?relay SYMBOL "?relay", uip_udp_new
uip_udpchksum       SYMBOL "uip_udpchksum"
??uip_udpchksum?relay SYMBOL "?relay", uip_udpchksum

        EXTERN ??memcmp?relay
        FUNCTION ??memcmp?relay,00H
        EXTERN ??memcpy?relay
        FUNCTION ??memcpy?relay,00H
        EXTERN ??memmove?relay
        FUNCTION ??memmove?relay,00H
        EXTERN ??memset?relay
        FUNCTION ??memset?relay,00H
        EXTERN ??tcpip_uipcall?relay
        FUNCTION ??tcpip_uipcall?relay,00H
        EXTERN ??uip_ds6_addr_lookup?relay
        FUNCTION ??uip_ds6_addr_lookup?relay,00H
        EXTERN ??uip_ds6_init?relay
        FUNCTION ??uip_ds6_init?relay,00H
        EXTERN ??uip_ds6_is_addr_onlink?relay
        FUNCTION ??uip_ds6_is_addr_onlink?relay,00H
        EXTERN ??uip_ds6_maddr_lookup?relay
        FUNCTION ??uip_ds6_maddr_lookup?relay,00H
        EXTERN ??uip_ds6_select_src?relay
        FUNCTION ??uip_ds6_select_src?relay,00H
        EXTERN ??uip_icmp6_echo_request_input?relay
        FUNCTION ??uip_icmp6_echo_request_input?relay,00H
        EXTERN ??uip_icmp6_error_output?relay
        FUNCTION ??uip_icmp6_error_output?relay,00H
        EXTERN ??uip_nd6_na_input?relay
        FUNCTION ??uip_nd6_na_input?relay,00H
        EXTERN ??uip_nd6_ns_input?relay
        FUNCTION ??uip_nd6_ns_input?relay,00H
        EXTERN memcmp
        FUNCTION memcmp,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memcpy
        FUNCTION memcpy,010202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memmove
        FUNCTION memmove,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN memset
        FUNCTION memset,010202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN tcpip_uipcall
        FUNCTION tcpip_uipcall,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_ds6_addr_lookup
        FUNCTION uip_ds6_addr_lookup,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_ds6_if
        EXTERN uip_ds6_init
        FUNCTION uip_ds6_init,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_ds6_is_addr_onlink
        FUNCTION uip_ds6_is_addr_onlink,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_ds6_maddr_lookup
        FUNCTION uip_ds6_maddr_lookup,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_ds6_select_src
        FUNCTION uip_ds6_select_src,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_icmp6_echo_request_input
        FUNCTION uip_icmp6_echo_request_input,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_icmp6_error_output
        FUNCTION uip_icmp6_error_output,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_nd6_na_input
        FUNCTION uip_nd6_na_input,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN uip_nd6_ns_input
        FUNCTION uip_nd6_ns_input,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// D:\myWork\myWork\core\net\uip6.c
//    1 /**
//    2  * \addtogroup uip6
//    3  * @{
//    4  */
//    5 
//    6 /**
//    7  * \file
//    8  *         The uIP TCP/IPv6 stack code.
//    9  *
//   10  * \author Adam Dunkels <adam@sics.se>
//   11  * \author Julien Abeille <jabeille@cisco.com> (IPv6 related code)
//   12  * \author Mathilde Durvy <mdurvy@cisco.com> (IPv6 related code)
//   13  */
//   14 /*
//   15  * Copyright (c) 2001-2003, Adam Dunkels.
//   16  * All rights reserved.
//   17  *
//   18  * Redistribution and use in source and binary forms, with or without
//   19  * modification, are permitted provided that the following conditions
//   20  * are met:
//   21  * 1. Redistributions of source code must retain the above copyright
//   22  *    notice, this list of conditions and the following disclaimer.
//   23  * 2. Redistributions in binary form must reproduce the above copyright
//   24  *    notice, this list of conditions and the following disclaimer in the
//   25  *    documentation and/or other materials provided with the distribution.
//   26  * 3. The name of the author may not be used to endorse or promote
//   27  *    products derived from this software without specific prior
//   28  *    written permission.
//   29  *
//   30  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
//   31  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
//   32  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
//   33  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//   34  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   35  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
//   36  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//   37  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//   38  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//   39  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
//   40  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   41  *
//   42  * This file is part of the uIP TCP/IP stack.
//   43  *
//   44  *
//   45  */
//   46 
//   47 /*
//   48  * uIP is a small implementation of the IP, UDP and TCP protocols (as
//   49  * well as some basic ICMP stuff). The implementation couples the IP,
//   50  * UDP, TCP and the application layers very tightly. To keep the size
//   51  * of the compiled code down, this code frequently uses the goto
//   52  * statement. While it would be possible to break the uip_process()
//   53  * function into many smaller functions, this would increase the code
//   54  * size because of the overhead of parameter passing and the fact that
//   55  * the optimizer would not be as efficient.
//   56  *
//   57  * The principle is that we have a small buffer, called the uip_buf,
//   58  * in which the device driver puts an incoming packet. The TCP/IP
//   59  * stack parses the headers in the packet, and calls the
//   60  * application. If the remote host has sent data to the application,
//   61  * this data is present in the uip_buf and the application read the
//   62  * data from there. It is up to the application to put this data into
//   63  * a byte stream if needed. The application will not be fed with data
//   64  * that is out of sequence.
//   65  *
//   66  * If the application wishes to send data to the peer, it should put
//   67  * its data into the uip_buf. The uip_appdata pointer points to the
//   68  * first available byte. The TCP/IP stack will calculate the
//   69  * checksums, and fill in the necessary header fields and finally send
//   70  * the packet back to the peer.
//   71  */
//   72 
//   73 #include "net/uip.h"
//   74 #include "net/uipopt.h"
//   75 #include "net/uip-icmp6.h"
//   76 #include "net/uip-nd6.h"
//   77 #include "net/uip-ds6.h"
//   78 
//   79 #include <string.h>
//   80 
//   81 #if UIP_CONF_IPV6
//   82 /*---------------------------------------------------------------------------*/
//   83 /* For Debug, logging, statistics                                            */
//   84 /*---------------------------------------------------------------------------*/
//   85 
//   86 #define DEBUG DEBUG_NONE
//   87 #include "net/uip-debug.h"
//   88 
//   89 #if UIP_CONF_IPV6_RPL
//   90 #include "rpl/rpl.h"
//   91 #endif /* UIP_CONF_IPV6_RPL */
//   92 
//   93 #if UIP_LOGGING == 1
//   94 #include <stdio.h>
//   95 void uip_log(char *msg);
//   96 #define UIP_LOG(m) uip_log(m)
//   97 #else
//   98 #define UIP_LOG(m)
//   99 #endif /* UIP_LOGGING == 1 */
//  100 
//  101 #if UIP_STATISTICS == 1
//  102 struct uip_stats uip_stat;
//  103 #endif /* UIP_STATISTICS == 1 */
//  104  
//  105 
//  106 /*---------------------------------------------------------------------------*/
//  107 /** @{ \name Layer 2 variables */
//  108 /*---------------------------------------------------------------------------*/
//  109 /** Host L2 address */
//  110 #if UIP_CONF_LL_802154

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  111 uip_lladdr_t uip_lladdr;
uip_lladdr:
        DS 8
        REQUIRE __INIT_XDATA_Z
//  112 #else /*UIP_CONF_LL_802154*/
//  113 uip_lladdr_t uip_lladdr = {{0x00,0x06,0x98,0x00,0x02,0x32}};
//  114 #endif /*UIP_CONF_LL_802154*/
//  115 /** @} */
//  116 
//  117 /*---------------------------------------------------------------------------*/
//  118 /** @{ \name Layer 3 variables */
//  119 /*---------------------------------------------------------------------------*/
//  120 /**
//  121  * \brief Type of the next header in IPv6 header or extension headers
//  122  *
//  123  * Can be the next header field in the IPv6 header or in an extension header.
//  124  * When doing fragment reassembly, we must change the value of the next header
//  125  * field in the header before the fragmentation header, hence we need a pointer
//  126  * to this field.
//  127  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  128 uint8_t *uip_next_hdr;
uip_next_hdr:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  129 /** \brief bitmap we use to record which IPv6 headers we have already seen */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  130 uint8_t uip_ext_bitmap = 0;
uip_ext_bitmap:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  131 /**
//  132  * \brief length of the extension headers read. updated each time we process
//  133  * a header
//  134  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  135 uint8_t uip_ext_len = 0;
uip_ext_len:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  136 /** \brief length of the header options read */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  137 uint8_t uip_ext_opt_offset = 0;
uip_ext_opt_offset:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  138 /** @} */
//  139 
//  140 /*---------------------------------------------------------------------------*/
//  141 /* Buffers                                                                   */
//  142 /*---------------------------------------------------------------------------*/
//  143 /** \name Buffer defines
//  144  *  @{
//  145  */
//  146 #define FBUF                             ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
//  147 #define UIP_IP_BUF                          ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
//  148 #define UIP_ICMP_BUF                      ((struct uip_icmp_hdr *)&uip_buf[uip_l2_l3_hdr_len])
//  149 #define UIP_UDP_BUF                        ((struct uip_udp_hdr *)&uip_buf[UIP_LLH_LEN + UIP_IPH_LEN])
//  150 #define UIP_TCP_BUF                        ((struct uip_tcp_hdr *)&uip_buf[UIP_LLH_LEN + UIP_IPH_LEN])
//  151 #define UIP_EXT_BUF                        ((struct uip_ext_hdr *)&uip_buf[uip_l2_l3_hdr_len])
//  152 #define UIP_ROUTING_BUF                ((struct uip_routing_hdr *)&uip_buf[uip_l2_l3_hdr_len])
//  153 #define UIP_FRAG_BUF                      ((struct uip_frag_hdr *)&uip_buf[uip_l2_l3_hdr_len])
//  154 #define UIP_HBHO_BUF                      ((struct uip_hbho_hdr *)&uip_buf[uip_l2_l3_hdr_len])
//  155 #define UIP_DESTO_BUF                    ((struct uip_desto_hdr *)&uip_buf[uip_l2_l3_hdr_len])
//  156 #define UIP_EXT_HDR_OPT_BUF            ((struct uip_ext_hdr_opt *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
//  157 #define UIP_EXT_HDR_OPT_PADN_BUF  ((struct uip_ext_hdr_opt_padn *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
//  158 #if UIP_CONF_IPV6_RPL
//  159 #define UIP_EXT_HDR_OPT_RPL_BUF    ((struct uip_ext_hdr_opt_rpl *)&uip_buf[uip_l2_l3_hdr_len + uip_ext_opt_offset])
//  160 #endif /* UIP_CONF_IPV6_RPL */
//  161 #define UIP_ICMP6_ERROR_BUF            ((struct uip_icmp6_error *)&uip_buf[uip_l2_l3_icmp_hdr_len])
//  162 /** @} */
//  163 /** \name Buffer variables
//  164  *  @{
//  165  */
//  166 /** Packet buffer for incoming and outgoing packets */
//  167 #ifndef UIP_CONF_EXTERNAL_BUFFER

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  168 uip_buf_t uip_aligned_buf;
uip_aligned_buf:
        DS 240
        REQUIRE __INIT_XDATA_Z
//  169 #endif /* UIP_CONF_EXTERNAL_BUFFER */
//  170 
//  171 /* The uip_appdata pointer points to application data. */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  172 void *uip_appdata;
uip_appdata:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  173 /* The uip_appdata pointer points to the application data which is to be sent*/

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  174 void *uip_sappdata;
uip_sappdata:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  175 
//  176 #if UIP_URGDATA > 0
//  177 /* The uip_urgdata pointer points to urgent data (out-of-band data), if present */
//  178 void *uip_urgdata;
//  179 uint16_t uip_urglen, uip_surglen;
//  180 #endif /* UIP_URGDATA > 0 */
//  181 
//  182 /* The uip_len is either 8 or 16 bits, depending on the maximum packet size.*/

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  183 uint16_t uip_len, uip_slen;
uip_len:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
uip_slen:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  184 /** @} */
//  185 
//  186 /*---------------------------------------------------------------------------*/
//  187 /** @{ \name General variables                                               */
//  188 /*---------------------------------------------------------------------------*/
//  189 
//  190 /* The uip_flags variable is used for communication between the TCP/IP stack
//  191 and the application program. */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  192 uint8_t uip_flags;
uip_flags:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  193 
//  194 /* uip_conn always points to the current connection (set to NULL for UDP). */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  195 struct uip_conn *uip_conn;
uip_conn:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  196 
//  197 /* Temporary variables. */
//  198 #if (UIP_TCP || UIP_UDP)

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  199 static uint8_t c;
`c`:
        DS 1
        REQUIRE __INIT_XDATA_Z
//  200 #endif
//  201 
//  202 #if UIP_ACTIVE_OPEN || UIP_UDP
//  203 /* Keeps track of the last port used for a new connection. */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  204 static uint16_t lastport;
lastport:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  205 #endif /* UIP_ACTIVE_OPEN || UIP_UDP */
//  206 /** @} */
//  207 
//  208 /*---------------------------------------------------------------------------*/
//  209 /* TCP                                                                       */
//  210 /*---------------------------------------------------------------------------*/
//  211 /** \name TCP defines
//  212  *@{
//  213  */
//  214 /* Structures and definitions. */
//  215 #define TCP_FIN 0x01
//  216 #define TCP_SYN 0x02
//  217 #define TCP_RST 0x04
//  218 #define TCP_PSH 0x08
//  219 #define TCP_ACK 0x10
//  220 #define TCP_URG 0x20
//  221 #define TCP_CTL 0x3f
//  222 
//  223 #define TCP_OPT_END     0   /* End of TCP options list */
//  224 #define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
//  225 #define TCP_OPT_MSS     2   /* Maximum segment size TCP option */
//  226 
//  227 #define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */
//  228 /** @} */
//  229 /** \name TCP variables
//  230  *@{
//  231  */
//  232 #if UIP_TCP
//  233 /* The uip_conns array holds all TCP connections. */
//  234 struct uip_conn uip_conns[UIP_CONNS];
//  235 
//  236 /* The uip_listenports list all currently listning ports. */
//  237 uint16_t uip_listenports[UIP_LISTENPORTS];
//  238 
//  239 /* The iss variable is used for the TCP initial sequence number. */
//  240 static uint8_t iss[4];
//  241 
//  242 /* Temporary variables. */
//  243 uint8_t uip_acc32[4];
//  244 static uint8_t opt;
//  245 static uint16_t tmp16;
//  246 #endif /* UIP_TCP */
//  247 /** @} */
//  248 
//  249 /*---------------------------------------------------------------------------*/
//  250 /** @{ \name UDP variables                                                   */
//  251 /*---------------------------------------------------------------------------*/
//  252 #if UIP_UDP

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
//  253 struct uip_udp_conn *uip_udp_conn;
uip_udp_conn:
        DS 2
        REQUIRE __INIT_XDATA_Z

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//  254 struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
uip_udp_conns:
        DS 250
        REQUIRE __INIT_XDATA_Z
//  255 #endif /* UIP_UDP */
//  256 /** @} */
//  257 
//  258 /*---------------------------------------------------------------------------*/
//  259 /** @{ \name ICMPv6 variables                                                */
//  260 /*---------------------------------------------------------------------------*/
//  261 #if UIP_CONF_ICMP6
//  262 /** single possible icmpv6 "connection" */
//  263 struct uip_icmp6_conn uip_icmp6_conns;
//  264 #endif /*UIP_CONF_ICMP6*/
//  265 /** @} */
//  266 
//  267 /*---------------------------------------------------------------------------*/
//  268 /* Functions                                                                 */
//  269 /*---------------------------------------------------------------------------*/
//  270 #if (!UIP_ARCH_ADD32 && UIP_TCP)
//  271 void
//  272 uip_add32(uint8_t *op32, uint16_t op16)
//  273 {
//  274   uip_acc32[3] = op32[3] + (op16 & 0xff);
//  275   uip_acc32[2] = op32[2] + (op16 >> 8);
//  276   uip_acc32[1] = op32[1];
//  277   uip_acc32[0] = op32[0];
//  278   
//  279   if(uip_acc32[2] < (op16 >> 8)) {
//  280     ++uip_acc32[1];
//  281     if(uip_acc32[1] == 0) {
//  282       ++uip_acc32[0];
//  283     }
//  284   }
//  285   
//  286   
//  287   if(uip_acc32[3] < (op16 & 0xff)) {
//  288     ++uip_acc32[2];
//  289     if(uip_acc32[2] == 0) {
//  290       ++uip_acc32[1];
//  291       if(uip_acc32[1] == 0) {
//  292         ++uip_acc32[0];
//  293       }
//  294     }
//  295   }
//  296 }
//  297 
//  298 #endif /* UIP_ARCH_ADD32 && UIP_TCP */
//  299 
//  300 #if ! UIP_ARCH_CHKSUM
//  301 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  302 static uint16_t
//  303 chksum(uint16_t sum, const uint8_t *data, uint16_t len)
chksum:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function chksum
        CODE
//  304 {
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,#0xa
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     R6,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R7,A
//  305   uint16_t t;
//  306   const uint8_t *dataptr;
//  307   const uint8_t *last_byte;
//  308 
//  309   dataptr = data;
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
//  310   last_byte = data + len - 1;
        MOV     A,R4
        ADD     A,R6
        MOV     R4,A
        MOV     A,R5
        ADDC    A,R7
        MOV     R5,A
        MOV     A,R4
        ADD     A,#-0x1
        MOV     R6,A
        MOV     A,R5
        ADDC    A,#-0x1
        MOV     R7,A
        SJMP    ??chksum_0
//  311   
//  312   while(dataptr < last_byte) {   /* At least two more bytes */
//  313     t = (dataptr[0] << 8) + dataptr[1];
??chksum_1:
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     R5,#0x0
        CLR     A
        XCH     A,R4
        MOV     R5,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,#0x0
        MOV     A,R4
        ADD     A,?V0 + 0
        MOV     R4,A
        MOV     A,R5
        ADDC    A,?V0 + 1
        MOV     R5,A
//  314     sum += t;
        MOV     A,R2
        ADD     A,R4
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R5
        MOV     R3,A
//  315     if(sum < t) {
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JNC     ??chksum_2
//  316       sum++;      /* carry */
        MOV     A,R2
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R3,A
//  317     }
//  318     dataptr += 2;
??chksum_2:
        MOV     A,R0
        ADD     A,#0x2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
//  319   }
??chksum_0:
        MOV     A,R6
        MOV     R4,A
        MOV     A,R7
        MOV     R5,A
        CLR     C
        MOV     A,R0
        SUBB    A,R4
        MOV     A,R1
        SUBB    A,R5
        JC      ??chksum_1
//  320   
//  321   if(dataptr == last_byte) {
        MOV     A,R6
        XRL     A,R0
        JNZ     ??chksum_3
        MOV     A,R7
        XRL     A,R1
??chksum_3:
        JNZ     ??chksum_4
//  322     t = (dataptr[0] << 8) + 0;
        MOV     DPL,R0
        MOV     DPH,R1
        MOVX    A,@DPTR
        MOV     R4,A
        MOV     R5,#0x0
        CLR     A
        XCH     A,R4
        MOV     R5,A
//  323     sum += t;
        MOV     A,R2
        ADD     A,R4
        MOV     R2,A
        MOV     A,R3
        ADDC    A,R5
        MOV     R3,A
//  324     if(sum < t) {
        CLR     C
        MOV     A,R2
        SUBB    A,R4
        MOV     A,R3
        SUBB    A,R5
        JNC     ??chksum_4
//  325       sum++;      /* carry */
        MOV     A,R2
        ADD     A,#0x1
        MOV     R2,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R3,A
//  326     }
//  327   }
//  328 
//  329   /* Return sum in host byte order. */
//  330   return sum;
??chksum_4:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock0
//  331 }
//  332 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  333 uint16_t
//  334 uip_chksum(uint16_t *data, uint16_t len)
uip_chksum:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function uip_chksum
        CODE
//  335 {
        FUNCALL uip_chksum, chksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_chksum, uip_htons
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  336   return uip_htons(chksum(0, (uint8_t *)data, len));
        ; Setup parameters for call to function uip_htons
        ; Setup parameters for call to function chksum
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??chksum?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        LCALL   ??uip_htons?relay
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock1
//  337 }
//  338 /*---------------------------------------------------------------------------*/
//  339 #ifndef UIP_ARCH_IPCHKSUM

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  340 uint16_t
//  341 uip_ipchksum(void)
uip_ipchksum:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function uip_ipchksum
        CODE
//  342 {
        FUNCALL uip_ipchksum, chksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_ipchksum, uip_htons
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  343   uint16_t sum;
//  344 
//  345   sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
        ; Setup parameters for call to function chksum
        MOV     ?V0 + 0,#0x28
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     R4,#uip_aligned_buf & 0xff
        MOV     R5,#(uip_aligned_buf >> 8) & 0xff
        MOV     R2,#0x0
        MOV     R3,#0x0
        LCALL   ??chksum?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
//  346   PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
//  347   return (sum == 0) ? 0xffff : uip_htons(sum);
        MOV     A,R2
        ORL     A,R3
        JNZ     ??uip_ipchksum_0
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??uip_ipchksum_1
??uip_ipchksum_0:
        ; Setup parameters for call to function uip_htons
        LCALL   ??uip_htons?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
??uip_ipchksum_1:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock2
//  348 }
//  349 #endif
//  350 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  351 static uint16_t
//  352 upper_layer_chksum(uint8_t proto)
upper_layer_chksum:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function upper_layer_chksum
        CODE
//  353 {
        FUNCALL upper_layer_chksum, chksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL upper_layer_chksum, chksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL upper_layer_chksum, uip_htons
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 2
        MOV     A,#-0x2
        LCALL   ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     A,R1
        MOV     R6,A
//  354 /* gcc 4.4.0 - 4.6.1 (maybe 4.3...) with -Os on 8 bit CPUS incorrectly compiles:
//  355  * int bar (int);
//  356  * int foo (unsigned char a, unsigned char b) {
//  357  *   int len = (a << 8) + b; //len becomes 0xff00&<random>+b
//  358  *   return len + bar (len);
//  359  * }
//  360  * upper_layer_len triggers this bug unless it is declared volatile.
//  361  * See https://sourceforge.net/apps/mantisbt/contiki/view.php?id=3
//  362  */
//  363   volatile uint16_t upper_layer_len;
//  364   uint16_t sum;
//  365   
//  366   upper_layer_len = (((uint16_t)(UIP_IP_BUF->len[0]) << 8) + UIP_IP_BUF->len[1] - uip_ext_len);
        MOV     DPTR,#uip_aligned_buf + 4
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        CLR     C
        SUBB    A,R2
        MOV     R0,A
        MOV     A,R1
        SUBB    A,R3
        MOV     R1,A
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  367   
//  368   PRINTF("Upper layer checksum len: %d from: %d\n", upper_layer_len,
//  369 	 UIP_IPH_LEN + UIP_LLH_LEN + uip_ext_len);
//  370 
//  371   /* First sum pseudoheader. */
//  372   /* IP protocol and length fields. This addition cannot carry. */
//  373   sum = upper_layer_len + proto;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     ?V0 + 0,R6
        MOV     ?V0 + 1,#0x0
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        MOV     R3,A
//  374   /* Sum IP source and destination addresses. */
//  375   sum = chksum(sum, (uint8_t *)&UIP_IP_BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
        ; Setup parameters for call to function chksum
        MOV     ?V0 + 0,#0x20
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     R4,#(uip_aligned_buf + 8) & 0xff
        MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??chksum?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
//  376 
//  377   /* Sum TCP header and data. */
//  378   sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN + uip_ext_len],
//  379                upper_layer_len);
        ; Setup parameters for call to function chksum
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#(uip_aligned_buf + 40) & 0xff
        ADD     A,R0
        MOV     R4,A
        MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
        ADDC    A,R1
        MOV     R5,A
        LCALL   ??chksum?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
//  380     
//  381   return (sum == 0) ? 0xffff : uip_htons(sum);
        MOV     A,R2
        ORL     A,R3
        JNZ     ??upper_layer_chksum_0
        MOV     R2,#-0x1
        MOV     R3,#-0x1
        SJMP    ??upper_layer_chksum_1
??upper_layer_chksum_0:
        ; Setup parameters for call to function uip_htons
        LCALL   ??uip_htons?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
??upper_layer_chksum_1:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock3
//  382 }
//  383 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  384 uint16_t
//  385 uip_icmp6chksum(void)
uip_icmp6chksum:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function uip_icmp6chksum
        CODE
//  386 {
        FUNCALL uip_icmp6chksum, upper_layer_chksum
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  387   return upper_layer_chksum(UIP_PROTO_ICMP6);
        ; Setup parameters for call to function upper_layer_chksum
        MOV     R1,#0x3a
        LCALL   ??upper_layer_chksum?relay
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock4
//  388   
//  389 }
//  390 /*---------------------------------------------------------------------------*/
//  391 #if UIP_TCP
//  392 uint16_t
//  393 uip_tcpchksum(void)
//  394 {
//  395   return upper_layer_chksum(UIP_PROTO_TCP);
//  396 }
//  397 #endif /* UIP_TCP */
//  398 /*---------------------------------------------------------------------------*/
//  399 #if UIP_UDP && UIP_UDP_CHECKSUMS

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  400 uint16_t
//  401 uip_udpchksum(void)
uip_udpchksum:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function uip_udpchksum
        CODE
//  402 {
        FUNCALL uip_udpchksum, upper_layer_chksum
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  403   return upper_layer_chksum(UIP_PROTO_UDP);
        ; Setup parameters for call to function upper_layer_chksum
        MOV     R1,#0x11
        LCALL   ??upper_layer_chksum?relay
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock5
//  404 }
//  405 #endif /* UIP_UDP && UIP_UDP_CHECKSUMS */
//  406 #endif /* UIP_ARCH_CHKSUM */
//  407 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  408 void
//  409 uip_init(void)
uip_init:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function uip_init
        CODE
//  410 {
        FUNCALL uip_init, uip_ds6_init
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  411    
//  412   uip_ds6_init();
        ; Setup parameters for call to function uip_ds6_init
        LCALL   ??uip_ds6_init?relay
//  413 
//  414 #if UIP_TCP
//  415   for(c = 0; c < UIP_LISTENPORTS; ++c) {
//  416     uip_listenports[c] = 0;
//  417   }
//  418   for(c = 0; c < UIP_CONNS; ++c) {
//  419     uip_conns[c].tcpstateflags = UIP_CLOSED;
//  420   }
//  421 #endif /* UIP_TCP */
//  422 
//  423 #if UIP_ACTIVE_OPEN || UIP_UDP
//  424   lastport = 1024;
        MOV     DPTR,#lastport
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x4
        MOVX    @DPTR,A
//  425 #endif /* UIP_ACTIVE_OPEN || UIP_UDP */
//  426 
//  427 #if UIP_UDP
//  428   for(c = 0; c < UIP_UDP_CONNS; ++c) {
        MOV     DPTR,#`c`
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??uip_init_0
//  429     uip_udp_conns[c].lport = 0;
??uip_init_1:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x19
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x19
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#(uip_udp_conns + 16) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((uip_udp_conns + 16) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  430   }
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
??uip_init_0:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0xa
        JC      ??uip_init_1
//  431 #endif /* UIP_UDP */
//  432 }
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock6
//  433 /*---------------------------------------------------------------------------*/
//  434 #if UIP_TCP && UIP_ACTIVE_OPEN
//  435 struct uip_conn *
//  436 uip_connect(uip_ipaddr_t *ripaddr, uint16_t rport)
//  437 {
//  438   register struct uip_conn *conn, *cconn;
//  439   
//  440   /* Find an unused local port. */
//  441  again:
//  442   ++lastport;
//  443 
//  444   if(lastport >= 32000) {
//  445     lastport = 4096;
//  446   }
//  447 
//  448   /* Check if this port is already in use, and if so try to find
//  449      another one. */
//  450   for(c = 0; c < UIP_CONNS; ++c) {
//  451     conn = &uip_conns[c];
//  452     if(conn->tcpstateflags != UIP_CLOSED &&
//  453        conn->lport == uip_htons(lastport)) {
//  454       goto again;
//  455     }
//  456   }
//  457 
//  458   conn = 0;
//  459   for(c = 0; c < UIP_CONNS; ++c) {
//  460     cconn = &uip_conns[c];
//  461     if(cconn->tcpstateflags == UIP_CLOSED) {
//  462       conn = cconn;
//  463       break;
//  464     }
//  465     if(cconn->tcpstateflags == UIP_TIME_WAIT) {
//  466       if(conn == 0 ||
//  467          cconn->timer > conn->timer) {
//  468         conn = cconn;
//  469       }
//  470     }
//  471   }
//  472 
//  473   if(conn == 0) {
//  474     return 0;
//  475   }
//  476   
//  477   conn->tcpstateflags = UIP_SYN_SENT;
//  478 
//  479   conn->snd_nxt[0] = iss[0];
//  480   conn->snd_nxt[1] = iss[1];
//  481   conn->snd_nxt[2] = iss[2];
//  482   conn->snd_nxt[3] = iss[3];
//  483 
//  484   conn->rcv_nxt[0] = 0;
//  485   conn->rcv_nxt[1] = 0;
//  486   conn->rcv_nxt[2] = 0;
//  487   conn->rcv_nxt[3] = 0;
//  488 
//  489   conn->initialmss = conn->mss = UIP_TCP_MSS;
//  490   
//  491   conn->len = 1;   /* TCP length of the SYN is one. */
//  492   conn->nrtx = 0;
//  493   conn->timer = 1; /* Send the SYN next time around. */
//  494   conn->rto = UIP_RTO;
//  495   conn->sa = 0;
//  496   conn->sv = 16;   /* Initial value of the RTT variance. */
//  497   conn->lport = uip_htons(lastport);
//  498   conn->rport = rport;
//  499   uip_ipaddr_copy(&conn->ripaddr, ripaddr);
//  500   
//  501   return conn;
//  502 }
//  503 #endif /* UIP_TCP && UIP_ACTIVE_OPEN */
//  504 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  505 void
//  506 remove_ext_hdr(void)
remove_ext_hdr:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function remove_ext_hdr
        CODE
//  507 {
        FUNCALL remove_ext_hdr, memmove
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  508   /* Remove ext header before TCP/UDP processing. */
//  509   if(uip_ext_len > 0) {
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        JNC     $+5
        LJMP    ??remove_ext_hdr_0 & 0xFFFF
//  510     PRINTF("Cutting ext-header before processing (extlen: %d, uiplen: %d)\n",
//  511 	   uip_ext_len, uip_len);
//  512     if(uip_len < UIP_IPH_LEN + uip_ext_len) {
        MOV     DPTR,#uip_len
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ADD     A,#0x28
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JNC     ??remove_ext_hdr_1
//  513       PRINTF("ERROR: uip_len too short compared to ext len\n");
//  514       uip_ext_len = 0;
        MOV     DPTR,#uip_ext_len
        MOV     A,#0x0
        MOVX    @DPTR,A
//  515       uip_len = 0;
        MOV     DPTR,#uip_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
//  516       return;
        SJMP    ??remove_ext_hdr_0
//  517     }
//  518     memmove(((uint8_t *)UIP_TCP_BUF), (uint8_t *)UIP_TCP_BUF + uip_ext_len,
//  519 	    uip_len - UIP_IPH_LEN - uip_ext_len);
??remove_ext_hdr_1:
        ; Setup parameters for call to function memmove
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        ADD     A,#-0x28
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOV     R1,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        CLR     C
        SUBB    A,R2
        MOV     ?V0 + 0,A
        MOV     A,R1
        SUBB    A,R3
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x28
        MOV     R4,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 40) & 0xff
        MOV     R3,#((uip_aligned_buf + 40) >> 8) & 0xff
        LCALL   ??memmove?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
//  520 
//  521     uip_len -= uip_ext_len;
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uip_len
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOVX    @DPTR,A
//  522 
//  523     /* Update the IP length. */
//  524     UIP_IP_BUF->len[0] = (uip_len - UIP_IPH_LEN) >> 8;
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        ADD     A,#-0x28
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf + 4
        MOVX    @DPTR,A
//  525     UIP_IP_BUF->len[1] = (uip_len - UIP_IPH_LEN) & 0xff;
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x28
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    @DPTR,A
//  526     uip_ext_len = 0;
        MOV     DPTR,#uip_ext_len
        MOV     A,#0x0
        MOVX    @DPTR,A
//  527   }
//  528 }
??remove_ext_hdr_0:
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock7
//  529 /*---------------------------------------------------------------------------*/
//  530 #if UIP_UDP

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  531 struct uip_udp_conn *
//  532 uip_udp_new(const uip_ipaddr_t *ripaddr, uint16_t rport)
uip_udp_new:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function uip_udp_new
        CODE
//  533 {
        FUNCALL uip_udp_new, uip_htons
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_udp_new, memset
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_udp_new, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xe
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 14)
        ; Saved register size: 14
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     ?V0 + 2,R4
        MOV     ?V0 + 3,R5
        SJMP    ??uip_udp_new_0
//  534   register struct uip_udp_conn *conn;
//  535   
//  536   /* Find an unused local port. */
//  537  again:
//  538   ++lastport;
//  539 
//  540   if(lastport >= 32000) {
//  541     lastport = 4096;
//  542   }
//  543   
//  544   for(c = 0; c < UIP_UDP_CONNS; ++c) {
//  545     if(uip_udp_conns[c].lport == uip_htons(lastport)) {
??uip_udp_new_1:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x19
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x19
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#(uip_udp_conns + 16) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((uip_udp_conns + 16) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        ; Setup parameters for call to function uip_htons
        MOV     DPTR,#lastport
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??uip_htons?relay
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        MOVX    A,@DPTR
        XRL     A,?V0 + 4
        JNZ     ??uip_udp_new_2
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,?V0 + 5
??uip_udp_new_2:
        JNZ     ??uip_udp_new_3
//  546       goto again;
//  547     }
//  548   }
??uip_udp_new_0:
        MOV     DPTR,#lastport
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOVX    @DPTR,A
        MOV     DPTR,#lastport
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,#0x0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x7d
        JC      ??uip_udp_new_4
        MOV     DPTR,#lastport
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x10
        MOVX    @DPTR,A
??uip_udp_new_4:
        MOV     DPTR,#`c`
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??uip_udp_new_5
??uip_udp_new_3:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
??uip_udp_new_5:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0xa
        JNC     $+5
        LJMP    ??uip_udp_new_1 & 0xFFFF
//  549 
//  550   conn = 0;
        MOV     R6,#0x0
        MOV     R7,#0x0
//  551   for(c = 0; c < UIP_UDP_CONNS; ++c) {
        MOV     DPTR,#`c`
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??uip_udp_new_6
??uip_udp_new_7:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
??uip_udp_new_6:
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0xa
        JNC     ??uip_udp_new_8
//  552     if(uip_udp_conns[c].lport == 0) {
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x19
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x19
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#(uip_udp_conns + 16) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((uip_udp_conns + 16) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_udp_new_7
//  553       conn = &uip_udp_conns[c];
        MOV     DPTR,#`c`
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,R0
        MOV     B,#0x19
        MUL     AB
        XCH     A,R0
        MOV     R2,B
        MOV     B,#0x0
        MUL     AB
        ADD     A,R2
        MOV     R2,A
        MOV     B,#0x19
        MOV     A,R1
        MUL     AB
        ADD     A,R2
        MOV     R1,A
        MOV     A,#uip_udp_conns & 0xff
        ADD     A,R0
        MOV     R6,A
        MOV     A,#(uip_udp_conns >> 8) & 0xff
        ADDC    A,R1
        MOV     R7,A
//  554       break;
//  555     }
//  556   }
//  557 
//  558   if(conn == 0) {
??uip_udp_new_8:
        MOV     A,R6
        ORL     A,R7
        JNZ     ??uip_udp_new_9
//  559     return 0;
        MOV     R2,#0x0
        MOV     R3,#0x0
        LJMP    ??uip_udp_new_10 & 0xFFFF
//  560   }
//  561   
//  562   conn->lport = UIP_HTONS(lastport);
??uip_udp_new_9:
        MOV     DPTR,#lastport
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        CLR     A
        XCH     A,R2
        MOV     R3,A
        MOV     DPTR,#lastport
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        CLR     A
        XCH     A,R1
        MOV     R0,A
        MOV     A,R2
        ORL     A,R0
        MOV     R0,A
        MOV     A,R3
        ORL     A,R1
        MOV     R1,A
        MOV     A,R6
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  563   conn->rport = rport;
        MOV     A,R6
        ADD     A,#0x12
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        MOV     A,?V0 + 2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 3
        MOVX    @DPTR,A
//  564   if(ripaddr == NULL) {
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JNZ     ??uip_udp_new_11
//  565     memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
        ; Setup parameters for call to function memset
        MOV     ?V0 + 0,#0x10
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,#0x0
        MOV     R5,#0x0
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??memset?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
        SJMP    ??uip_udp_new_12
//  566   } else {
//  567     uip_ipaddr_copy(&conn->ripaddr, ripaddr);
??uip_udp_new_11:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x10
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R4,?V0 + 0
        MOV     R5,?V0 + 1
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 14)
//  568   }
//  569   conn->ttl = uip_ds6_if.cur_hop_limit;
??uip_udp_new_12:
        MOV     DPTR,#uip_ds6_if + 4
        MOVX    A,@DPTR
        PUSH    A
          CFI CFA_SP SP+-1
        MOV     A,R6
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R7
        ADDC    A,#0x0
        MOV     DPH,A
        POP     A
          CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  570   
//  571   return conn;
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
??uip_udp_new_10:
        MOV     R7,#0x6
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock8
//  572 }
//  573 #endif /* UIP_UDP */
//  574 /*---------------------------------------------------------------------------*/
//  575 #if UIP_TCP
//  576 void
//  577 uip_unlisten(uint16_t port)
//  578 {
//  579   for(c = 0; c < UIP_LISTENPORTS; ++c) {
//  580     if(uip_listenports[c] == port) {
//  581       uip_listenports[c] = 0;
//  582       return;
//  583     }
//  584   }
//  585 }
//  586 /*---------------------------------------------------------------------------*/
//  587 void
//  588 uip_listen(uint16_t port)
//  589 {
//  590   for(c = 0; c < UIP_LISTENPORTS; ++c) {
//  591     if(uip_listenports[c] == 0) {
//  592       uip_listenports[c] = port;
//  593       return;
//  594     }
//  595   }
//  596 }
//  597 #endif
//  598 /*---------------------------------------------------------------------------*/
//  599 
//  600 #if UIP_CONF_IPV6_REASSEMBLY
//  601 #define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
//  602 
//  603 static uint8_t uip_reassbuf[UIP_REASS_BUFSIZE];
//  604 
//  605 static uint8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
//  606 /*the first byte of an IP fragment is aligned on an 8-byte boundary */
//  607 
//  608 static const uint8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
//  609                                     0x0f, 0x07, 0x03, 0x01};
//  610 static uint16_t uip_reasslen;
//  611 static uint8_t uip_reassflags;
//  612 
//  613 #define UIP_REASS_FLAG_LASTFRAG 0x01
//  614 #define UIP_REASS_FLAG_FIRSTFRAG 0x02
//  615 #define UIP_REASS_FLAG_ERROR_MSG 0x04
//  616 
//  617 
//  618 /*
//  619  * See RFC 2460 for a description of fragmentation in IPv6
//  620  * A typical Ipv6 fragment
//  621  *  +------------------+--------+--------------+
//  622  *  |  Unfragmentable  |Fragment|    first     |
//  623  *  |       Part       | Header |   fragment   |
//  624  *  +------------------+--------+--------------+
//  625  */
//  626 
//  627 
//  628 struct etimer uip_reass_timer; /* timer for reassembly */
//  629 uint8_t uip_reass_on; /* equal to 1 if we are currently reassembling a packet */
//  630 
//  631 static uint32_t uip_id; /* For every packet that is to be fragmented, the source
//  632                         node generates an Identification value that is present
//  633                         in all the fragments */
//  634 #define IP_MF   0x0001
//  635 
//  636 static uint16_t
//  637 uip_reass(void)
//  638 {
//  639   uint16_t offset=0;
//  640   uint16_t len;
//  641   uint16_t i;
//  642   
//  643   /* If ip_reasstmr is zero, no packet is present in the buffer */
//  644   /* We first write the unfragmentable part of IP header into the reassembly
//  645      buffer. The reset the other reassembly variables. */
//  646   if(uip_reass_on == 0) {
//  647     PRINTF("Starting reassembly\n");
//  648     memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
//  649     /* temporary in case we do not receive the fragment with offset 0 first */
//  650     etimer_set(&uip_reass_timer, UIP_REASS_MAXAGE*CLOCK_SECOND);
//  651     uip_reass_on = 1;
//  652     uip_reassflags = 0;
//  653     uip_id = UIP_FRAG_BUF->id;
//  654     /* Clear the bitmap. */
//  655     memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
//  656   }
//  657   /*
//  658    * Check if the incoming fragment matches the one currently present
//  659    * in the reasembly buffer. If so, we proceed with copying the fragment
//  660    * into the buffer.
//  661    */
//  662   if(uip_ipaddr_cmp(&FBUF->srcipaddr, &UIP_IP_BUF->srcipaddr) &&
//  663      uip_ipaddr_cmp(&FBUF->destipaddr, &UIP_IP_BUF->destipaddr) &&
//  664      UIP_FRAG_BUF->id == uip_id) {
//  665     len = uip_len - uip_ext_len - UIP_IPH_LEN - UIP_FRAGH_LEN;
//  666     offset = (uip_ntohs(UIP_FRAG_BUF->offsetresmore) & 0xfff8);
//  667     /* in byte, originaly in multiple of 8 bytes*/
//  668     PRINTF("len %d\n", len);
//  669     PRINTF("offset %d\n", offset);
//  670     if(offset == 0){
//  671       uip_reassflags |= UIP_REASS_FLAG_FIRSTFRAG;
//  672       /*
//  673        * The Next Header field of the last header of the Unfragmentable
//  674        * Part is obtained from the Next Header field of the first
//  675        * fragment's Fragment header.
//  676        */
//  677       *uip_next_hdr = UIP_FRAG_BUF->next;
//  678       memcpy(FBUF, UIP_IP_BUF, uip_ext_len + UIP_IPH_LEN);
//  679       PRINTF("src ");
//  680       PRINT6ADDR(&FBUF->srcipaddr);
//  681       PRINTF("dest ");
//  682       PRINT6ADDR(&FBUF->destipaddr);
//  683       PRINTF("next %d\n", UIP_IP_BUF->proto);
//  684       
//  685     }
//  686     
//  687     /* If the offset or the offset + fragment length overflows the
//  688        reassembly buffer, we discard the entire packet. */
//  689     if(offset > UIP_REASS_BUFSIZE ||
//  690        offset + len > UIP_REASS_BUFSIZE) {
//  691       uip_reass_on = 0;
//  692       etimer_stop(&uip_reass_timer);
//  693       return 0;
//  694     }
//  695 
//  696     /* If this fragment has the More Fragments flag set to zero, it is the
//  697        last fragment*/
//  698     if((uip_ntohs(UIP_FRAG_BUF->offsetresmore) & IP_MF) == 0) {
//  699       uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
//  700       /*calculate the size of the entire packet*/
//  701       uip_reasslen = offset + len;
//  702       PRINTF("LAST FRAGMENT reasslen %d\n", uip_reasslen);
//  703     } else {
//  704       /* If len is not a multiple of 8 octets and the M flag of that fragment
//  705          is 1, then that fragment must be discarded and an ICMP Parameter
//  706          Problem, Code 0, message should be sent to the source of the fragment,
//  707          pointing to the Payload Length field of the fragment packet. */
//  708       if(len % 8 != 0){
//  709         uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, 4);
//  710         uip_reassflags |= UIP_REASS_FLAG_ERROR_MSG;
//  711         /* not clear if we should interrupt reassembly, but it seems so from
//  712            the conformance tests */
//  713         uip_reass_on = 0;
//  714         etimer_stop(&uip_reass_timer);
//  715         return uip_len;
//  716       }
//  717     }
//  718     
//  719     /* Copy the fragment into the reassembly buffer, at the right
//  720        offset. */
//  721     memcpy((uint8_t *)FBUF + UIP_IPH_LEN + uip_ext_len + offset,
//  722            (uint8_t *)UIP_FRAG_BUF + UIP_FRAGH_LEN, len);
//  723     
//  724     /* Update the bitmap. */
//  725     if(offset >> 6 == (offset + len) >> 6) {
//  726       uip_reassbitmap[offset >> 6] |=
//  727         bitmap_bits[(offset >> 3) & 7] &
//  728         ~bitmap_bits[((offset + len) >> 3)  & 7];
//  729     } else {
//  730       /* If the two endpoints are in different bytes, we update the
//  731          bytes in the endpoints and fill the stuff inbetween with
//  732          0xff. */
//  733       uip_reassbitmap[offset >> 6] |= bitmap_bits[(offset >> 3) & 7];
//  734  
//  735       for(i = (1 + (offset >> 6)); i < ((offset + len) >> 6); ++i) {
//  736         uip_reassbitmap[i] = 0xff;
//  737       }
//  738       uip_reassbitmap[(offset + len) >> 6] |=
//  739         ~bitmap_bits[((offset + len) >> 3) & 7];
//  740     }
//  741   
//  742     /* Finally, we check if we have a full packet in the buffer. We do
//  743        this by checking if we have the last fragment and if all bits
//  744        in the bitmap are set. */
//  745     
//  746     if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
//  747       /* Check all bytes up to and including all but the last byte in
//  748          the bitmap. */
//  749       for(i = 0; i < (uip_reasslen >> 6); ++i) {
//  750         if(uip_reassbitmap[i] != 0xff) {
//  751           return 0;
//  752         }
//  753       }
//  754       /* Check the last byte in the bitmap. It should contain just the
//  755          right amount of bits. */
//  756       if(uip_reassbitmap[uip_reasslen >> 6] !=
//  757          (uint8_t)~bitmap_bits[(uip_reasslen >> 3) & 7]) {
//  758         return 0;
//  759       }
//  760 
//  761      /* If we have come this far, we have a full packet in the
//  762          buffer, so we copy it to uip_buf. We also reset the timer. */
//  763       uip_reass_on = 0;
//  764       etimer_stop(&uip_reass_timer);
//  765 
//  766       uip_reasslen += UIP_IPH_LEN + uip_ext_len;
//  767       memcpy(UIP_IP_BUF, FBUF, uip_reasslen);
//  768       UIP_IP_BUF->len[0] = ((uip_reasslen - UIP_IPH_LEN) >> 8);
//  769       UIP_IP_BUF->len[1] = ((uip_reasslen - UIP_IPH_LEN) & 0xff);
//  770       PRINTF("REASSEMBLED PAQUET %d (%d)\n", uip_reasslen,
//  771              (UIP_IP_BUF->len[0] << 8) | UIP_IP_BUF->len[1]);
//  772    
//  773       return uip_reasslen;
//  774       
//  775     }
//  776   } else {
//  777     PRINTF("Already reassembling another paquet\n");
//  778   }
//  779   return 0;
//  780 }
//  781 
//  782 void
//  783 uip_reass_over(void)
//  784 {
//  785    /* to late, we abandon the reassembly of the packet */
//  786 
//  787   uip_reass_on = 0;
//  788   etimer_stop(&uip_reass_timer);
//  789 
//  790   if(uip_reassflags & UIP_REASS_FLAG_FIRSTFRAG){
//  791     PRINTF("FRAG INTERRUPTED TOO LATE\n");
//  792     /* If the first fragment has been received, an ICMP Time Exceeded
//  793        -- Fragment Reassembly Time Exceeded message should be sent to the
//  794        source of that fragment. */
//  795     /** \note
//  796      * We don't have a complete packet to put in the error message.
//  797      * We could include the first fragment but since its not mandated by
//  798      * any RFC, we decided not to include it as it reduces the size of
//  799      * the packet.
//  800      */
//  801     uip_len = 0;
//  802     uip_ext_len = 0;
//  803     memcpy(UIP_IP_BUF, FBUF, UIP_IPH_LEN); /* copy the header for src
//  804                                               and dest address*/
//  805     uip_icmp6_error_output(ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_REASSEMBLY, 0);
//  806     
//  807     UIP_STAT(++uip_stat.ip.sent);
//  808     uip_flags = 0;
//  809   }
//  810 }
//  811 
//  812 #endif /* UIP_CONF_IPV6_REASSEMBLY */
//  813 
//  814 /*---------------------------------------------------------------------------*/
//  815 #if UIP_TCP
//  816 static void
//  817 uip_add_rcv_nxt(uint16_t n)
//  818 {
//  819   uip_add32(uip_conn->rcv_nxt, n);
//  820   uip_conn->rcv_nxt[0] = uip_acc32[0];
//  821   uip_conn->rcv_nxt[1] = uip_acc32[1];
//  822   uip_conn->rcv_nxt[2] = uip_acc32[2];
//  823   uip_conn->rcv_nxt[3] = uip_acc32[3];
//  824 }
//  825 #endif
//  826 /*---------------------------------------------------------------------------*/
//  827 
//  828 /**
//  829  * \brief Process the options in Destination and Hop By Hop extension headers
//  830  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  831 static uint8_t
//  832 ext_hdr_options_process(void)
ext_hdr_options_process:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function ext_hdr_options_process
        CODE
//  833 {
        FUNCALL ext_hdr_options_process, uip_icmp6_error_output
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x10
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 16)
        ; Saved register size: 16
        ; Auto size: 0
//  834  /*
//  835   * Length field in the extension header: length of the header in units of
//  836   * 8 bytes, excluding the first 8 bytes
//  837   * length field in an option : the length of data in the option
//  838   */
//  839   uip_ext_opt_offset = 2;
        MOV     DPTR,#uip_ext_opt_offset
        MOV     A,#0x2
        MOVX    @DPTR,A
        SJMP    ??ext_hdr_options_process_0
//  840   while(uip_ext_opt_offset < ((UIP_EXT_BUF->len << 3) + 8)) {
//  841     switch(UIP_EXT_HDR_OPT_BUF->type) {
//  842       /*
//  843        * for now we do not support any options except padding ones
//  844        * PAD1 does not make sense as the header must be 8bytes aligned,
//  845        * hence we can only have
//  846        */
//  847       case UIP_EXT_HDR_OPT_PAD1:
//  848         PRINTF("Processing PAD1 option\n");
//  849         uip_ext_opt_offset += 1;
??ext_hdr_options_process_1:
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        ADD     A,#0x1
        MOVX    @DPTR,A
//  850         break;
??ext_hdr_options_process_0:
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        MOV     A,?V0 + 0
        ADD     A,#0x8
        MOV     R0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     R1,A
        CLR     C
        MOV     A,R2
        SUBB    A,R0
        MOV     A,R3
        SUBB    A,R1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      $+5
        LJMP    ??ext_hdr_options_process_2 & 0xFFFF
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     A,#(uip_aligned_buf + 40) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        JZ      ??ext_hdr_options_process_1
        DEC     A
        JZ      ??ext_hdr_options_process_3
        ADD     A,#-0x62
        JZ      ??ext_hdr_options_process_4
        SJMP    ??ext_hdr_options_process_5
//  851       case UIP_EXT_HDR_OPT_PADN:
//  852         PRINTF("Processing PADN option\n");
//  853         uip_ext_opt_offset += UIP_EXT_HDR_OPT_PADN_BUF->opt_len + 2;
??ext_hdr_options_process_3:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
//  854         break;
        LJMP    ??ext_hdr_options_process_0 & 0xFFFF
//  855       case UIP_EXT_HDR_OPT_RPL:
//  856 		/* Fixes situation when a node that is not using RPL
//  857 		 * joins a network which does. The received packages will include the
//  858 		 * RPL header and processed by the "default" case of the switch
//  859 		 * (0x63 & 0xC0 = 0x40). Hence, the packet is discarded as the header
//  860 		 * is considered invalid.
//  861 		 * Using this fix, the header is ignored, and the next header (if
//  862 		 * present) is processed.
//  863 		 */
//  864 #if UIP_CONF_IPV6_RPL
//  865         PRINTF("Processing RPL option\n");
//  866         if(rpl_verify_header(uip_ext_opt_offset)) {
//  867           PRINTF("RPL Option Error: Dropping Packet\n");
//  868           return 1;
//  869         }
//  870 #endif /* UIP_CONF_IPV6_RPL */
//  871         uip_ext_opt_offset += (UIP_EXT_HDR_OPT_BUF->len) + 2;
??ext_hdr_options_process_4:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
//  872         return 0;
        MOV     R1,#0x0
        LJMP    ??ext_hdr_options_process_6 & 0xFFFF
//  873       default:
//  874         /*
//  875          * check the two highest order bits of the option
//  876          * - 00 skip over this option and continue processing the header.
//  877          * - 01 discard the packet.
//  878          * - 10 discard the packet and, regardless of whether or not the
//  879          *   packet's Destination Address was a multicast address, send an
//  880          *   ICMP Parameter Problem, Code 2, message to the packet's
//  881          *   Source Address, pointing to the unrecognized Option Type.
//  882          * - 11 discard the packet and, only if the packet's Destination
//  883          *   Address was not a multicast address, send an ICMP Parameter
//  884          *   Problem, Code 2, message to the packet's Source Address,
//  885          *   pointing to the unrecognized Option Type.
//  886          */
//  887         PRINTF("MSB %x\n", UIP_EXT_HDR_OPT_BUF->type);
//  888         switch(UIP_EXT_HDR_OPT_BUF->type & 0xC0) {
??ext_hdr_options_process_5:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     A,#(uip_aligned_buf + 40) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ANL     A,#0xc0
        MOV     R0,A
        MOV     A,R1
        ANL     A,#0x0
        MOV     R1,A
        MOV     A,R0
        JZ      ??ext_hdr_options_process_7
        ADD     A,#-0x40
        JZ      ??ext_hdr_options_process_8
        ADD     A,#-0x40
        JZ      ??ext_hdr_options_process_9
        ADD     A,#-0x40
        JZ      ??ext_hdr_options_process_10
//  889           case 0:
//  890             break;
//  891           case 0x40:
//  892             return 1;
//  893           case 0xC0:
//  894             if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
//  895               return 1;
//  896             }
//  897           case 0x80:
//  898             uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION,
//  899                              (uint32_t)UIP_IPH_LEN + uip_ext_len + uip_ext_opt_offset);
//  900             return 2;
//  901         }
//  902         /* in the cases were we did not discard, update ext_opt* */
//  903         uip_ext_opt_offset += UIP_EXT_HDR_OPT_BUF->len + 2;
??ext_hdr_options_process_7:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#0x2
        MOV     R0,A
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
//  904         break;
        LJMP    ??ext_hdr_options_process_0 & 0xFFFF
??ext_hdr_options_process_8:
        MOV     R1,#0x1
        SJMP    ??ext_hdr_options_process_6
??ext_hdr_options_process_10:
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     ??ext_hdr_options_process_9
        MOV     R1,#0x1
        SJMP    ??ext_hdr_options_process_6
??ext_hdr_options_process_9:
        ; Setup parameters for call to function uip_icmp6_error_output
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     ?V0 + 0,A
        CLR     A
        MOV     ?V0 + 1,A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     DPTR,#uip_ext_opt_offset
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        CLR     A
        MOV     ?V0 + 5,A
        MOV     ?V0 + 6,A
        MOV     ?V0 + 7,A
        MOV     R0,#?V0 + 0
        MOV     R1,#?V0 + 4
        LCALL   ?L_ADD
        MOV     DPTR,#__Constant_28
        MOV     R0,#?V0 + 0
        LCALL   ?L_ADD_X
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_FOUR
          CFI CFA_XSP16 add(XSP16, 20)
        MOV     R2,#0x2
        MOV     R1,#0x4
        LCALL   ??uip_icmp6_error_output?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R1,#0x2
        SJMP    ??ext_hdr_options_process_6
//  905     }
//  906   }
//  907   return 0;
??ext_hdr_options_process_2:
        MOV     R1,#0x0
??ext_hdr_options_process_6:
        MOV     R7,#0x8
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock9
//  908 }
//  909 
//  910 
//  911 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  912 void
//  913 uip_process(uint8_t flag)
uip_process:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function uip_process
        CODE
//  914 {
        FUNCALL uip_process, tcpip_uipcall
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, ext_hdr_options_process
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_ds6_addr_lookup
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_ds6_maddr_lookup
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6_error_output
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6_error_output
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_ds6_is_addr_onlink
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6_error_output
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6chksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_nd6_ns_input
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, ext_hdr_options_process
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, remove_ext_hdr
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, ext_hdr_options_process
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6_error_output
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6_error_output
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 16, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 16, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_nd6_na_input
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_icmp6_echo_request_input
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_udpchksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, memcmp
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, tcpip_uipcall
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 14, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 14, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_ds6_select_src
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL uip_process, uip_udpchksum
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
//  915 #if UIP_TCP
//  916   register struct uip_conn *uip_connr = uip_conn;
//  917 #endif /* UIP_TCP */
//  918 #if UIP_UDP
//  919   if(flag == UIP_UDP_SEND_CONN) {
        MOV     A,#0x4
        XRL     A,R6
        JNZ     ??uip_process_0
//  920     goto udp_send;
//  921   }
//  922 #endif /* UIP_UDP */
//  923   uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
//  924    
//  925   /* Check if we were invoked because of a poll request for a
//  926      particular connection. */
//  927   if(flag == UIP_POLL_REQUEST) {
//  928 #if UIP_TCP
//  929     if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
//  930        !uip_outstanding(uip_connr)) {
//  931       uip_flags = UIP_POLL;
//  932       UIP_APPCALL();
//  933       goto appsend;
//  934 #if UIP_ACTIVE_OPEN
//  935     } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) {
//  936       /* In the SYN_SENT state, we retransmit out SYN. */
//  937       UIP_TCP_BUF->flags = 0;
//  938       goto tcp_send_syn;
//  939 #endif /* UIP_ACTIVE_OPEN */
//  940     }
//  941     goto drop;
//  942 #endif /* UIP_TCP */
//  943     /* Check if we were invoked because of the perodic timer fireing. */
//  944   } else if(flag == UIP_TIMER) {
//  945     /* Reset the length variables. */
//  946 #if UIP_TCP
//  947     uip_len = 0;
//  948     uip_slen = 0;
//  949     
//  950     /* Increase the initial sequence number. */
//  951     if(++iss[3] == 0) {
//  952       if(++iss[2] == 0) {
//  953         if(++iss[1] == 0) {
//  954           ++iss[0];
//  955         }
//  956       }
//  957     }
//  958     
//  959     /*
//  960      * Check if the connection is in a state in which we simply wait
//  961      * for the connection to time out. If so, we increase the
//  962      * connection's timer and remove the connection if it times
//  963      * out.
//  964      */
//  965     if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
//  966        uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
//  967       ++(uip_connr->timer);
//  968       if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
//  969         uip_connr->tcpstateflags = UIP_CLOSED;
//  970       }
//  971     } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
//  972       /*
//  973        * If the connection has outstanding data, we increase the
//  974        * connection's timer and see if it has reached the RTO value
//  975        * in which case we retransmit.
//  976        */
//  977       if(uip_outstanding(uip_connr)) {
//  978         if(uip_connr->timer-- == 0) {
//  979           if(uip_connr->nrtx == UIP_MAXRTX ||
//  980              ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
//  981                uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
//  982               uip_connr->nrtx == UIP_MAXSYNRTX)) {
//  983             uip_connr->tcpstateflags = UIP_CLOSED;
//  984                   
//  985             /*
//  986              * We call UIP_APPCALL() with uip_flags set to
//  987              * UIP_TIMEDOUT to inform the application that the
//  988              * connection has timed out.
//  989              */
//  990             uip_flags = UIP_TIMEDOUT;
//  991             UIP_APPCALL();
//  992                   
//  993             /* We also send a reset packet to the remote host. */
//  994             UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
//  995             goto tcp_send_nodata;
//  996           }
//  997                
//  998           /* Exponential backoff. */
//  999           uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
// 1000                                          4:
// 1001                                          uip_connr->nrtx);
// 1002           ++(uip_connr->nrtx);
// 1003                
// 1004           /*
// 1005            * Ok, so we need to retransmit. We do this differently
// 1006            * depending on which state we are in. In ESTABLISHED, we
// 1007            * call upon the application so that it may prepare the
// 1008            * data for the retransmit. In SYN_RCVD, we resend the
// 1009            * SYNACK that we sent earlier and in LAST_ACK we have to
// 1010            * retransmit our FINACK.
// 1011            */
// 1012           UIP_STAT(++uip_stat.tcp.rexmit);
// 1013           switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
// 1014             case UIP_SYN_RCVD:
// 1015               /* In the SYN_RCVD state, we should retransmit our SYNACK. */
// 1016               goto tcp_send_synack;
// 1017                      
// 1018 #if UIP_ACTIVE_OPEN
// 1019             case UIP_SYN_SENT:
// 1020               /* In the SYN_SENT state, we retransmit out SYN. */
// 1021               UIP_TCP_BUF->flags = 0;
// 1022               goto tcp_send_syn;
// 1023 #endif /* UIP_ACTIVE_OPEN */
// 1024                      
// 1025             case UIP_ESTABLISHED:
// 1026               /*
// 1027                * In the ESTABLISHED state, we call upon the application
// 1028                * to do the actual retransmit after which we jump into
// 1029                * the code for sending out the packet (the apprexmit
// 1030                * label).
// 1031                */
// 1032               uip_flags = UIP_REXMIT;
// 1033               UIP_APPCALL();
// 1034               goto apprexmit;
// 1035                      
// 1036             case UIP_FIN_WAIT_1:
// 1037             case UIP_CLOSING:
// 1038             case UIP_LAST_ACK:
// 1039               /* In all these states we should retransmit a FINACK. */
// 1040               goto tcp_send_finack;
// 1041           }
// 1042         }
// 1043       } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
// 1044         /*
// 1045          * If there was no need for a retransmission, we poll the
// 1046          * application for new data.
// 1047          */
// 1048         uip_flags = UIP_POLL;
// 1049         UIP_APPCALL();
// 1050         goto appsend;
// 1051       }
// 1052     }
// 1053     goto drop;
// 1054 #endif /* UIP_TCP */
// 1055   }
// 1056 #if UIP_UDP
// 1057   if(flag == UIP_UDP_TIMER) {
// 1058     if(uip_udp_conn->lport != 0) {
// 1059       uip_conn = NULL;
// 1060       uip_sappdata = uip_appdata = &uip_buf[UIP_IPUDPH_LEN + UIP_LLH_LEN];
// 1061       uip_len = uip_slen = 0;
// 1062       uip_flags = UIP_POLL;
// 1063       UIP_UDP_APPCALL();
// 1064       goto udp_send;
// 1065     } else {
// 1066       goto drop;
// 1067     }
// 1068   }
// 1069 #endif /* UIP_UDP */
// 1070 
// 1071   
// 1072   /* This is where the input processing starts. */
// 1073   UIP_STAT(++uip_stat.ip.recv);
// 1074    
// 1075   /* Start of IP input header processing code. */
// 1076    
// 1077   /* Check validity of the IP header. */
// 1078   if((UIP_IP_BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
// 1079     UIP_STAT(++uip_stat.ip.drop);
// 1080     UIP_STAT(++uip_stat.ip.vhlerr);
// 1081     UIP_LOG("ipv6: invalid version.");
// 1082     goto drop;
// 1083   }
// 1084   /*
// 1085    * Check the size of the packet. If the size reported to us in
// 1086    * uip_len is smaller the size reported in the IP header, we assume
// 1087    * that the packet has been corrupted in transit. If the size of
// 1088    * uip_len is larger than the size reported in the IP packet header,
// 1089    * the packet has been padded and we set uip_len to the correct
// 1090    * value..
// 1091    */
// 1092    
// 1093   if((UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1] <= uip_len) {
// 1094     uip_len = (UIP_IP_BUF->len[0] << 8) + UIP_IP_BUF->len[1] + UIP_IPH_LEN;
// 1095     /*
// 1096      * The length reported in the IPv6 header is the
// 1097      * length of the payload that follows the
// 1098      * header. However, uIP uses the uip_len variable
// 1099      * for holding the size of the entire packet,
// 1100      * including the IP header. For IPv4 this is not a
// 1101      * problem as the length field in the IPv4 header
// 1102      * contains the length of the entire packet. But
// 1103      * for IPv6 we need to add the size of the IPv6
// 1104      * header (40 bytes).
// 1105      */
// 1106   } else {
// 1107     UIP_LOG("ip: packet shorter than reported in IP header.");
// 1108     goto drop;
// 1109   }
// 1110   
// 1111   PRINTF("IPv6 packet received from ");
// 1112   PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
// 1113   PRINTF(" to ");
// 1114   PRINT6ADDR(&UIP_IP_BUF->destipaddr);
// 1115   PRINTF("\n");
// 1116 
// 1117   if(uip_is_addr_mcast(&UIP_IP_BUF->srcipaddr)){
// 1118     UIP_STAT(++uip_stat.ip.drop);
// 1119     PRINTF("Dropping packet, src is mcast\n");
// 1120     goto drop;
// 1121   }
// 1122 
// 1123 #if UIP_CONF_ROUTER
// 1124   /*
// 1125    * Next header field processing. In IPv6, we can have extension headers,
// 1126    * if present, the Hop-by-Hop Option must be processed before forwarding
// 1127    * the packet.
// 1128    */
// 1129   uip_next_hdr = &UIP_IP_BUF->proto;
// 1130   uip_ext_len = 0;
// 1131   uip_ext_bitmap = 0;
// 1132   if(*uip_next_hdr == UIP_PROTO_HBHO) {
// 1133 #if UIP_CONF_IPV6_CHECKS
// 1134     uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_HBHO;
// 1135 #endif /* UIP_CONF_IPV6_CHECKS */
// 1136     switch(ext_hdr_options_process()) {
// 1137       case 0:
// 1138         /* continue */
// 1139         uip_next_hdr = &UIP_EXT_BUF->next;
// 1140         uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
// 1141         break;
// 1142       case 1:
// 1143 	PRINTF("Dropping packet after extension header processing\n");
// 1144         /* silently discard */
// 1145         goto drop;
// 1146       case 2:
// 1147 	PRINTF("Sending error message after extension header processing\n");
// 1148         /* send icmp error message (created in ext_hdr_options_process)
// 1149          * and discard*/
// 1150         goto send;
// 1151     }
// 1152   }
// 1153 
// 1154 
// 1155   /* TBD Some Parameter problem messages */
// 1156   if(!uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr) &&
// 1157      !uip_ds6_is_my_maddr(&UIP_IP_BUF->destipaddr)) {
// 1158     if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr) &&
// 1159        !uip_is_addr_link_local(&UIP_IP_BUF->destipaddr) &&
// 1160        !uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr) &&
// 1161        !uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr) &&
// 1162        !uip_is_addr_loopback(&UIP_IP_BUF->destipaddr)) {
// 1163 
// 1164 
// 1165       /* Check MTU */
// 1166       if(uip_len > UIP_LINK_MTU) {
// 1167         uip_icmp6_error_output(ICMP6_PACKET_TOO_BIG, 0, UIP_LINK_MTU);
// 1168         UIP_STAT(++uip_stat.ip.drop);
// 1169         goto send;
// 1170       }
// 1171       /* Check Hop Limit */
// 1172       if(UIP_IP_BUF->ttl <= 1) {
// 1173         uip_icmp6_error_output(ICMP6_TIME_EXCEEDED,
// 1174                                ICMP6_TIME_EXCEED_TRANSIT, 0);
// 1175         UIP_STAT(++uip_stat.ip.drop);
// 1176         goto send;
// 1177       }
// 1178 
// 1179 #if UIP_CONF_IPV6_RPL
// 1180       rpl_update_header_empty();
// 1181 #endif /* UIP_CONF_IPV6_RPL */
// 1182 
// 1183       UIP_IP_BUF->ttl = UIP_IP_BUF->ttl - 1;
// 1184       PRINTF("Forwarding packet to ");
// 1185       PRINT6ADDR(&UIP_IP_BUF->destipaddr);
// 1186       PRINTF("\n");
// 1187       UIP_STAT(++uip_stat.ip.forwarded);
// 1188       goto send;
// 1189     } else {
// 1190       if((uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr)) &&
// 1191          (!uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) &&
// 1192          (!uip_is_addr_loopback(&UIP_IP_BUF->destipaddr)) &&
// 1193          (!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) &&
// 1194          (!uip_ds6_is_addr_onlink((&UIP_IP_BUF->destipaddr)))) {
// 1195         PRINTF("LL source address with off link destination, dropping\n");
// 1196         uip_icmp6_error_output(ICMP6_DST_UNREACH,
// 1197                                ICMP6_DST_UNREACH_NOTNEIGHBOR, 0);
// 1198         goto send;
// 1199       }
// 1200       PRINTF("Dropping packet, not for me and link local or multicast\n");
// 1201       UIP_STAT(++uip_stat.ip.drop);
// 1202       goto drop;
// 1203     }
// 1204   }
// 1205 #else /* UIP_CONF_ROUTER */
// 1206   if(!uip_ds6_is_my_addr(&UIP_IP_BUF->destipaddr) &&
// 1207      !uip_ds6_is_my_maddr(&UIP_IP_BUF->destipaddr) &&
// 1208      !uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
// 1209     PRINTF("Dropping packet, not for me\n");
// 1210     UIP_STAT(++uip_stat.ip.drop);
// 1211     goto drop;
// 1212   }
// 1213 
// 1214   /*
// 1215    * Next header field processing. In IPv6, we can have extension headers,
// 1216    * they are processed here
// 1217    */
// 1218   uip_next_hdr = &UIP_IP_BUF->proto;
// 1219   uip_ext_len = 0;
// 1220   uip_ext_bitmap = 0;
// 1221 #endif /* UIP_CONF_ROUTER */
// 1222 
// 1223   while(1) {
// 1224     switch(*uip_next_hdr){
// 1225 #if UIP_TCP
// 1226       case UIP_PROTO_TCP:
// 1227         /* TCP, for both IPv4 and IPv6 */
// 1228         goto tcp_input;
// 1229 #endif /* UIP_TCP */
// 1230 #if UIP_UDP
// 1231       case UIP_PROTO_UDP:
// 1232         /* UDP, for both IPv4 and IPv6 */
// 1233         goto udp_input;
// 1234 #endif /* UIP_UDP */
// 1235       case UIP_PROTO_ICMP6:
// 1236         /* ICMPv6 */
// 1237         goto icmp6_input;
// 1238       case UIP_PROTO_HBHO:
// 1239         PRINTF("Processing hbh header\n");
// 1240         /* Hop by hop option header */
// 1241 #if UIP_CONF_IPV6_CHECKS
// 1242         /* Hop by hop option header. If we saw one HBH already, drop */
// 1243         if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_HBHO) {
// 1244           goto bad_hdr;
// 1245         } else {
// 1246           uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_HBHO;
// 1247         }
// 1248 #endif /*UIP_CONF_IPV6_CHECKS*/
// 1249         switch(ext_hdr_options_process()) {
// 1250           case 0:
// 1251             /*continue*/
// 1252             uip_next_hdr = &UIP_EXT_BUF->next;
// 1253             uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
// 1254             break;
// 1255           case 1:
// 1256             /*silently discard*/
// 1257             goto drop;
// 1258           case 2:
// 1259             /* send icmp error message (created in ext_hdr_options_process)
// 1260              * and discard*/
// 1261             goto send;
// 1262         }
// 1263         break;
// 1264       case UIP_PROTO_DESTO:
// 1265 #if UIP_CONF_IPV6_CHECKS
// 1266         /* Destination option header. if we saw two already, drop */
// 1267         PRINTF("Processing desto header\n");
// 1268         if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO1) {
// 1269           if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_DESTO2) {
// 1270             goto bad_hdr;
// 1271           } else{
// 1272             uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO2;
// 1273           }
// 1274         } else {
// 1275           uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_DESTO1;
// 1276         }
// 1277 #endif /*UIP_CONF_IPV6_CHECKS*/
// 1278         switch(ext_hdr_options_process()) {
// 1279           case 0:
// 1280             /*continue*/
// 1281             uip_next_hdr = &UIP_EXT_BUF->next;
// 1282             uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
// 1283             break;
// 1284           case 1:
// 1285             /*silently discard*/
// 1286             goto drop;
// 1287           case 2:
// 1288             /* send icmp error message (created in ext_hdr_options_process)
// 1289              * and discard*/
// 1290             goto send;
// 1291         }
// 1292         break;
// 1293       case UIP_PROTO_ROUTING:
// 1294 #if UIP_CONF_IPV6_CHECKS
// 1295         /* Routing header. If we saw one already, drop */
// 1296         if(uip_ext_bitmap & UIP_EXT_HDR_BITMAP_ROUTING) {
// 1297           goto bad_hdr;
// 1298         } else {
// 1299           uip_ext_bitmap |= UIP_EXT_HDR_BITMAP_ROUTING;
// 1300         }
// 1301 #endif /*UIP_CONF_IPV6_CHECKS*/
// 1302         /*
// 1303          * Routing Header  length field is in units of 8 bytes, excluding
// 1304          * As per RFC2460 section 4.4, if routing type is unrecognized:
// 1305          * if segments left = 0, ignore the header
// 1306          * if segments left > 0, discard packet and send icmp error pointing
// 1307          * to the routing type
// 1308          */
// 1309 
// 1310         PRINTF("Processing Routing header\n");
// 1311         if(UIP_ROUTING_BUF->seg_left > 0) {
// 1312           uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, UIP_IPH_LEN + uip_ext_len + 2);
// 1313           UIP_STAT(++uip_stat.ip.drop);
// 1314           UIP_LOG("ip6: unrecognized routing type");
// 1315           goto send;
// 1316         }
// 1317         uip_next_hdr = &UIP_EXT_BUF->next;
// 1318         uip_ext_len += (UIP_EXT_BUF->len << 3) + 8;
// 1319         break;
// 1320       case UIP_PROTO_FRAG:
// 1321         /* Fragmentation header:call the reassembly function, then leave */
// 1322 #if UIP_CONF_IPV6_REASSEMBLY
// 1323         PRINTF("Processing frag header\n");
// 1324         uip_len = uip_reass();
// 1325         if(uip_len == 0) {
// 1326           goto drop;
// 1327         }
// 1328         if(uip_reassflags & UIP_REASS_FLAG_ERROR_MSG){
// 1329           /* we are not done with reassembly, this is an error message */
// 1330           goto send;
// 1331         }
// 1332         /*packet is reassembled, reset the next hdr to the beginning
// 1333            of the IP header and restart the parsing of the reassembled pkt*/
// 1334         PRINTF("Processing reassembled packet\n");
// 1335         uip_ext_len = 0;
// 1336         uip_ext_bitmap = 0;
// 1337         uip_next_hdr = &UIP_IP_BUF->proto;
// 1338         break;
// 1339 #else /* UIP_CONF_IPV6_REASSEMBLY */
// 1340         UIP_STAT(++uip_stat.ip.drop);
// 1341         UIP_STAT(++uip_stat.ip.fragerr);
// 1342         UIP_LOG("ip: fragment dropped.");
// 1343         goto drop;
// 1344 #endif /* UIP_CONF_IPV6_REASSEMBLY */
// 1345       case UIP_PROTO_NONE:
// 1346         goto drop;
// 1347       default:
// 1348         goto bad_hdr;
// 1349     }
// 1350   }
// 1351   bad_hdr:
// 1352   /*
// 1353    * RFC 2460 send error message parameterr problem, code unrecognized
// 1354    * next header, pointing to the next header field
// 1355    */
// 1356   uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER, (uint32_t)(uip_next_hdr - (uint8_t *)UIP_IP_BUF));
// 1357   UIP_STAT(++uip_stat.ip.drop);
// 1358   UIP_STAT(++uip_stat.ip.protoerr);
// 1359   UIP_LOG("ip6: unrecognized header");
// 1360   goto send;
// 1361   /* End of headers processing */
// 1362   
// 1363   icmp6_input:
// 1364   /* This is IPv6 ICMPv6 processing code. */
// 1365   PRINTF("icmp6_input: length %d type: %d \n", uip_len, UIP_ICMP_BUF->type);
// 1366 
// 1367 #if UIP_CONF_IPV6_CHECKS
// 1368   /* Compute and check the ICMP header checksum */
// 1369   if(uip_icmp6chksum() != 0xffff) {
// 1370     UIP_STAT(++uip_stat.icmp.drop);
// 1371     UIP_STAT(++uip_stat.icmp.chkerr);
// 1372     UIP_LOG("icmpv6: bad checksum.");
// 1373     PRINTF("icmpv6: bad checksum.");
// 1374     goto drop;
// 1375   }
// 1376 #endif /*UIP_CONF_IPV6_CHECKS*/
// 1377 
// 1378   UIP_STAT(++uip_stat.icmp.recv);
// 1379   /*
// 1380    * Here we process incoming ICMPv6 packets
// 1381    * For echo request, we send echo reply
// 1382    * For ND pkts, we call the appropriate function in uip-nd6.c
// 1383    * We do not treat Error messages for now
// 1384    * If no pkt is to be sent as an answer to the incoming one, we
// 1385    * "goto drop". Else we just break; then at the after the "switch"
// 1386    * we "goto send"
// 1387    */
// 1388 #if UIP_CONF_ICMP6
// 1389   UIP_ICMP6_APPCALL(UIP_ICMP_BUF->type);
// 1390 #endif /*UIP_CONF_ICMP6*/
// 1391 
// 1392   switch(UIP_ICMP_BUF->type) {
// 1393     case ICMP6_NS:
// 1394 #if UIP_ND6_SEND_NA
// 1395       uip_nd6_ns_input();
// 1396 #else /* UIP_ND6_SEND_NA */
// 1397       UIP_STAT(++uip_stat.icmp.drop);
// 1398       uip_len = 0;
// 1399 #endif /* UIP_ND6_SEND_NA */
// 1400       break;
// 1401     case ICMP6_NA:
// 1402 #if UIP_ND6_SEND_NA
// 1403       uip_nd6_na_input();
// 1404 #else /* UIP_ND6_SEND_NA */
// 1405       UIP_STAT(++uip_stat.icmp.drop);
// 1406       uip_len = 0;
// 1407 #endif /* UIP_ND6_SEND_NA */
// 1408       break;
// 1409     case ICMP6_RS:
// 1410 #if UIP_CONF_ROUTER && UIP_ND6_SEND_RA
// 1411     uip_nd6_rs_input();
// 1412 #else /* UIP_CONF_ROUTER && UIP_ND6_SEND_RA */
// 1413     UIP_STAT(++uip_stat.icmp.drop);
// 1414     uip_len = 0;
// 1415 #endif /* UIP_CONF_ROUTER && UIP_ND6_SEND_RA */
// 1416     break;
// 1417   case ICMP6_RA:
// 1418 #if UIP_CONF_ROUTER
// 1419     UIP_STAT(++uip_stat.icmp.drop);
// 1420     uip_len = 0;
// 1421 #else /* UIP_CONF_ROUTER */
// 1422     uip_nd6_ra_input();
// 1423 #endif /* UIP_CONF_ROUTER */
// 1424     break;
// 1425 #if UIP_CONF_IPV6_RPL
// 1426   case ICMP6_RPL:
// 1427     uip_rpl_input();
// 1428     break;
// 1429 #endif /* UIP_CONF_IPV6_RPL */
// 1430     case ICMP6_ECHO_REQUEST:
// 1431       uip_icmp6_echo_request_input();
// 1432       break;
// 1433     case ICMP6_ECHO_REPLY:
// 1434       /** \note We don't implement any application callback for now */
// 1435       PRINTF("Received an icmp6 echo reply\n");
// 1436       UIP_STAT(++uip_stat.icmp.recv);
// 1437       uip_len = 0;
// 1438       break;
// 1439     default:
// 1440       PRINTF("Unknown icmp6 message type %d\n", UIP_ICMP_BUF->type);
// 1441       UIP_STAT(++uip_stat.icmp.drop);
// 1442       UIP_STAT(++uip_stat.icmp.typeerr);
// 1443       UIP_LOG("icmp6: unknown ICMP message.");
// 1444       uip_len = 0;
// 1445       break;
// 1446   }
// 1447   
// 1448   if(uip_len > 0) {
// 1449     goto send;
// 1450   } else {
// 1451     goto drop;
// 1452   }
// 1453   /* End of IPv6 ICMP processing. */
// 1454    
// 1455 
// 1456 #if UIP_UDP
// 1457   /* UDP input processing. */
// 1458  udp_input:
// 1459 
// 1460   remove_ext_hdr();
// 1461 
// 1462   PRINTF("Receiving UDP packet\n");
// 1463   UIP_STAT(++uip_stat.udp.recv);
// 1464  
// 1465   /* UDP processing is really just a hack. We don't do anything to the
// 1466      UDP/IP headers, but let the UDP application do all the hard
// 1467      work. If the application sets uip_slen, it has a packet to
// 1468      send. */
// 1469 #if UIP_UDP_CHECKSUMS
// 1470   uip_len = uip_len - UIP_IPUDPH_LEN;
// 1471   uip_appdata = &uip_buf[UIP_IPUDPH_LEN + UIP_LLH_LEN];
// 1472   /* XXX hack: UDP/IPv6 receivers should drop packets with UDP
// 1473      checksum 0. Here, we explicitly receive UDP packets with checksum
// 1474      0. This is to be able to debug code that for one reason or
// 1475      another miscomputes UDP checksums. The reception of zero UDP
// 1476      checksums should be turned into a configration option. */
// 1477   if(UIP_UDP_BUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
// 1478     UIP_STAT(++uip_stat.udp.drop);
// 1479     UIP_STAT(++uip_stat.udp.chkerr);
// 1480     PRINTF("udp: bad checksum 0x%04x 0x%04x\n", UIP_UDP_BUF->udpchksum,
// 1481            uip_udpchksum());
// 1482     goto drop;
// 1483   }
// 1484 #else /* UIP_UDP_CHECKSUMS */
// 1485   uip_len = uip_len - UIP_IPUDPH_LEN;
// 1486 #endif /* UIP_UDP_CHECKSUMS */
// 1487 
// 1488   /* Make sure that the UDP destination port number is not zero. */
// 1489   if(UIP_UDP_BUF->destport == 0) {
// 1490     PRINTF("udp: zero port.\n");
// 1491     goto drop;
// 1492   }
// 1493 
// 1494   /* Demultiplex this UDP packet between the UDP "connections". */
// 1495   for(uip_udp_conn = &uip_udp_conns[0];
// 1496       uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
// 1497       ++uip_udp_conn) {
// 1498     /* If the local UDP port is non-zero, the connection is considered
// 1499        to be used. If so, the local port number is checked against the
// 1500        destination port number in the received packet. If the two port
// 1501        numbers match, the remote port number is checked if the
// 1502        connection is bound to a remote port. Finally, if the
// 1503        connection is bound to a remote IP address, the source IP
// 1504        address of the packet is checked. */
// 1505     if(uip_udp_conn->lport != 0 &&
// 1506        UIP_UDP_BUF->destport == uip_udp_conn->lport &&
// 1507        (uip_udp_conn->rport == 0 ||
// 1508         UIP_UDP_BUF->srcport == uip_udp_conn->rport) &&
// 1509        (uip_is_addr_unspecified(&uip_udp_conn->ripaddr) ||
// 1510         uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
// 1511       goto udp_found;
// 1512     }
// 1513   }
// 1514   PRINTF("udp: no matching connection found\n");
// 1515 
// 1516 #if UIP_UDP_SEND_UNREACH_NOPORT
// 1517   uip_icmp6_error_output(ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT, 0);
// 1518   UIP_STAT(++uip_stat.ip.drop);
// 1519   goto send;
// 1520 #else
// 1521   goto drop;
// 1522 #endif
// 1523 
// 1524  udp_found:
// 1525   PRINTF("In udp_found\n");
// 1526  
// 1527   uip_conn = NULL;
// 1528   uip_flags = UIP_NEWDATA;
// 1529   uip_sappdata = uip_appdata = &uip_buf[UIP_IPUDPH_LEN + UIP_LLH_LEN];
// 1530   uip_slen = 0;
// 1531   UIP_UDP_APPCALL();
// 1532 
// 1533  udp_send:
// 1534   PRINTF("In udp_send\n");
// 1535 
// 1536   if(uip_slen == 0) {
??uip_process_1:
        MOV     DPTR,#uip_slen
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_2 & 0xFFFF
// 1537     goto drop;
        SJMP    ??uip_process_3
// 1538   }
??uip_process_0:
        MOV     R0,#(uip_aligned_buf + 60) & 0xff
        MOV     R1,#((uip_aligned_buf + 60) >> 8) & 0xff
        MOV     DPTR,#uip_appdata
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_sappdata
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     A,#0x3
        XRL     A,R6
        MOV     A,#0x5
        XRL     A,R6
        JNZ     ??uip_process_4
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??uip_process_3
        MOV     DPTR,#uip_conn
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        MOV     R0,#(uip_aligned_buf + 48) & 0xff
        MOV     R1,#((uip_aligned_buf + 48) >> 8) & 0xff
        MOV     DPTR,#uip_appdata
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_sappdata
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     R0,#0x0
        MOV     R1,#0x0
        MOV     DPTR,#uip_slen
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_len
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_flags
        MOV     A,#0x8
        MOVX    @DPTR,A
        ; Setup parameters for call to function tcpip_uipcall
        LCALL   ??tcpip_uipcall?relay
        LJMP    ??uip_process_1 & 0xFFFF
// 1539   uip_len = uip_slen + UIP_IPUDPH_LEN;
// 1540 
// 1541   /* For IPv6, the IP length field does not include the IPv6 IP header
// 1542      length. */
// 1543   UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
// 1544   UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
// 1545 
// 1546   UIP_IP_BUF->ttl = uip_udp_conn->ttl;
// 1547   UIP_IP_BUF->proto = UIP_PROTO_UDP;
// 1548 
// 1549   UIP_UDP_BUF->udplen = UIP_HTONS(uip_slen + UIP_UDPH_LEN);
// 1550   UIP_UDP_BUF->udpchksum = 0;
// 1551 
// 1552   UIP_UDP_BUF->srcport  = uip_udp_conn->lport;
// 1553   UIP_UDP_BUF->destport = uip_udp_conn->rport;
// 1554 
// 1555   uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_udp_conn->ripaddr);
// 1556   uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
// 1557 
// 1558   uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
// 1559 
// 1560 #if UIP_CONF_IPV6_RPL
// 1561   rpl_insert_header();
// 1562 #endif /* UIP_CONF_IPV6_RPL */
// 1563 
// 1564 #if UIP_UDP_CHECKSUMS
// 1565   /* Calculate UDP checksum. */
// 1566   UIP_UDP_BUF->udpchksum = ~(uip_udpchksum());
// 1567   if(UIP_UDP_BUF->udpchksum == 0) {
// 1568     UIP_UDP_BUF->udpchksum = 0xffff;
// 1569   }
// 1570 #endif /* UIP_UDP_CHECKSUMS */
// 1571   UIP_STAT(++uip_stat.udp.sent);
// 1572   goto ip_send_nolen;
// 1573 #endif /* UIP_UDP */
// 1574 
// 1575 #if UIP_TCP
// 1576   /* TCP input processing. */
// 1577  tcp_input:
// 1578 
// 1579   remove_ext_hdr();
// 1580 
// 1581   UIP_STAT(++uip_stat.tcp.recv);
// 1582   PRINTF("Receiving TCP packet\n");
// 1583   /* Start of TCP input header processing code. */
// 1584   
// 1585   if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
// 1586                                        checksum. */
// 1587     UIP_STAT(++uip_stat.tcp.drop);
// 1588     UIP_STAT(++uip_stat.tcp.chkerr);
// 1589     PRINTF("tcp: bad checksum 0x%04x 0x%04x\n", UIP_TCP_BUF->tcpchksum,
// 1590            uip_tcpchksum());
// 1591     goto drop;
// 1592   }
// 1593 
// 1594   /* Make sure that the TCP port number is not zero. */
// 1595   if(UIP_TCP_BUF->destport == 0 || UIP_TCP_BUF->srcport == 0) {
// 1596     PRINTF("tcp: zero port.");
// 1597     goto drop;
// 1598   }
// 1599 
// 1600   /* Demultiplex this segment. */
// 1601   /* First check any active connections. */
// 1602   for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
// 1603       ++uip_connr) {
// 1604     if(uip_connr->tcpstateflags != UIP_CLOSED &&
// 1605        UIP_TCP_BUF->destport == uip_connr->lport &&
// 1606        UIP_TCP_BUF->srcport == uip_connr->rport &&
// 1607        uip_ipaddr_cmp(&UIP_IP_BUF->srcipaddr, &uip_connr->ripaddr)) {
// 1608       goto found;
// 1609     }
// 1610   }
// 1611 
// 1612   /* If we didn't find and active connection that expected the packet,
// 1613      either this packet is an old duplicate, or this is a SYN packet
// 1614      destined for a connection in LISTEN. If the SYN flag isn't set,
// 1615      it is an old packet and we send a RST. */
// 1616   if((UIP_TCP_BUF->flags & TCP_CTL) != TCP_SYN) {
// 1617     goto reset;
// 1618   }
// 1619   
// 1620   tmp16 = UIP_TCP_BUF->destport;
// 1621   /* Next, check listening connections. */
// 1622   for(c = 0; c < UIP_LISTENPORTS; ++c) {
// 1623     if(tmp16 == uip_listenports[c]) {
// 1624       goto found_listen;
// 1625     }
// 1626   }
// 1627   
// 1628   /* No matching connection found, so we send a RST packet. */
// 1629   UIP_STAT(++uip_stat.tcp.synrst);
// 1630 
// 1631  reset:
// 1632   PRINTF("In reset\n");
// 1633   /* We do not send resets in response to resets. */
// 1634   if(UIP_TCP_BUF->flags & TCP_RST) {
// 1635     goto drop;
// 1636   }
// 1637 
// 1638   UIP_STAT(++uip_stat.tcp.rst);
// 1639   
// 1640   UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
// 1641   uip_len = UIP_IPTCPH_LEN;
// 1642   UIP_TCP_BUF->tcpoffset = 5 << 4;
// 1643 
// 1644   /* Flip the seqno and ackno fields in the TCP header. */
// 1645   c = UIP_TCP_BUF->seqno[3];
// 1646   UIP_TCP_BUF->seqno[3] = UIP_TCP_BUF->ackno[3];
// 1647   UIP_TCP_BUF->ackno[3] = c;
// 1648   
// 1649   c = UIP_TCP_BUF->seqno[2];
// 1650   UIP_TCP_BUF->seqno[2] = UIP_TCP_BUF->ackno[2];
// 1651   UIP_TCP_BUF->ackno[2] = c;
// 1652   
// 1653   c = UIP_TCP_BUF->seqno[1];
// 1654   UIP_TCP_BUF->seqno[1] = UIP_TCP_BUF->ackno[1];
// 1655   UIP_TCP_BUF->ackno[1] = c;
// 1656   
// 1657   c = UIP_TCP_BUF->seqno[0];
// 1658   UIP_TCP_BUF->seqno[0] = UIP_TCP_BUF->ackno[0];
// 1659   UIP_TCP_BUF->ackno[0] = c;
// 1660 
// 1661   /* We also have to increase the sequence number we are
// 1662      acknowledging. If the least significant byte overflowed, we need
// 1663      to propagate the carry to the other bytes as well. */
// 1664   if(++UIP_TCP_BUF->ackno[3] == 0) {
// 1665     if(++UIP_TCP_BUF->ackno[2] == 0) {
// 1666       if(++UIP_TCP_BUF->ackno[1] == 0) {
// 1667         ++UIP_TCP_BUF->ackno[0];
// 1668       }
// 1669     }
// 1670   }
// 1671  
// 1672   /* Swap port numbers. */
// 1673   tmp16 = UIP_TCP_BUF->srcport;
// 1674   UIP_TCP_BUF->srcport = UIP_TCP_BUF->destport;
// 1675   UIP_TCP_BUF->destport = tmp16;
// 1676   
// 1677   /* Swap IP addresses. */
// 1678   uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);
// 1679   uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
// 1680   /* And send out the RST packet! */
// 1681   goto tcp_send_noconn;
// 1682 
// 1683   /* This label will be jumped to if we matched the incoming packet
// 1684      with a connection in LISTEN. In that case, we should create a new
// 1685      connection and send a SYNACK in return. */
// 1686  found_listen:
// 1687   PRINTF("In found listen\n");
// 1688   /* First we check if there are any connections avaliable. Unused
// 1689      connections are kept in the same table as used connections, but
// 1690      unused ones have the tcpstate set to CLOSED. Also, connections in
// 1691      TIME_WAIT are kept track of and we'll use the oldest one if no
// 1692      CLOSED connections are found. Thanks to Eddie C. Dost for a very
// 1693      nice algorithm for the TIME_WAIT search. */
// 1694   uip_connr = 0;
// 1695   for(c = 0; c < UIP_CONNS; ++c) {
// 1696     if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
// 1697       uip_connr = &uip_conns[c];
// 1698       break;
// 1699     }
// 1700     if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
// 1701       if(uip_connr == 0 ||
// 1702          uip_conns[c].timer > uip_connr->timer) {
// 1703         uip_connr = &uip_conns[c];
// 1704       }
// 1705     }
// 1706   }
// 1707 
// 1708   if(uip_connr == 0) {
// 1709     /* All connections are used already, we drop packet and hope that
// 1710        the remote end will retransmit the packet at a time when we
// 1711        have more spare connections. */
// 1712     UIP_STAT(++uip_stat.tcp.syndrop);
// 1713     UIP_LOG("tcp: found no unused connections.");
// 1714     goto drop;
// 1715   }
// 1716   uip_conn = uip_connr;
// 1717   
// 1718   /* Fill in the necessary fields for the new connection. */
// 1719   uip_connr->rto = uip_connr->timer = UIP_RTO;
// 1720   uip_connr->sa = 0;
// 1721   uip_connr->sv = 4;
// 1722   uip_connr->nrtx = 0;
// 1723   uip_connr->lport = UIP_TCP_BUF->destport;
// 1724   uip_connr->rport = UIP_TCP_BUF->srcport;
// 1725   uip_ipaddr_copy(&uip_connr->ripaddr, &UIP_IP_BUF->srcipaddr);
// 1726   uip_connr->tcpstateflags = UIP_SYN_RCVD;
// 1727 
// 1728   uip_connr->snd_nxt[0] = iss[0];
// 1729   uip_connr->snd_nxt[1] = iss[1];
// 1730   uip_connr->snd_nxt[2] = iss[2];
// 1731   uip_connr->snd_nxt[3] = iss[3];
// 1732   uip_connr->len = 1;
// 1733 
// 1734   /* rcv_nxt should be the seqno from the incoming packet + 1. */
// 1735   uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];
// 1736   uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];
// 1737   uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];
// 1738   uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];
// 1739   uip_add_rcv_nxt(1);
// 1740 
// 1741   /* Parse the TCP MSS option, if present. */
// 1742   if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {
// 1743     for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
// 1744       opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
// 1745       if(opt == TCP_OPT_END) {
// 1746         /* End of options. */
// 1747         break;
// 1748       } else if(opt == TCP_OPT_NOOP) {
// 1749         ++c;
// 1750         /* NOP option. */
// 1751       } else if(opt == TCP_OPT_MSS &&
// 1752                 uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
// 1753         /* An MSS option with the right option length. */
// 1754         tmp16 = ((uint16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
// 1755           (uint16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
// 1756         uip_connr->initialmss = uip_connr->mss =
// 1757           tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
// 1758    
// 1759         /* And we are done processing options. */
// 1760         break;
// 1761       } else {
// 1762         /* All other options have a length field, so that we easily
// 1763            can skip past them. */
// 1764         if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
// 1765           /* If the length field is zero, the options are malformed
// 1766              and we don't process them further. */
// 1767           break;
// 1768         }
// 1769         c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
// 1770       }
// 1771     }
// 1772   }
// 1773   
// 1774   /* Our response will be a SYNACK. */
// 1775 #if UIP_ACTIVE_OPEN
// 1776  tcp_send_synack:
// 1777   UIP_TCP_BUF->flags = TCP_ACK;
// 1778   
// 1779  tcp_send_syn:
// 1780   UIP_TCP_BUF->flags |= TCP_SYN;
// 1781 #else /* UIP_ACTIVE_OPEN */
// 1782  tcp_send_synack:
// 1783   UIP_TCP_BUF->flags = TCP_SYN | TCP_ACK;
// 1784 #endif /* UIP_ACTIVE_OPEN */
// 1785   
// 1786   /* We send out the TCP Maximum Segment Size option with our
// 1787      SYNACK. */
// 1788   UIP_TCP_BUF->optdata[0] = TCP_OPT_MSS;
// 1789   UIP_TCP_BUF->optdata[1] = TCP_OPT_MSS_LEN;
// 1790   UIP_TCP_BUF->optdata[2] = (UIP_TCP_MSS) / 256;
// 1791   UIP_TCP_BUF->optdata[3] = (UIP_TCP_MSS) & 255;
// 1792   uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
// 1793   UIP_TCP_BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
// 1794   goto tcp_send;
// 1795 
// 1796   /* This label will be jumped to if we found an active connection. */
// 1797  found:
// 1798   PRINTF("In found\n");
// 1799   uip_conn = uip_connr;
// 1800   uip_flags = 0;
// 1801   /* We do a very naive form of TCP reset processing; we just accept
// 1802      any RST and kill our connection. We should in fact check if the
// 1803      sequence number of this reset is wihtin our advertised window
// 1804      before we accept the reset. */
// 1805   if(UIP_TCP_BUF->flags & TCP_RST) {
// 1806     uip_connr->tcpstateflags = UIP_CLOSED;
// 1807     UIP_LOG("tcp: got reset, aborting connection.");
// 1808     uip_flags = UIP_ABORT;
// 1809     UIP_APPCALL();
// 1810     goto drop;
// 1811   }
// 1812   /* Calculate the length of the data, if the application has sent
// 1813      any data to us. */
// 1814   c = (UIP_TCP_BUF->tcpoffset >> 4) << 2;
// 1815   /* uip_len will contain the length of the actual TCP data. This is
// 1816      calculated by subtracing the length of the TCP header (in
// 1817      c) and the length of the IP header (20 bytes). */
// 1818   uip_len = uip_len - c - UIP_IPH_LEN;
// 1819 
// 1820   /* First, check if the sequence number of the incoming packet is
// 1821      what we're expecting next. If not, we send out an ACK with the
// 1822      correct numbers in, unless we are in the SYN_RCVD state and
// 1823      receive a SYN, in which case we should retransmit our SYNACK
// 1824      (which is done futher down). */
// 1825   if(!((((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
// 1826 	((UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK))) ||
// 1827        (((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_RCVD) &&
// 1828 	((UIP_TCP_BUF->flags & TCP_CTL) == TCP_SYN)))) {
// 1829     if((uip_len > 0 || ((UIP_TCP_BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
// 1830        (UIP_TCP_BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
// 1831         UIP_TCP_BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
// 1832         UIP_TCP_BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
// 1833         UIP_TCP_BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
// 1834 
// 1835       if(UIP_TCP_BUF->flags & TCP_SYN) {
// 1836         goto tcp_send_synack;
// 1837       }
// 1838       goto tcp_send_ack;
// 1839     }
// 1840   }
// 1841 
// 1842   /* Next, check if the incoming segment acknowledges any outstanding
// 1843      data. If so, we update the sequence number, reset the length of
// 1844      the outstanding data, calculate RTT estimations, and reset the
// 1845      retransmission timer. */
// 1846   if((UIP_TCP_BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
// 1847     uip_add32(uip_connr->snd_nxt, uip_connr->len);
// 1848 
// 1849     if(UIP_TCP_BUF->ackno[0] == uip_acc32[0] &&
// 1850        UIP_TCP_BUF->ackno[1] == uip_acc32[1] &&
// 1851        UIP_TCP_BUF->ackno[2] == uip_acc32[2] &&
// 1852        UIP_TCP_BUF->ackno[3] == uip_acc32[3]) {
// 1853       /* Update sequence number. */
// 1854       uip_connr->snd_nxt[0] = uip_acc32[0];
// 1855       uip_connr->snd_nxt[1] = uip_acc32[1];
// 1856       uip_connr->snd_nxt[2] = uip_acc32[2];
// 1857       uip_connr->snd_nxt[3] = uip_acc32[3];
// 1858    
// 1859       /* Do RTT estimation, unless we have done retransmissions. */
// 1860       if(uip_connr->nrtx == 0) {
// 1861         signed char m;
// 1862         m = uip_connr->rto - uip_connr->timer;
// 1863         /* This is taken directly from VJs original code in his paper */
// 1864         m = m - (uip_connr->sa >> 3);
// 1865         uip_connr->sa += m;
// 1866         if(m < 0) {
// 1867           m = -m;
// 1868         }
// 1869         m = m - (uip_connr->sv >> 2);
// 1870         uip_connr->sv += m;
// 1871         uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
// 1872 
// 1873       }
// 1874       /* Set the acknowledged flag. */
// 1875       uip_flags = UIP_ACKDATA;
// 1876       /* Reset the retransmission timer. */
// 1877       uip_connr->timer = uip_connr->rto;
// 1878 
// 1879       /* Reset length of outstanding data. */
// 1880       uip_connr->len = 0;
// 1881     }
// 1882     
// 1883   }
// 1884 
// 1885   /* Do different things depending on in what state the connection is. */
// 1886   switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
// 1887     /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
// 1888        implemented, since we force the application to close when the
// 1889        peer sends a FIN (hence the application goes directly from
// 1890        ESTABLISHED to LAST_ACK). */
// 1891     case UIP_SYN_RCVD:
// 1892       /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
// 1893          we are waiting for an ACK that acknowledges the data we sent
// 1894          out the last time. Therefore, we want to have the UIP_ACKDATA
// 1895          flag set. If so, we enter the ESTABLISHED state. */
// 1896       if(uip_flags & UIP_ACKDATA) {
// 1897         uip_connr->tcpstateflags = UIP_ESTABLISHED;
// 1898         uip_flags = UIP_CONNECTED;
// 1899         uip_connr->len = 0;
// 1900         if(uip_len > 0) {
// 1901           uip_flags |= UIP_NEWDATA;
// 1902           uip_add_rcv_nxt(uip_len);
// 1903         }
// 1904         uip_slen = 0;
// 1905         UIP_APPCALL();
// 1906         goto appsend;
// 1907       }
// 1908       /* We need to retransmit the SYNACK */
// 1909       if((UIP_TCP_BUF->flags & TCP_CTL) == TCP_SYN) {
// 1910 	goto tcp_send_synack;
// 1911       }
// 1912       goto drop;
// 1913 #if UIP_ACTIVE_OPEN
// 1914     case UIP_SYN_SENT:
// 1915       /* In SYN_SENT, we wait for a SYNACK that is sent in response to
// 1916          our SYN. The rcv_nxt is set to sequence number in the SYNACK
// 1917          plus one, and we send an ACK. We move into the ESTABLISHED
// 1918          state. */
// 1919       if((uip_flags & UIP_ACKDATA) &&
// 1920          (UIP_TCP_BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
// 1921 
// 1922         /* Parse the TCP MSS option, if present. */
// 1923         if((UIP_TCP_BUF->tcpoffset & 0xf0) > 0x50) {
// 1924           for(c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
// 1925             opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
// 1926             if(opt == TCP_OPT_END) {
// 1927               /* End of options. */
// 1928               break;
// 1929             } else if(opt == TCP_OPT_NOOP) {
// 1930               ++c;
// 1931               /* NOP option. */
// 1932             } else if(opt == TCP_OPT_MSS &&
// 1933                       uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
// 1934               /* An MSS option with the right option length. */
// 1935               tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
// 1936                 uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
// 1937               uip_connr->initialmss =
// 1938                 uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
// 1939 
// 1940               /* And we are done processing options. */
// 1941               break;
// 1942             } else {
// 1943               /* All other options have a length field, so that we easily
// 1944                  can skip past them. */
// 1945               if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
// 1946                 /* If the length field is zero, the options are malformed
// 1947                    and we don't process them further. */
// 1948                 break;
// 1949               }
// 1950               c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
// 1951             }
// 1952           }
// 1953         }
// 1954         uip_connr->tcpstateflags = UIP_ESTABLISHED;
// 1955         uip_connr->rcv_nxt[0] = UIP_TCP_BUF->seqno[0];
// 1956         uip_connr->rcv_nxt[1] = UIP_TCP_BUF->seqno[1];
// 1957         uip_connr->rcv_nxt[2] = UIP_TCP_BUF->seqno[2];
// 1958         uip_connr->rcv_nxt[3] = UIP_TCP_BUF->seqno[3];
// 1959         uip_add_rcv_nxt(1);
// 1960         uip_flags = UIP_CONNECTED | UIP_NEWDATA;
// 1961         uip_connr->len = 0;
// 1962         uip_len = 0;
// 1963         uip_slen = 0;
// 1964         UIP_APPCALL();
// 1965         goto appsend;
// 1966       }
// 1967       /* Inform the application that the connection failed */
// 1968       uip_flags = UIP_ABORT;
// 1969       UIP_APPCALL();
// 1970       /* The connection is closed after we send the RST */
// 1971       uip_conn->tcpstateflags = UIP_CLOSED;
// 1972       goto reset;
// 1973 #endif /* UIP_ACTIVE_OPEN */
// 1974     
// 1975     case UIP_ESTABLISHED:
// 1976       /* In the ESTABLISHED state, we call upon the application to feed
// 1977          data into the uip_buf. If the UIP_ACKDATA flag is set, the
// 1978          application should put new data into the buffer, otherwise we are
// 1979          retransmitting an old segment, and the application should put that
// 1980          data into the buffer.
// 1981 
// 1982          If the incoming packet is a FIN, we should close the connection on
// 1983          this side as well, and we send out a FIN and enter the LAST_ACK
// 1984          state. We require that there is no outstanding data; otherwise the
// 1985          sequence numbers will be screwed up. */
// 1986 
// 1987       if(UIP_TCP_BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
// 1988         if(uip_outstanding(uip_connr)) {
// 1989           goto drop;
// 1990         }
// 1991         uip_add_rcv_nxt(1 + uip_len);
// 1992         uip_flags |= UIP_CLOSE;
// 1993         if(uip_len > 0) {
// 1994           uip_flags |= UIP_NEWDATA;
// 1995         }
// 1996         UIP_APPCALL();
// 1997         uip_connr->len = 1;
// 1998         uip_connr->tcpstateflags = UIP_LAST_ACK;
// 1999         uip_connr->nrtx = 0;
// 2000       tcp_send_finack:
// 2001         UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;
// 2002         goto tcp_send_nodata;
// 2003       }
// 2004 
// 2005       /* Check the URG flag. If this is set, the segment carries urgent
// 2006          data that we must pass to the application. */
// 2007       if((UIP_TCP_BUF->flags & TCP_URG) != 0) {
// 2008 #if UIP_URGDATA > 0
// 2009         uip_urglen = (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];
// 2010         if(uip_urglen > uip_len) {
// 2011           /* There is more urgent data in the next segment to come. */
// 2012           uip_urglen = uip_len;
// 2013         }
// 2014         uip_add_rcv_nxt(uip_urglen);
// 2015         uip_len -= uip_urglen;
// 2016         uip_urgdata = uip_appdata;
// 2017         uip_appdata += uip_urglen;
// 2018       } else {
// 2019         uip_urglen = 0;
// 2020 #else /* UIP_URGDATA > 0 */
// 2021         uip_appdata = ((char *)uip_appdata) + ((UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1]);
// 2022         uip_len -= (UIP_TCP_BUF->urgp[0] << 8) | UIP_TCP_BUF->urgp[1];
// 2023 #endif /* UIP_URGDATA > 0 */
// 2024       }
// 2025 
// 2026       /* If uip_len > 0 we have TCP data in the packet, and we flag this
// 2027          by setting the UIP_NEWDATA flag and update the sequence number
// 2028          we acknowledge. If the application has stopped the dataflow
// 2029          using uip_stop(), we must not accept any data packets from the
// 2030          remote host. */
// 2031       if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
// 2032         uip_flags |= UIP_NEWDATA;
// 2033         uip_add_rcv_nxt(uip_len);
// 2034       }
// 2035 
// 2036       /* Check if the available buffer space advertised by the other end
// 2037          is smaller than the initial MSS for this connection. If so, we
// 2038          set the current MSS to the window size to ensure that the
// 2039          application does not send more data than the other end can
// 2040          handle.
// 2041 
// 2042          If the remote host advertises a zero window, we set the MSS to
// 2043          the initial MSS so that the application will send an entire MSS
// 2044          of data. This data will not be acknowledged by the receiver,
// 2045          and the application will retransmit it. This is called the
// 2046          "persistent timer" and uses the retransmission mechanim.
// 2047       */
// 2048       tmp16 = ((uint16_t)UIP_TCP_BUF->wnd[0] << 8) + (uint16_t)UIP_TCP_BUF->wnd[1];
// 2049       if(tmp16 > uip_connr->initialmss ||
// 2050          tmp16 == 0) {
// 2051         tmp16 = uip_connr->initialmss;
// 2052       }
// 2053       uip_connr->mss = tmp16;
// 2054 
// 2055       /* If this packet constitutes an ACK for outstanding data (flagged
// 2056          by the UIP_ACKDATA flag, we should call the application since it
// 2057          might want to send more data. If the incoming packet had data
// 2058          from the peer (as flagged by the UIP_NEWDATA flag), the
// 2059          application must also be notified.
// 2060 
// 2061          When the application is called, the global variable uip_len
// 2062          contains the length of the incoming data. The application can
// 2063          access the incoming data through the global pointer
// 2064          uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
// 2065          bytes into the uip_buf array.
// 2066 
// 2067          If the application wishes to send any data, this data should be
// 2068          put into the uip_appdata and the length of the data should be
// 2069          put into uip_len. If the application don't have any data to
// 2070          send, uip_len must be set to 0. */
// 2071       if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
// 2072         uip_slen = 0;
// 2073         UIP_APPCALL();
// 2074 
// 2075       appsend:
// 2076       
// 2077         if(uip_flags & UIP_ABORT) {
// 2078           uip_slen = 0;
// 2079           uip_connr->tcpstateflags = UIP_CLOSED;
// 2080           UIP_TCP_BUF->flags = TCP_RST | TCP_ACK;
// 2081           goto tcp_send_nodata;
// 2082         }
// 2083 
// 2084         if(uip_flags & UIP_CLOSE) {
// 2085           uip_slen = 0;
// 2086           uip_connr->len = 1;
// 2087           uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
// 2088           uip_connr->nrtx = 0;
// 2089           UIP_TCP_BUF->flags = TCP_FIN | TCP_ACK;
// 2090           goto tcp_send_nodata;
// 2091         }
// 2092 
// 2093         /* If uip_slen > 0, the application has data to be sent. */
// 2094         if(uip_slen > 0) {
// 2095 
// 2096           /* If the connection has acknowledged data, the contents of
// 2097              the ->len variable should be discarded. */
// 2098           if((uip_flags & UIP_ACKDATA) != 0) {
// 2099             uip_connr->len = 0;
// 2100           }
// 2101 
// 2102           /* If the ->len variable is non-zero the connection has
// 2103              already data in transit and cannot send anymore right
// 2104              now. */
// 2105           if(uip_connr->len == 0) {
// 2106 
// 2107             /* The application cannot send more than what is allowed by
// 2108                the mss (the minumum of the MSS and the available
// 2109                window). */
// 2110             if(uip_slen > uip_connr->mss) {
// 2111               uip_slen = uip_connr->mss;
// 2112             }
// 2113 
// 2114             /* Remember how much data we send out now so that we know
// 2115                when everything has been acknowledged. */
// 2116             uip_connr->len = uip_slen;
// 2117           } else {
// 2118 
// 2119             /* If the application already had unacknowledged data, we
// 2120                make sure that the application does not send (i.e.,
// 2121                retransmit) out more than it previously sent out. */
// 2122             uip_slen = uip_connr->len;
// 2123           }
// 2124         }
// 2125         uip_connr->nrtx = 0;
// 2126       apprexmit:
// 2127         uip_appdata = uip_sappdata;
// 2128       
// 2129         /* If the application has data to be sent, or if the incoming
// 2130            packet had new data in it, we must send out a packet. */
// 2131         if(uip_slen > 0 && uip_connr->len > 0) {
// 2132           /* Add the length of the IP and TCP headers. */
// 2133           uip_len = uip_connr->len + UIP_TCPIP_HLEN;
// 2134           /* We always set the ACK flag in response packets. */
// 2135           UIP_TCP_BUF->flags = TCP_ACK | TCP_PSH;
// 2136           /* Send the packet. */
// 2137           goto tcp_send_noopts;
// 2138         }
// 2139         /* If there is no data to send, just send out a pure ACK if
// 2140            there is newdata. */
// 2141         if(uip_flags & UIP_NEWDATA) {
// 2142           uip_len = UIP_TCPIP_HLEN;
// 2143           UIP_TCP_BUF->flags = TCP_ACK;
// 2144           goto tcp_send_noopts;
// 2145         }
// 2146       }
// 2147       goto drop;
// 2148     case UIP_LAST_ACK:
// 2149       /* We can close this connection if the peer has acknowledged our
// 2150          FIN. This is indicated by the UIP_ACKDATA flag. */
// 2151       if(uip_flags & UIP_ACKDATA) {
// 2152         uip_connr->tcpstateflags = UIP_CLOSED;
// 2153         uip_flags = UIP_CLOSE;
// 2154         UIP_APPCALL();
// 2155       }
// 2156       break;
// 2157     
// 2158     case UIP_FIN_WAIT_1:
// 2159       /* The application has closed the connection, but the remote host
// 2160          hasn't closed its end yet. Thus we do nothing but wait for a
// 2161          FIN from the other side. */
// 2162       if(uip_len > 0) {
// 2163         uip_add_rcv_nxt(uip_len);
// 2164       }
// 2165       if(UIP_TCP_BUF->flags & TCP_FIN) {
// 2166         if(uip_flags & UIP_ACKDATA) {
// 2167           uip_connr->tcpstateflags = UIP_TIME_WAIT;
// 2168           uip_connr->timer = 0;
// 2169           uip_connr->len = 0;
// 2170         } else {
// 2171           uip_connr->tcpstateflags = UIP_CLOSING;
// 2172         }
// 2173         uip_add_rcv_nxt(1);
// 2174         uip_flags = UIP_CLOSE;
// 2175         UIP_APPCALL();
// 2176         goto tcp_send_ack;
// 2177       } else if(uip_flags & UIP_ACKDATA) {
// 2178         uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
// 2179         uip_connr->len = 0;
// 2180         goto drop;
// 2181       }
// 2182       if(uip_len > 0) {
// 2183         goto tcp_send_ack;
// 2184       }
// 2185       goto drop;
// 2186       
// 2187     case UIP_FIN_WAIT_2:
// 2188       if(uip_len > 0) {
// 2189         uip_add_rcv_nxt(uip_len);
// 2190       }
// 2191       if(UIP_TCP_BUF->flags & TCP_FIN) {
// 2192         uip_connr->tcpstateflags = UIP_TIME_WAIT;
// 2193         uip_connr->timer = 0;
// 2194         uip_add_rcv_nxt(1);
// 2195         uip_flags = UIP_CLOSE;
// 2196         UIP_APPCALL();
// 2197         goto tcp_send_ack;
// 2198       }
// 2199       if(uip_len > 0) {
// 2200         goto tcp_send_ack;
// 2201       }
// 2202       goto drop;
// 2203 
// 2204     case UIP_TIME_WAIT:
// 2205       goto tcp_send_ack;
// 2206     
// 2207     case UIP_CLOSING:
// 2208       if(uip_flags & UIP_ACKDATA) {
// 2209         uip_connr->tcpstateflags = UIP_TIME_WAIT;
// 2210         uip_connr->timer = 0;
// 2211       }
// 2212   }
// 2213   goto drop;
// 2214   
// 2215   /* We jump here when we are ready to send the packet, and just want
// 2216      to set the appropriate TCP sequence numbers in the TCP header. */
// 2217  tcp_send_ack:
// 2218   UIP_TCP_BUF->flags = TCP_ACK;
// 2219 
// 2220  tcp_send_nodata:
// 2221   uip_len = UIP_IPTCPH_LEN;
// 2222 
// 2223  tcp_send_noopts:
// 2224   UIP_TCP_BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
// 2225 
// 2226   /* We're done with the input processing. We are now ready to send a
// 2227      reply. Our job is to fill in all the fields of the TCP and IP
// 2228      headers before calculating the checksum and finally send the
// 2229      packet. */
// 2230  tcp_send:
// 2231   PRINTF("In tcp_send\n");
// 2232    
// 2233   UIP_TCP_BUF->ackno[0] = uip_connr->rcv_nxt[0];
// 2234   UIP_TCP_BUF->ackno[1] = uip_connr->rcv_nxt[1];
// 2235   UIP_TCP_BUF->ackno[2] = uip_connr->rcv_nxt[2];
// 2236   UIP_TCP_BUF->ackno[3] = uip_connr->rcv_nxt[3];
// 2237   
// 2238   UIP_TCP_BUF->seqno[0] = uip_connr->snd_nxt[0];
// 2239   UIP_TCP_BUF->seqno[1] = uip_connr->snd_nxt[1];
// 2240   UIP_TCP_BUF->seqno[2] = uip_connr->snd_nxt[2];
// 2241   UIP_TCP_BUF->seqno[3] = uip_connr->snd_nxt[3];
// 2242 
// 2243   UIP_IP_BUF->proto = UIP_PROTO_TCP;
// 2244 
// 2245   UIP_TCP_BUF->srcport  = uip_connr->lport;
// 2246   UIP_TCP_BUF->destport = uip_connr->rport;
// 2247 
// 2248   uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &uip_connr->ripaddr);
// 2249   uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
// 2250   PRINTF("Sending TCP packet to ");
// 2251   PRINT6ADDR(&UIP_IP_BUF->destipaddr);
// 2252   PRINTF(" from ");
// 2253   PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
// 2254   PRINTF("\n");
// 2255 
// 2256   if(uip_connr->tcpstateflags & UIP_STOPPED) {
// 2257     /* If the connection has issued uip_stop(), we advertise a zero
// 2258        window so that the remote host will stop sending data. */
// 2259     UIP_TCP_BUF->wnd[0] = UIP_TCP_BUF->wnd[1] = 0;
// 2260   } else {
// 2261     UIP_TCP_BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
// 2262     UIP_TCP_BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
// 2263   }
// 2264 
// 2265  tcp_send_noconn:
// 2266   UIP_IP_BUF->ttl = uip_ds6_if.cur_hop_limit;
// 2267   UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
// 2268   UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
// 2269 
// 2270   UIP_TCP_BUF->urgp[0] = UIP_TCP_BUF->urgp[1] = 0;
// 2271   
// 2272   /* Calculate TCP checksum. */
// 2273   UIP_TCP_BUF->tcpchksum = 0;
// 2274   UIP_TCP_BUF->tcpchksum = ~(uip_tcpchksum());
// 2275   UIP_STAT(++uip_stat.tcp.sent);
// 2276 
// 2277 #endif /* UIP_TCP */
// 2278 #if UIP_UDP
// 2279  ip_send_nolen:
// 2280 #endif
// 2281   UIP_IP_BUF->vtc = 0x60;
// 2282   UIP_IP_BUF->tcflow = 0x00;
// 2283   UIP_IP_BUF->flow = 0x00;
// 2284  send:
// 2285   PRINTF("Sending packet with length %d (%d)\n", uip_len,
// 2286          (UIP_IP_BUF->len[0] << 8) | UIP_IP_BUF->len[1]);
// 2287   
// 2288   UIP_STAT(++uip_stat.ip.sent);
// 2289   /* Return and let the caller do the actual transmission. */
// 2290   uip_flags = 0;
// 2291   return;
// 2292 
// 2293  drop:
// 2294   uip_len = 0;
??uip_process_3:
        MOV     DPTR,#uip_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2295   uip_ext_len = 0;
        MOV     DPTR,#uip_ext_len
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2296   uip_ext_bitmap = 0;
        MOV     DPTR,#uip_ext_bitmap
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2297   uip_flags = 0;
        MOV     DPTR,#uip_flags
        MOV     A,#0x0
        MOVX    @DPTR,A
// 2298   return;
??uip_process_5:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
??uip_process_4:
        MOV     DPTR,#uip_aligned_buf
        MOVX    A,@DPTR
        ANL     A,#0xf0
        XRL     A,#0x60
        JNZ     ??uip_process_3
        MOV     DPTR,#uip_len
        PUSH    DPL
          CFI CFA_SP SP+-1
        PUSH    DPH
          CFI CFA_SP SP+-2
        MOV     DPTR,#uip_aligned_buf + 4
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        POP     DPH
          CFI CFA_SP SP+-1
        POP     DPL
          CFI CFA_SP SP+0
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JC      ??uip_process_3
        MOV     DPTR,#uip_aligned_buf + 4
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        CLR     A
        XCH     A,R0
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R3,#0x0
        MOV     A,R0
        ADD     A,R2
        MOV     R0,A
        MOV     A,R1
        ADDC    A,R3
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x28
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_len
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     $+5
        LJMP    ??uip_process_3 & 0xFFFF
        MOV     DPTR,#uip_next_hdr
        MOV     A,#(uip_aligned_buf + 6) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((uip_aligned_buf + 6) >> 8) & 0xff
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_bitmap
        MOV     A,#0x0
        MOVX    @DPTR,A
        MOV     DPTR,#uip_next_hdr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        JNZ     ??uip_process_6
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
        ; Setup parameters for call to function ext_hdr_options_process
        LCALL   ??ext_hdr_options_process?relay
        MOV     A,R1
        JZ      ??uip_process_7
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_3 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_8 & 0xFFFF
        SJMP    ??uip_process_6
??uip_process_7:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x28
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_next_hdr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        ADD     A,#0x8
        MOV     R0,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
??uip_process_6:
        ; Setup parameters for call to function uip_ds6_addr_lookup
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??uip_ds6_addr_lookup?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??uip_process_9 & 0xFFFF
        ; Setup parameters for call to function uip_ds6_maddr_lookup
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??uip_ds6_maddr_lookup?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??uip_process_9 & 0xFFFF
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        XRL     A,#0xff
        JNZ     $+5
        LJMP    ??uip_process_10 & 0xFFFF
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        XRL     A,#0xfe
        JNZ     ??uip_process_11
        MOV     DPTR,#uip_aligned_buf + 25
        MOVX    A,@DPTR
        XRL     A,#0x80
        JNZ     $+5
        LJMP    ??uip_process_10 & 0xFFFF
??uip_process_11:
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        XRL     A,#0xfe
        JNZ     ??uip_process_12
        MOV     DPTR,#uip_aligned_buf + 9
        MOVX    A,@DPTR
        XRL     A,#0x80
        JNZ     $+5
        LJMP    ??uip_process_10 & 0xFFFF
??uip_process_12:
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 10
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 12
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 14
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 16
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 18
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 20
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_13
        MOV     DPTR,#uip_aligned_buf + 22
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??uip_process_10 & 0xFFFF
??uip_process_13:
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 32
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 34
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 36
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 38
        MOVX    A,@DPTR
        JNZ     ??uip_process_14
        MOV     DPTR,#uip_aligned_buf + 39
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??uip_process_10
??uip_process_14:
        MOV     DPTR,#uip_len
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,#0x1
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#0x5
        JC      ??uip_process_15
        ; Setup parameters for call to function uip_icmp6_error_output
        MOV     DPTR,#__Constant_500
        LCALL   ?PUSH_XSTACK8_X_FOUR
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R2,#0x0
        MOV     R1,#0x2
        LCALL   ??uip_icmp6_error_output?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_15:
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x2
        JNC     ??uip_process_16
        ; Setup parameters for call to function uip_icmp6_error_output
        MOV     DPTR,#__Constant_0
        LCALL   ?PUSH_XSTACK8_X_FOUR
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R2,#0x0
        MOV     R1,#0x3
        LCALL   ??uip_icmp6_error_output?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_16:
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    A,@DPTR
        ADD     A,#-0x1
        MOVX    @DPTR,A
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_10:
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        XRL     A,#0xfe
        JZ      $+5
        LJMP    ??uip_process_3 & 0xFFFF
        MOV     DPTR,#uip_aligned_buf + 9
        MOVX    A,@DPTR
        XRL     A,#0x80
        JZ      $+5
        LJMP    ??uip_process_3 & 0xFFFF
        MOV     DPTR,#uip_aligned_buf + 8
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 10
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 12
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 14
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 16
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 18
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 20
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_17
        MOV     DPTR,#uip_aligned_buf + 22
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     $+5
        LJMP    ??uip_process_3 & 0xFFFF
??uip_process_17:
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 26
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 28
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 30
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 32
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 34
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 36
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 38
        MOVX    A,@DPTR
        JNZ     ??uip_process_18
        MOV     DPTR,#uip_aligned_buf + 39
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??uip_process_19
??uip_process_18:
        MOV     DPTR,#uip_aligned_buf + 24
        MOVX    A,@DPTR
        XRL     A,#0xff
        JZ      ??uip_process_19
        ; Setup parameters for call to function uip_ds6_is_addr_onlink
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??uip_ds6_is_addr_onlink?relay
        MOV     A,R1
        JNZ     ??uip_process_19
        ; Setup parameters for call to function uip_icmp6_error_output
        MOV     DPTR,#__Constant_0
        LCALL   ?PUSH_XSTACK8_X_FOUR
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R2,#0x2
        MOV     R1,#0x1
        LCALL   ??uip_icmp6_error_output?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_19:
        LJMP    ??uip_process_3 & 0xFFFF
??uip_process_20:
        ; Setup parameters for call to function uip_icmp6chksum
        LCALL   ??uip_icmp6chksum?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#-0x1
        XRL     A,?V0 + 0
        JNZ     ??uip_process_21
        MOV     A,#-0x1
        XRL     A,?V0 + 1
??uip_process_21:
        JZ      $+5
        LJMP    ??uip_process_3 & 0xFFFF
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#(uip_aligned_buf + 40) & 0xff
        ADD     A,R0
        MOV     DPL,A
        MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
        ADDC    A,R1
        MOV     DPH,A
        MOVX    A,@DPTR
        ADD     A,#-0x80
        JNZ     $+5
        LJMP    ??uip_process_22 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_23 & 0xFFFF
        ADD     A,#-0x4
        JNZ     $+5
        LJMP    ??uip_process_24 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_25 & 0xFFFF
        DEC     A
        JZ      ??uip_process_26
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_27 & 0xFFFF
        LJMP    ??uip_process_28 & 0xFFFF
??uip_process_26:
        ; Setup parameters for call to function uip_nd6_ns_input
        LCALL   ??uip_nd6_ns_input?relay
        LJMP    ??uip_process_29 & 0xFFFF
??uip_process_30:
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.0
        JNC     $+5
        LJMP    ??uip_process_31 & 0xFFFF
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.0
        MOVX    @DPTR,A
        ; Setup parameters for call to function ext_hdr_options_process
        LCALL   ??ext_hdr_options_process?relay
        MOV     A,R1
        JZ      ??uip_process_32
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_3 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_8 & 0xFFFF
        SJMP    ??uip_process_9
??uip_process_32:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x28
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_next_hdr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        ADD     A,#0x8
        MOV     R0,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
??uip_process_9:
        MOV     DPTR,#uip_next_hdr
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        JZ      ??uip_process_30
        ADD     A,#-0x11
        JZ      ??uip_process_33
        ADD     A,#-0x1a
        JNZ     $+5
        LJMP    ??uip_process_34 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_3 & 0xFFFF
        ADD     A,#-0xe
        JNZ     $+5
        LJMP    ??uip_process_20 & 0xFFFF
        DEC     A
        JNZ     $+5
        LJMP    ??uip_process_3 & 0xFFFF
        DEC     A
        JZ      ??uip_process_35
        LJMP    ??uip_process_31 & 0xFFFF
??uip_process_33:
        ; Setup parameters for call to function remove_ext_hdr
        LCALL   ??remove_ext_hdr?relay
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        ADD     A,#-0x30
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_appdata
        MOV     A,#(uip_aligned_buf + 48) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((uip_aligned_buf + 48) >> 8) & 0xff
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 46
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_36 & 0xFFFF
??uip_process_37:
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_38 & 0xFFFF
        LJMP    ??uip_process_3 & 0xFFFF
??uip_process_35:
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.1
        JNC     ??uip_process_39
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.6
        JNC     $+5
        LJMP    ??uip_process_31 & 0xFFFF
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.6
        MOVX    @DPTR,A
        SJMP    ??uip_process_40
??uip_process_39:
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.1
        MOVX    @DPTR,A
??uip_process_40:
        ; Setup parameters for call to function ext_hdr_options_process
        LCALL   ??ext_hdr_options_process?relay
        MOV     A,R1
        JZ      ??uip_process_41
        DEC     A
        JZ      ??uip_process_42
        DEC     A
        JZ      ??uip_process_43
        SJMP    ??uip_process_44
??uip_process_41:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x28
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_next_hdr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        ADD     A,#0x8
        MOV     R0,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
??uip_process_44:
        LJMP    ??uip_process_9 & 0xFFFF
??uip_process_42:
        LJMP    ??uip_process_3 & 0xFFFF
??uip_process_43:
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_34:
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        MOV     C,0xE0 /* A   */.2
        JNC     $+5
        LJMP    ??uip_process_31 & 0xFFFF
        MOV     DPTR,#uip_ext_bitmap
        MOVX    A,@DPTR
        SETB    0xE0 /* A   */.2
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x2b
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#0x1
        JC      ??uip_process_45
        ; Setup parameters for call to function uip_icmp6_error_output
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        ADD     A,#0x2a
        MOV     ?V0 + 0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
        MOV     A,?V0 + 1
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_FOUR
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R2,#0x0
        MOV     R1,#0x4
        LCALL   ??uip_icmp6_error_output?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_45:
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x28
        MOV     R0,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_next_hdr
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        MOV     R0,A
        MOV     R1,#0x0
        MOV     A,#uip_aligned_buf & 0xff
        ADD     A,R0
        MOV     R0,A
        MOV     A,#(uip_aligned_buf >> 8) & 0xff
        ADDC    A,R1
        MOV     R1,A
        MOV     A,R0
        ADD     A,#0x29
        MOV     DPL,A
        MOV     A,R1
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        RLC     A
        RLC     A
        RLC     A
        ANL     A,#0xf8
        ADD     A,#0x8
        MOV     R0,A
        MOV     DPTR,#uip_ext_len
        MOVX    A,@DPTR
        ADD     A,R0
        MOVX    @DPTR,A
        LJMP    ??uip_process_9 & 0xFFFF
??uip_process_31:
        ; Setup parameters for call to function uip_icmp6_error_output
        MOV     DPTR,#uip_next_hdr
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#uip_aligned_buf & 0xff
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#(uip_aligned_buf >> 8) & 0xff
        MOV     ?V0 + 1,A
        MOV     A,?V0 + 1
        RLC     A
        SUBB    A,0xE0 /* A   */
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_FOUR
          CFI CFA_XSP16 add(XSP16, 16)
        MOV     R2,#0x1
        MOV     R1,#0x4
        LCALL   ??uip_icmp6_error_output?relay
        MOV     A,#0x4
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        LJMP    ??uip_process_8 & 0xFFFF
??uip_process_27:
        ; Setup parameters for call to function uip_nd6_na_input
        LCALL   ??uip_nd6_na_input?relay
        SJMP    ??uip_process_29
??uip_process_24:
        MOV     DPTR,#uip_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??uip_process_29
??uip_process_25:
        MOV     DPTR,#uip_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??uip_process_29
??uip_process_22:
        ; Setup parameters for call to function uip_icmp6_echo_request_input
        LCALL   ??uip_icmp6_echo_request_input?relay
        SJMP    ??uip_process_29
??uip_process_23:
        MOV     DPTR,#uip_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        SJMP    ??uip_process_29
??uip_process_28:
        MOV     DPTR,#uip_len
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
??uip_process_29:
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_8 & 0xFFFF
        LJMP    ??uip_process_3 & 0xFFFF
??uip_process_36:
        ; Setup parameters for call to function uip_udpchksum
        LCALL   ??uip_udpchksum?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,#-0x1
        XRL     A,?V0 + 0
        JNZ     ??uip_process_46
        MOV     A,#-0x1
        XRL     A,?V0 + 1
??uip_process_46:
        JNZ     $+5
        LJMP    ??uip_process_37 & 0xFFFF
        LJMP    ??uip_process_3 & 0xFFFF
??uip_process_38:
        MOV     DPTR,#uip_udp_conn
        MOV     A,#uip_udp_conns & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(uip_udp_conns >> 8) & 0xff
        MOVX    @DPTR,A
        SJMP    ??uip_process_47
??uip_process_48:
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        ADD     A,#0x19
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_udp_conn
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
??uip_process_47:
        MOV     DPTR,#uip_udp_conn
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,#(uip_udp_conns + 250) & 0xff
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#((uip_udp_conns + 250) >> 8) & 0xff
        JC      $+5
        LJMP    ??uip_process_3 & 0xFFFF
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??uip_process_48
        MOV     DPTR,#uip_aligned_buf + 42
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R2
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,R2
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??uip_process_49
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??uip_process_49:
        JNZ     ??uip_process_48
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x12
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??uip_process_50
        MOV     DPTR,#uip_aligned_buf + 40
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R2
        ADD     A,#0x12
        MOV     DPL,A
        MOV     A,R2
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??uip_process_51
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,R1
??uip_process_51:
        JZ      $+5
        LJMP    ??uip_process_48 & 0xFFFF
??uip_process_50:
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_52 & 0xFFFF
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_52 & 0xFFFF
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPH,A
        MOV     DPL,R0
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      $+5
        LJMP    ??uip_process_52 & 0xFFFF
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x6
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_52
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x8
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_52
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0xa
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_52
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0xc
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_52
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0xe
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??uip_process_53
??uip_process_52:
        ; Setup parameters for call to function memcmp
        MOV     ?V0 + 0,#0x10
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??memcmp?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      $+5
        LJMP    ??uip_process_48 & 0xFFFF
??uip_process_53:
        MOV     DPTR,#uip_conn
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        MOV     DPTR,#uip_flags
        MOV     A,#0x2
        MOVX    @DPTR,A
        MOV     R0,#(uip_aligned_buf + 48) & 0xff
        MOV     R1,#((uip_aligned_buf + 48) >> 8) & 0xff
        MOV     DPTR,#uip_appdata
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_sappdata
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_slen
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        ; Setup parameters for call to function tcpip_uipcall
        LCALL   ??tcpip_uipcall?relay
        LJMP    ??uip_process_1 & 0xFFFF
??uip_process_2:
        MOV     DPTR,#uip_slen
        MOVX    A,@DPTR
        ADD     A,#0x30
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        MOV     DPTR,#uip_len
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        ADD     A,#-0x28
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#-0x1
        MOV     R1,A
        CLR     A
        MOV     A,R1
        MOV     R0,A
        MOV     DPTR,#uip_aligned_buf + 4
        MOVX    @DPTR,A
        MOV     DPTR,#uip_len
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ADD     A,#-0x28
        MOV     DPTR,#uip_aligned_buf + 5
        MOVX    @DPTR,A
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x14
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     DPTR,#uip_aligned_buf + 7
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 6
        MOV     A,#0x11
        MOVX    @DPTR,A
        MOV     DPTR,#uip_slen
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R3,A
        CLR     A
        XCH     A,R2
        MOV     R3,A
        MOV     DPTR,#uip_slen
        MOVX    A,@DPTR
        ADD     A,#0x8
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#0x0
        MOV     R1,A
        CLR     A
        XCH     A,R1
        MOV     R0,A
        MOV     A,R2
        ORL     A,R0
        MOV     R0,A
        MOV     A,R3
        ORL     A,R1
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 44
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 46
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x10
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 40
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        XCH     A,R0
        ADD     A,#0x12
        MOV     DPL,A
        MOV     A,R0
        ADDC    A,#0x0
        MOV     DPH,A
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 42
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 0,#0x10
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
          CFI CFA_XSP16 add(XSP16, 14)
        MOV     DPTR,#uip_udp_conn
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     R2,#(uip_aligned_buf + 24) & 0xff
        MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 12)
        ; Setup parameters for call to function uip_ds6_select_src
        MOV     R4,#(uip_aligned_buf + 24) & 0xff
        MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
        MOV     R2,#(uip_aligned_buf + 8) & 0xff
        MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
        LCALL   ??uip_ds6_select_src?relay
        MOV     DPTR,#uip_appdata
        MOV     A,#(uip_aligned_buf + 60) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((uip_aligned_buf + 60) >> 8) & 0xff
        MOVX    @DPTR,A
        ; Setup parameters for call to function uip_udpchksum
        LCALL   ??uip_udpchksum?relay
        MOV     A,R2
        CPL     A
        MOV     R0,A
        MOV     A,R3
        CPL     A
        MOV     R1,A
        MOV     DPTR,#uip_aligned_buf + 46
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 46
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JNZ     ??uip_process_54
        MOV     DPTR,#uip_aligned_buf + 46
        MOV     A,#-0x1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x1
        MOVX    @DPTR,A
??uip_process_54:
        MOV     DPTR,#uip_aligned_buf
        MOV     A,#0x60
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 1
        MOV     A,#0x0
        MOVX    @DPTR,A
        MOV     DPTR,#uip_aligned_buf + 2
        MOV     A,#0x0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#0x0
        MOVX    @DPTR,A
??uip_process_8:
        MOV     DPTR,#uip_flags
        MOV     A,#0x0
        MOVX    @DPTR,A
        LJMP    ??uip_process_5 & 0xFFFF
          CFI EndBlock cfiBlock10
// 2299 }
// 2300 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2301 uint16_t
// 2302 uip_htons(uint16_t val)
uip_htons:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function uip_htons
        CODE
// 2303 {
        ; Saved register size: 0
        ; Auto size: 0
// 2304   return UIP_HTONS(val);
        MOV     A,R2
        MOV     R0,A
        MOV     A,R3
        MOV     R1,A
        CLR     A
        XCH     A,R0
        MOV     R1,A
        CLR     A
        XCH     A,R3
        MOV     R2,A
        MOV     A,R0
        ORL     A,R2
        MOV     R2,A
        MOV     A,R1
        ORL     A,R3
        MOV     R3,A
        LJMP    ?BRET
          CFI EndBlock cfiBlock11
// 2305 }
// 2306 

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2307 uint32_t
// 2308 uip_htonl(uint32_t val)
uip_htonl:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function uip_htonl
        CODE
// 2309 {
        MOV     A,#-0x18
        LCALL   ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V15 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V14 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V13 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI V12 load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI V11 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI V10 load(1, XDATA, add(CFA_XSP16, literal(-12)))
          CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-13)))
          CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-14)))
          CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-15)))
          CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-16)))
          CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-17)))
          CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-18)))
          CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-19)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-20)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-21)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-22)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-23)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-24)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 24)
        ; Saved register size: 24
        ; Auto size: 0
        MOV     ?V0 + 8,R2
        MOV     ?V0 + 9,R3
        MOV     ?V0 + 10,R4
        MOV     ?V0 + 11,R5
// 2310   return UIP_HTONL(val);
        MOV     ?V0 + 4,?V0 + 8
        MOV     ?V0 + 5,?V0 + 9
        CLR     A
        XCH     A,?V0 + 4
        MOV     ?V0 + 5,A
        MOV     ?V0 + 0,?V0 + 8
        MOV     ?V0 + 1,?V0 + 9
        CLR     A
        XCH     A,?V0 + 1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 4
        ORL     A,?V0 + 0
        MOV     ?V0 + 12,A
        MOV     A,?V0 + 5
        ORL     A,?V0 + 1
        MOV     ?V0 + 13,A
        CLR     A
        MOV     ?V0 + 14,A
        MOV     ?V0 + 15,A
        MOV     A,#0x10
        MOV     R0,#?V0 + 12
        LCALL   ?L_SHL
        MOV     ?V0 + 4,?V0 + 8
        MOV     ?V0 + 5,?V0 + 9
        MOV     ?V0 + 6,?V0 + 10
        MOV     ?V0 + 7,?V0 + 11
        MOV     A,#0x10
        MOV     R0,#?V0 + 4
        LCALL   ?UL_SHR
        CLR     A
        XCH     A,?V0 + 4
        MOV     ?V0 + 5,A
        MOV     A,#0x10
        MOV     R0,#?V0 + 8
        LCALL   ?UL_SHR
        MOV     ?V0 + 0,?V0 + 8
        MOV     ?V0 + 1,?V0 + 9
        CLR     A
        XCH     A,?V0 + 1
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 4
        ORL     A,?V0 + 0
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 5
        ORL     A,?V0 + 1
        MOV     ?V0 + 1,A
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 12
        MOV     R1,#?V0 + 0
        LCALL   ?L_IOR
        MOV     R2,?V0 + 12
        MOV     R3,?V0 + 13
        MOV     R4,?V0 + 14
        MOV     R5,?V0 + 15
        MOV     R7,#0x10
        LJMP    ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock12
// 2311 }
// 2312 /*---------------------------------------------------------------------------*/

        RSEG BANKED_CODE:CODE:NOROOT(0)
// 2313 void
// 2314 uip_send(const void *data, int len)
uip_send:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function uip_send
        CODE
// 2315 {
        FUNCALL uip_send, memcpy
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 2, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 2, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
          CFI DPL0 Frame(CFA_SP, 4)
          CFI CFA_SP SP+-4
        PUSH    DPH
          CFI DPH0 Frame(CFA_SP, 5)
          CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
// 2316   int copylen;
// 2317 #define MIN(a,b) ((a) < (b)? (a): (b))
// 2318   copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
// 2319                 (int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
        MOV     DPTR,#uip_sappdata
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#(uip_aligned_buf + 60) & 0xff
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#((uip_aligned_buf + 60) >> 8) & 0xff
        MOV     R1,A
        MOV     A,#-0x4c
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        MOV     A,#0x0
        SUBB    A,R1
        MOV     R1,A
        CLR     C
        MOV     A,R4
        SUBB    A,R0
        MOV     A,R5
        SUBB    A,R1
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JNC     ??uip_send_0
        MOV     A,R4
        MOV     R0,A
        MOV     A,R5
        MOV     R1,A
        SJMP    ??uip_send_1
??uip_send_0:
        MOV     DPTR,#uip_sappdata
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,#(uip_aligned_buf + 60) & 0xff
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,#((uip_aligned_buf + 60) >> 8) & 0xff
        MOV     R1,A
        MOV     A,#-0x4c
        CLR     C
        SUBB    A,R0
        MOV     R0,A
        MOV     A,#0x0
        SUBB    A,R1
        MOV     R1,A
// 2320   if(copylen > 0) {
??uip_send_1:
        CLR     C
        MOV     A,R0
        SUBB    A,#0x1
        MOV     A,R1
        SUBB    A,#0x0
        MOV     C,0xD0 /* PSW */.2
        XRL     A,PSW
        RLC     A
        JC      ??uip_send_2
// 2321     uip_slen = copylen;
        MOV     DPTR,#uip_slen
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
// 2322     if(data != uip_sappdata) {
        MOV     DPTR,#uip_sappdata
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R2
        XRL     A,R0
        JNZ     ??uip_send_3
        MOV     A,R3
        XRL     A,R1
??uip_send_3:
        JZ      ??uip_send_2
// 2323       memcpy(uip_sappdata, (data), uip_slen);
        ; Setup parameters for call to function memcpy
        MOV     DPTR,#uip_slen
        LCALL   ?PUSH_XSTACK8_X_TWO
          CFI CFA_XSP16 add(XSP16, 2)
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     DPTR,#uip_sappdata
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R3,A
        LCALL   ??memcpy?relay
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
          CFI CFA_XSP16 XSP16+0
// 2324     }
// 2325   }
// 2326 }
??uip_send_2:
        POP     DPH
          CFI DPH0 SameValue
          CFI CFA_SP SP+-4
        POP     DPL
          CFI DPL0 SameValue
          CFI CFA_SP SP+-3
        LJMP    ?BRET
          CFI EndBlock cfiBlock13

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_28:
        DS 4
        REQUIRE `?<Initializer for __Constant_28>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_28>`:
        DATA32
        DD 40

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_500:
        DS 4
        REQUIRE `?<Initializer for __Constant_500>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_500>`:
        DATA32
        DD 1280

        RSEG XDATA_I:XDATA:NOROOT(0)
        DATA32
__Constant_0:
        DS 4
        REQUIRE `?<Initializer for __Constant_0>`
        REQUIRE __INIT_XDATA_I

        RSEG XDATA_ID:CODE:NOROOT(0)
`?<Initializer for __Constant_0>`:
        DATA32
        DD 0

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??chksum?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    chksum

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_chksum?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_chksum

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_ipchksum?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_ipchksum

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??upper_layer_chksum?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    upper_layer_chksum

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_icmp6chksum?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_icmp6chksum

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_udpchksum?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_udpchksum

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_init?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_init

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??remove_ext_hdr?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    remove_ext_hdr

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_udp_new?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_udp_new

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ext_hdr_options_process?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    ext_hdr_options_process

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_process?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_process

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_htons?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_htons

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_htonl?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_htonl

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??uip_send?relay:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    uip_send

        END
// 2327 /*---------------------------------------------------------------------------*/
// 2328 /** @} */
// 2329 #endif /* UIP_CONF_IPV6 */
// 
// 4 469 bytes in segment BANKED_CODE
//    84 bytes in segment BANK_RELAYS
//    12 bytes in segment XDATA_I
//    12 bytes in segment XDATA_ID
//   519 bytes in segment XDATA_Z
// 
// 4 553 bytes of CODE  memory (+ 12 bytes shared)
//   519 bytes of XDATA memory (+ 12 bytes shared)
//
//Errors: none
//Warnings: none
