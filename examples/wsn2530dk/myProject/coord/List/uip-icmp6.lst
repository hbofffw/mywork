###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             03/Apr/2014  10:45:53 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\myWork\myWork\core\net\uip-icmp6.c              #
#    Command line       =  D:\myWork\myWork\core\net\uip-icmp6.c -D           #
#                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC             #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\ -lA D:\myWork\myWork\examples\wsn2530dk\my #
#                          Project\coord\List\ --diag_suppress                #
#                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o          #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\ -e --no_cse --no_unroll --no_inline         #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 --preinclude D:\myWork\myWork\examples\wsn2530d #
#                          k\myProject\..\..\..\cpu\cc253x\cc253x.h -I        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\cpu\cc253x\ -I D:\myWork\myWork\examples\wsn2 #
#                          530dk\myProject\..\..\..\platform\wsn2530dk\ -I    #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\core\ -I D:\myWork\myWork\examples\wsn2530dk\ #
#                          myProject\..\..\..\apps\ -I                        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\ -Ol #
#    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\uip-icmp6.lst                               #
#    Object file        =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\uip-icmp6.r51                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\myWork\myWork\core\net\uip-icmp6.c
      1          /**
      2           * \addtogroup uip6
      3           * @{
      4           */
      5          
      6          /**
      7           * \file
      8           *         ICMPv6 echo request and error messages (RFC 4443)
      9           * \author Julien Abeille <jabeille@cisco.com> 
     10           * \author Mathilde Durvy <mdurvy@cisco.com>
     11           */
     12          
     13          /*
     14           * Copyright (c) 2001-2003, Adam Dunkels.
     15           * All rights reserved.
     16           *
     17           * Redistribution and use in source and binary forms, with or without
     18           * modification, are permitted provided that the following conditions
     19           * are met:
     20           * 1. Redistributions of source code must retain the above copyright
     21           *    notice, this list of conditions and the following disclaimer.
     22           * 2. Redistributions in binary form must reproduce the above copyright
     23           *    notice, this list of conditions and the following disclaimer in the
     24           *    documentation and/or other materials provided with the distribution.
     25           * 3. The name of the author may not be used to endorse or promote
     26           *    products derived from this software without specific prior
     27           *    written permission.
     28           *
     29           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
     30           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     31           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     32           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
     33           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     34           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
     35           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     36           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
     37           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     38           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     39           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     40           *
     41           * This file is part of the uIP TCP/IP stack.
     42           *
     43           */
     44          
     45          #include <string.h>
     46          #include "net/uip-ds6.h"
     47          #include "net/uip-icmp6.h"
     48          #include "contiki-default-conf.h"
     49          
     50          #define DEBUG 0
     51          #if DEBUG
     52          #include <stdio.h>
     53          #define PRINTF(...) printf(__VA_ARGS__)
     54          #define PRINT6ADDR(addr) PRINTF(" %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x ", ((uint8_t *)addr)[0], ((uint8_t *)addr)[1], ((uint8_t *)addr)[2], ((uint8_t *)addr)[3], ((uint8_t *)addr)[4], ((uint8_t *)addr)[5], ((uint8_t *)addr)[6], ((uint8_t *)addr)[7], ((uint8_t *)addr)[8], ((uint8_t *)addr)[9], ((uint8_t *)addr)[10], ((uint8_t *)addr)[11], ((uint8_t *)addr)[12], ((uint8_t *)addr)[13], ((uint8_t *)addr)[14], ((uint8_t *)addr)[15])
     55          #define PRINTLLADDR(lladdr) PRINTF(" %02x:%02x:%02x:%02x:%02x:%02x ",lladdr->addr[0], lladdr->addr[1], lladdr->addr[2], lladdr->addr[3],lladdr->addr[4], lladdr->addr[5])
     56          #else
     57          #define PRINTF(...)
     58          #define PRINT6ADDR(addr)
     59          #endif
     60          
     61          #define UIP_IP_BUF                ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
     62          #define UIP_ICMP_BUF            ((struct uip_icmp_hdr *)&uip_buf[uip_l2_l3_hdr_len])
     63          #define UIP_ICMP6_ERROR_BUF  ((struct uip_icmp6_error *)&uip_buf[uip_l2_l3_icmp_hdr_len])
     64          #define UIP_EXT_BUF              ((struct uip_ext_hdr *)&uip_buf[uip_l2_l3_hdr_len])
     65          #define UIP_FIRST_EXT_BUF        ((struct uip_ext_hdr *)&uip_buf[UIP_LLIPH_LEN])
     66          
     67          /** \brief temporary IP address */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     68          static uip_ipaddr_t tmp_ipaddr;
   \                     tmp_ipaddr:
   \   000000                DS 16
   \   000010                REQUIRE __INIT_XDATA_Z
     69          
     70          #if UIP_CONF_IPV6_RPL
     71          #include "rpl/rpl.h"
     72          #endif /* UIP_CONF_IPV6_RPL */
     73          
     74          #if UIP_CONF_IPV6
     75          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     76          void
     77          uip_icmp6_echo_request_input(void)
   \                     uip_icmp6_echo_request_input:
     78          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
     79          #if UIP_CONF_IPV6_RPL
     80            uint8_t temp_ext_len;
     81          #endif /* UIP_CONF_IPV6_RPL */
     82            /*
     83             * we send an echo reply. It is trivial if there was no extension
     84             * headers in the request otherwise we need to remove the extension
     85             * headers and change a few fields
     86             */
     87            PRINTF("Received Echo Request from");
     88            PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
     89            PRINTF("to");
     90            PRINT6ADDR(&UIP_IP_BUF->destipaddr);
     91            PRINTF("\n");
     92          
     93            /* IP header */
     94            UIP_IP_BUF->ttl = uip_ds6_if.cur_hop_limit;
   \   000005   90....       MOV     DPTR,#uip_ds6_if + 4
   \   000008   E0           MOVX    A,@DPTR
   \   000009   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   00000C   F0           MOVX    @DPTR,A
     95          
     96            if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)){
   \   00000D   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   000010   E0           MOVX    A,@DPTR
   \   000011   64FF         XRL     A,#0xff
   \   000013   7028         JNZ     ??uip_icmp6_echo_request_input_0
     97              uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);
   \   000015                ; Setup parameters for call to function memcpy
   \   000015   75..10       MOV     ?V0 + 0,#0x10
   \   000018   75..00       MOV     ?V0 + 1,#0x0
   \   00001B   78..         MOV     R0,#?V0 + 0
   \   00001D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000020   7C..         MOV     R4,#(uip_aligned_buf + 8) & 0xff
   \   000022   7D..         MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   000024   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   000026   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000028   12....       LCALL   ??memcpy?relay
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?DEALLOC_XSTACK8
     98              uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
   \   000030                ; Setup parameters for call to function uip_ds6_select_src
   \   000030   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   000032   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000034   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   000036   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   000038   12....       LCALL   ??uip_ds6_select_src?relay
   \   00003B   8051         SJMP    ??uip_icmp6_echo_request_input_1
     99            } else {
    100              uip_ipaddr_copy(&tmp_ipaddr, &UIP_IP_BUF->srcipaddr);
   \                     ??uip_icmp6_echo_request_input_0:
   \   00003D                ; Setup parameters for call to function memcpy
   \   00003D   75..10       MOV     ?V0 + 0,#0x10
   \   000040   75..00       MOV     ?V0 + 1,#0x0
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   7C..         MOV     R4,#(uip_aligned_buf + 8) & 0xff
   \   00004A   7D..         MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   00004C   7A..         MOV     R2,#tmp_ipaddr & 0xff
   \   00004E   7B..         MOV     R3,#(tmp_ipaddr >> 8) & 0xff
   \   000050   12....       LCALL   ??memcpy?relay
   \   000053   7402         MOV     A,#0x2
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
    101              uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
   \   000058                ; Setup parameters for call to function memcpy
   \   000058   75..10       MOV     ?V0 + 0,#0x10
   \   00005B   75..00       MOV     ?V0 + 1,#0x0
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   000065   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000067   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   000069   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   00006B   12....       LCALL   ??memcpy?relay
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
    102              uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &tmp_ipaddr);
   \   000073                ; Setup parameters for call to function memcpy
   \   000073   75..10       MOV     ?V0 + 0,#0x10
   \   000076   75..00       MOV     ?V0 + 1,#0x0
   \   000079   78..         MOV     R0,#?V0 + 0
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007E   7C..         MOV     R4,#tmp_ipaddr & 0xff
   \   000080   7D..         MOV     R5,#(tmp_ipaddr >> 8) & 0xff
   \   000082   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   000084   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000086   12....       LCALL   ??memcpy?relay
   \   000089   7402         MOV     A,#0x2
   \   00008B   12....       LCALL   ?DEALLOC_XSTACK8
    103            }
    104          
    105            if(uip_ext_len > 0) {
   \                     ??uip_icmp6_echo_request_input_1:
   \   00008E   90....       MOV     DPTR,#uip_ext_len
   \   000091   E0           MOVX    A,@DPTR
   \   000092   C3           CLR     C
   \   000093   9401         SUBB    A,#0x1
   \   000095   5003         JNC     $+5
   \   000097   02....       LJMP    ??uip_icmp6_echo_request_input_2 & 0xFFFF
    106          #if UIP_CONF_IPV6_RPL
    107              if((temp_ext_len = rpl_invert_header())) {
    108                /* If there were other extension headers*/
    109                UIP_FIRST_EXT_BUF->next = UIP_PROTO_ICMP6;
    110                if (uip_ext_len != temp_ext_len) {
    111                  uip_len -= (uip_ext_len - temp_ext_len);
    112                  UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    113                  UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
    114                  /* move the echo request payload (starting after the icmp header)
    115                   * to the new location in the reply.
    116                   * The shift is equal to the length of the remaining extension headers present
    117                   * Note: UIP_ICMP_BUF still points to the echo request at this stage
    118                   */
    119                memmove((uint8_t *)UIP_ICMP_BUF + UIP_ICMPH_LEN - (uip_ext_len - temp_ext_len),
    120                        (uint8_t *)UIP_ICMP_BUF + UIP_ICMPH_LEN,
    121                        (uip_len - UIP_IPH_LEN - temp_ext_len - UIP_ICMPH_LEN));
    122                }
    123                uip_ext_len = temp_ext_len;
    124              } else {
    125          #endif /* UIP_CONF_IPV6_RPL */
    126                /* If there were extension headers*/
    127                UIP_IP_BUF->proto = UIP_PROTO_ICMP6;
   \   00009A   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   00009D   743A         MOV     A,#0x3a
   \   00009F   F0           MOVX    @DPTR,A
    128                uip_len -= uip_ext_len;
   \   0000A0   90....       MOV     DPTR,#uip_ext_len
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F8           MOV     R0,A
   \   0000A5   7900         MOV     R1,#0x0
   \   0000A7   90....       MOV     DPTR,#uip_len
   \   0000AA   C3           CLR     C
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   98           SUBB    A,R0
   \   0000AD   F0           MOVX    @DPTR,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   99           SUBB    A,R1
   \   0000B1   F0           MOVX    @DPTR,A
    129                UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
   \   0000B2   90....       MOV     DPTR,#uip_len
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   24D8         ADD     A,#-0x28
   \   0000B8   F8           MOV     R0,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   34FF         ADDC    A,#-0x1
   \   0000BD   F9           MOV     R1,A
   \   0000BE   E4           CLR     A
   \   0000BF   E9           MOV     A,R1
   \   0000C0   F8           MOV     R0,A
   \   0000C1   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   0000C4   F0           MOVX    @DPTR,A
    130                UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
   \   0000C5   90....       MOV     DPTR,#uip_len
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F8           MOV     R0,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F9           MOV     R1,A
   \   0000CD   E8           MOV     A,R0
   \   0000CE   24D8         ADD     A,#-0x28
   \   0000D0   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   0000D3   F0           MOVX    @DPTR,A
    131                /* move the echo request payload (starting after the icmp header)
    132                 * to the new location in the reply.
    133                 * The shift is equal to the length of the extension headers present
    134                 * Note: UIP_ICMP_BUF still points to the echo request at this stage
    135                 */
    136                memmove((uint8_t *)UIP_ICMP_BUF + UIP_ICMPH_LEN - uip_ext_len,
    137                        (uint8_t *)UIP_ICMP_BUF + UIP_ICMPH_LEN,
    138                        (uip_len - UIP_IPH_LEN - UIP_ICMPH_LEN));
   \   0000D4                ; Setup parameters for call to function memmove
   \   0000D4   90....       MOV     DPTR,#uip_len
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   24D4         ADD     A,#-0x2c
   \   0000DA   F5..         MOV     ?V0 + 0,A
   \   0000DC   A3           INC     DPTR
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   34FF         ADDC    A,#-0x1
   \   0000E0   F5..         MOV     ?V0 + 1,A
   \   0000E2   78..         MOV     R0,#?V0 + 0
   \   0000E4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E7   90....       MOV     DPTR,#uip_ext_len
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   F8           MOV     R0,A
   \   0000EC   7900         MOV     R1,#0x0
   \   0000EE   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0000F0   28           ADD     A,R0
   \   0000F1   F8           MOV     R0,A
   \   0000F2   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0000F4   39           ADDC    A,R1
   \   0000F5   F9           MOV     R1,A
   \   0000F6   E8           MOV     A,R0
   \   0000F7   242C         ADD     A,#0x2c
   \   0000F9   FC           MOV     R4,A
   \   0000FA   E9           MOV     A,R1
   \   0000FB   3400         ADDC    A,#0x0
   \   0000FD   FD           MOV     R5,A
   \   0000FE   90....       MOV     DPTR,#uip_ext_len
   \   000101   E0           MOVX    A,@DPTR
   \   000102   F8           MOV     R0,A
   \   000103   7900         MOV     R1,#0x0
   \   000105   C3           CLR     C
   \   000106   E4           CLR     A
   \   000107   98           SUBB    A,R0
   \   000108   F8           MOV     R0,A
   \   000109   E4           CLR     A
   \   00010A   99           SUBB    A,R1
   \   00010B   F9           MOV     R1,A
   \   00010C   90....       MOV     DPTR,#uip_ext_len
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   FA           MOV     R2,A
   \   000111   7B00         MOV     R3,#0x0
   \   000113   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000115   2A           ADD     A,R2
   \   000116   FA           MOV     R2,A
   \   000117   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000119   3B           ADDC    A,R3
   \   00011A   FB           MOV     R3,A
   \   00011B   EA           MOV     A,R2
   \   00011C   28           ADD     A,R0
   \   00011D   F8           MOV     R0,A
   \   00011E   EB           MOV     A,R3
   \   00011F   39           ADDC    A,R1
   \   000120   F9           MOV     R1,A
   \   000121   E8           MOV     A,R0
   \   000122   242C         ADD     A,#0x2c
   \   000124   FA           MOV     R2,A
   \   000125   E9           MOV     A,R1
   \   000126   3400         ADDC    A,#0x0
   \   000128   FB           MOV     R3,A
   \   000129   12....       LCALL   ??memmove?relay
   \   00012C   7402         MOV     A,#0x2
   \   00012E   12....       LCALL   ?DEALLOC_XSTACK8
    139                uip_ext_len = 0;
   \   000131   90....       MOV     DPTR,#uip_ext_len
   \   000134   7400         MOV     A,#0x0
   \   000136   F0           MOVX    @DPTR,A
    140          #if UIP_CONF_IPV6_RPL
    141              }
    142          #endif /* UIP_CONF_IPV6_RPL */
    143            }
    144            /* Below is important for the correctness of UIP_ICMP_BUF and the
    145             * checksum
    146             */
    147          
    148            /* Note: now UIP_ICMP_BUF points to the beginning of the echo reply */
    149            UIP_ICMP_BUF->type = ICMP6_ECHO_REPLY;
   \                     ??uip_icmp6_echo_request_input_2:
   \   000137   90....       MOV     DPTR,#uip_ext_len
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   F8           MOV     R0,A
   \   00013C   7900         MOV     R1,#0x0
   \   00013E   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000140   28           ADD     A,R0
   \   000141   F8           MOV     R0,A
   \   000142   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000144   39           ADDC    A,R1
   \   000145   F9           MOV     R1,A
   \   000146   E8           MOV     A,R0
   \   000147   2428         ADD     A,#0x28
   \   000149   F582         MOV     DPL,A
   \   00014B   E9           MOV     A,R1
   \   00014C   3400         ADDC    A,#0x0
   \   00014E   F583         MOV     DPH,A
   \   000150   7481         MOV     A,#-0x7f
   \   000152   F0           MOVX    @DPTR,A
    150            UIP_ICMP_BUF->icode = 0;
   \   000153   90....       MOV     DPTR,#uip_ext_len
   \   000156   E0           MOVX    A,@DPTR
   \   000157   F8           MOV     R0,A
   \   000158   7900         MOV     R1,#0x0
   \   00015A   74..         MOV     A,#uip_aligned_buf & 0xff
   \   00015C   28           ADD     A,R0
   \   00015D   F8           MOV     R0,A
   \   00015E   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000160   39           ADDC    A,R1
   \   000161   F9           MOV     R1,A
   \   000162   E8           MOV     A,R0
   \   000163   2429         ADD     A,#0x29
   \   000165   F582         MOV     DPL,A
   \   000167   E9           MOV     A,R1
   \   000168   3400         ADDC    A,#0x0
   \   00016A   F583         MOV     DPH,A
   \   00016C   7400         MOV     A,#0x0
   \   00016E   F0           MOVX    @DPTR,A
    151            UIP_ICMP_BUF->icmpchksum = 0;
   \   00016F   90....       MOV     DPTR,#uip_ext_len
   \   000172   E0           MOVX    A,@DPTR
   \   000173   F8           MOV     R0,A
   \   000174   7900         MOV     R1,#0x0
   \   000176   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000178   28           ADD     A,R0
   \   000179   F8           MOV     R0,A
   \   00017A   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00017C   39           ADDC    A,R1
   \   00017D   F9           MOV     R1,A
   \   00017E   E8           MOV     A,R0
   \   00017F   242A         ADD     A,#0x2a
   \   000181   F582         MOV     DPL,A
   \   000183   E9           MOV     A,R1
   \   000184   3400         ADDC    A,#0x0
   \   000186   F583         MOV     DPH,A
   \   000188   7400         MOV     A,#0x0
   \   00018A   F0           MOVX    @DPTR,A
   \   00018B   A3           INC     DPTR
   \   00018C   7400         MOV     A,#0x0
   \   00018E   F0           MOVX    @DPTR,A
    152            UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();
   \   00018F                ; Setup parameters for call to function uip_icmp6chksum
   \   00018F   12....       LCALL   ??uip_icmp6chksum?relay
   \   000192   8A..         MOV     ?V0 + 0,R2
   \   000194   8B..         MOV     ?V0 + 1,R3
   \   000196   A8..         MOV     R0,?V0 + 0
   \   000198   A9..         MOV     R1,?V0 + 1
   \   00019A   E5..         MOV     A,?V0 + 0
   \   00019C   F4           CPL     A
   \   00019D   FA           MOV     R2,A
   \   00019E   E5..         MOV     A,?V0 + 1
   \   0001A0   F4           CPL     A
   \   0001A1   FB           MOV     R3,A
   \   0001A2   90....       MOV     DPTR,#uip_ext_len
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   F8           MOV     R0,A
   \   0001A7   7900         MOV     R1,#0x0
   \   0001A9   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0001AB   28           ADD     A,R0
   \   0001AC   F8           MOV     R0,A
   \   0001AD   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0001AF   39           ADDC    A,R1
   \   0001B0   F9           MOV     R1,A
   \   0001B1   E8           MOV     A,R0
   \   0001B2   242A         ADD     A,#0x2a
   \   0001B4   F582         MOV     DPL,A
   \   0001B6   E9           MOV     A,R1
   \   0001B7   3400         ADDC    A,#0x0
   \   0001B9   F583         MOV     DPH,A
   \   0001BB   EA           MOV     A,R2
   \   0001BC   F0           MOVX    @DPTR,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   EB           MOV     A,R3
   \   0001BF   F0           MOVX    @DPTR,A
    153          
    154            PRINTF("Sending Echo Reply to");
    155            PRINT6ADDR(&UIP_IP_BUF->destipaddr);
    156            PRINTF("from");
    157            PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
    158            PRINTF("\n");
    159            UIP_STAT(++uip_stat.icmp.sent);
    160            return;
   \   0001C0   7F02         MOV     R7,#0x2
   \   0001C2   02....       LJMP    ?BANKED_LEAVE_XDATA
    161          }
    162          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    163          void
    164          uip_icmp6_error_output(uint8_t type, uint8_t code, uint32_t param) {
   \                     uip_icmp6_error_output:
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FF           MOV     R7,A
   \   000009   740E         MOV     A,#0xe
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   12....       LCALL   ?L_MOV_X
    165          
    166           /* check if originating packet is not an ICMP error*/
    167            if (uip_ext_len) {
   \   000013   90....       MOV     DPTR,#uip_ext_len
   \   000016   E0           MOVX    A,@DPTR
   \   000017   603A         JZ      ??uip_icmp6_error_output_0
    168              if(UIP_EXT_BUF->next == UIP_PROTO_ICMP6 && UIP_ICMP_BUF->type < 128){
   \   000019   90....       MOV     DPTR,#uip_ext_len
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   7900         MOV     R1,#0x0
   \   000020   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   000022   28           ADD     A,R0
   \   000023   F582         MOV     DPL,A
   \   000025   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000027   39           ADDC    A,R1
   \   000028   F583         MOV     DPH,A
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   643A         XRL     A,#0x3a
   \   00002D   7050         JNZ     ??uip_icmp6_error_output_1
   \   00002F   90....       MOV     DPTR,#uip_ext_len
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F8           MOV     R0,A
   \   000034   7900         MOV     R1,#0x0
   \   000036   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   000038   28           ADD     A,R0
   \   000039   F582         MOV     DPL,A
   \   00003B   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   00003D   39           ADDC    A,R1
   \   00003E   F583         MOV     DPH,A
   \   000040   E0           MOVX    A,@DPTR
   \   000041   C3           CLR     C
   \   000042   9480         SUBB    A,#-0x80
   \   000044   5039         JNC     ??uip_icmp6_error_output_1
    169                uip_len = 0;
   \   000046   90....       MOV     DPTR,#uip_len
   \   000049   7400         MOV     A,#0x0
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   7400         MOV     A,#0x0
   \   00004F   F0           MOVX    @DPTR,A
    170                return;
   \   000050   02....       LJMP    ??uip_icmp6_error_output_2 & 0xFFFF
    171              }
    172            } else {
    173              if(UIP_IP_BUF->proto == UIP_PROTO_ICMP6 && UIP_ICMP_BUF->type < 128){
   \                     ??uip_icmp6_error_output_0:
   \   000053   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000056   E0           MOVX    A,@DPTR
   \   000057   643A         XRL     A,#0x3a
   \   000059   7024         JNZ     ??uip_icmp6_error_output_1
   \   00005B   90....       MOV     DPTR,#uip_ext_len
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F8           MOV     R0,A
   \   000060   7900         MOV     R1,#0x0
   \   000062   74..         MOV     A,#(uip_aligned_buf + 40) & 0xff
   \   000064   28           ADD     A,R0
   \   000065   F582         MOV     DPL,A
   \   000067   74..         MOV     A,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000069   39           ADDC    A,R1
   \   00006A   F583         MOV     DPH,A
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   C3           CLR     C
   \   00006E   9480         SUBB    A,#-0x80
   \   000070   500D         JNC     ??uip_icmp6_error_output_1
    174                uip_len = 0;
   \   000072   90....       MOV     DPTR,#uip_len
   \   000075   7400         MOV     A,#0x0
   \   000077   F0           MOVX    @DPTR,A
   \   000078   A3           INC     DPTR
   \   000079   7400         MOV     A,#0x0
   \   00007B   F0           MOVX    @DPTR,A
    175                return;
   \   00007C   02....       LJMP    ??uip_icmp6_error_output_2 & 0xFFFF
    176              }
    177            }
    178          
    179          #if UIP_CONF_IPV6_RPL
    180            uip_ext_len = rpl_invert_header();
    181          #else /* UIP_CONF_IPV6_RPL */
    182            uip_ext_len = 0;
   \                     ??uip_icmp6_error_output_1:
   \   00007F   90....       MOV     DPTR,#uip_ext_len
   \   000082   7400         MOV     A,#0x0
   \   000084   F0           MOVX    @DPTR,A
    183          #endif /* UIP_CONF_IPV6_RPL */
    184          
    185            /* remember data of original packet before shifting */
    186            uip_ipaddr_copy(&tmp_ipaddr, &UIP_IP_BUF->destipaddr);
   \   000085                ; Setup parameters for call to function memcpy
   \   000085   75..10       MOV     ?V0 + 4,#0x10
   \   000088   75..00       MOV     ?V0 + 5,#0x0
   \   00008B   78..         MOV     R0,#?V0 + 4
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   000092   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000094   7A..         MOV     R2,#tmp_ipaddr & 0xff
   \   000096   7B..         MOV     R3,#(tmp_ipaddr >> 8) & 0xff
   \   000098   12....       LCALL   ??memcpy?relay
   \   00009B   7402         MOV     A,#0x2
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
    187          
    188            uip_len += UIP_IPICMPH_LEN + UIP_ICMP6_ERROR_LEN;
   \   0000A0   90....       MOV     DPTR,#uip_len
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   2430         ADD     A,#0x30
   \   0000A6   F0           MOVX    @DPTR,A
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   3400         ADDC    A,#0x0
   \   0000AB   F0           MOVX    @DPTR,A
    189          
    190            if(uip_len > UIP_LINK_MTU)
   \   0000AC   90....       MOV     DPTR,#uip_len
   \   0000AF   C3           CLR     C
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   9401         SUBB    A,#0x1
   \   0000B3   A3           INC     DPTR
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   9405         SUBB    A,#0x5
   \   0000B7   400A         JC      ??uip_icmp6_error_output_3
    191              uip_len = UIP_LINK_MTU;
   \   0000B9   90....       MOV     DPTR,#uip_len
   \   0000BC   7400         MOV     A,#0x0
   \   0000BE   F0           MOVX    @DPTR,A
   \   0000BF   A3           INC     DPTR
   \   0000C0   7405         MOV     A,#0x5
   \   0000C2   F0           MOVX    @DPTR,A
    192          
    193            memmove((uint8_t *)UIP_ICMP6_ERROR_BUF + uip_ext_len + UIP_ICMP6_ERROR_LEN,
    194                    (void *)UIP_IP_BUF, uip_len - UIP_IPICMPH_LEN - uip_ext_len - UIP_ICMP6_ERROR_LEN);
   \                     ??uip_icmp6_error_output_3:
   \   0000C3                ; Setup parameters for call to function memmove
   \   0000C3   90....       MOV     DPTR,#uip_len
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   24D4         ADD     A,#-0x2c
   \   0000C9   F8           MOV     R0,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   34FF         ADDC    A,#-0x1
   \   0000CE   F9           MOV     R1,A
   \   0000CF   90....       MOV     DPTR,#uip_ext_len
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   FA           MOV     R2,A
   \   0000D4   7B00         MOV     R3,#0x0
   \   0000D6   E8           MOV     A,R0
   \   0000D7   C3           CLR     C
   \   0000D8   9A           SUBB    A,R2
   \   0000D9   F8           MOV     R0,A
   \   0000DA   E9           MOV     A,R1
   \   0000DB   9B           SUBB    A,R3
   \   0000DC   F9           MOV     R1,A
   \   0000DD   E8           MOV     A,R0
   \   0000DE   24FC         ADD     A,#-0x4
   \   0000E0   F5..         MOV     ?V0 + 4,A
   \   0000E2   E9           MOV     A,R1
   \   0000E3   34FF         ADDC    A,#-0x1
   \   0000E5   F5..         MOV     ?V0 + 5,A
   \   0000E7   78..         MOV     R0,#?V0 + 4
   \   0000E9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EC   7C..         MOV     R4,#uip_aligned_buf & 0xff
   \   0000EE   7D..         MOV     R5,#(uip_aligned_buf >> 8) & 0xff
   \   0000F0   90....       MOV     DPTR,#uip_ext_len
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   FA           MOV     R2,A
   \   0000F5   7B00         MOV     R3,#0x0
   \   0000F7   90....       MOV     DPTR,#uip_ext_len
   \   0000FA   E0           MOVX    A,@DPTR
   \   0000FB   F8           MOV     R0,A
   \   0000FC   7900         MOV     R1,#0x0
   \   0000FE   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000100   28           ADD     A,R0
   \   000101   F8           MOV     R0,A
   \   000102   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000104   39           ADDC    A,R1
   \   000105   F9           MOV     R1,A
   \   000106   E8           MOV     A,R0
   \   000107   2A           ADD     A,R2
   \   000108   F8           MOV     R0,A
   \   000109   E9           MOV     A,R1
   \   00010A   3B           ADDC    A,R3
   \   00010B   F9           MOV     R1,A
   \   00010C   E8           MOV     A,R0
   \   00010D   2430         ADD     A,#0x30
   \   00010F   FA           MOV     R2,A
   \   000110   E9           MOV     A,R1
   \   000111   3400         ADDC    A,#0x0
   \   000113   FB           MOV     R3,A
   \   000114   12....       LCALL   ??memmove?relay
   \   000117   7402         MOV     A,#0x2
   \   000119   12....       LCALL   ?DEALLOC_XSTACK8
    195          
    196            UIP_IP_BUF->vtc = 0x60;
   \   00011C   90....       MOV     DPTR,#uip_aligned_buf
   \   00011F   7460         MOV     A,#0x60
   \   000121   F0           MOVX    @DPTR,A
    197            UIP_IP_BUF->tcflow = 0;
   \   000122   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   000125   7400         MOV     A,#0x0
   \   000127   F0           MOVX    @DPTR,A
    198            UIP_IP_BUF->flow = 0;
   \   000128   90....       MOV     DPTR,#uip_aligned_buf + 2
   \   00012B   7400         MOV     A,#0x0
   \   00012D   F0           MOVX    @DPTR,A
   \   00012E   A3           INC     DPTR
   \   00012F   7400         MOV     A,#0x0
   \   000131   F0           MOVX    @DPTR,A
    199            if (uip_ext_len) {
   \   000132   90....       MOV     DPTR,#uip_ext_len
   \   000135   E0           MOVX    A,@DPTR
   \   000136   6008         JZ      ??uip_icmp6_error_output_4
    200              UIP_FIRST_EXT_BUF->next = UIP_PROTO_ICMP6;
   \   000138   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   00013B   743A         MOV     A,#0x3a
   \   00013D   F0           MOVX    @DPTR,A
   \   00013E   8006         SJMP    ??uip_icmp6_error_output_5
    201            } else {
    202              UIP_IP_BUF->proto = UIP_PROTO_ICMP6;
   \                     ??uip_icmp6_error_output_4:
   \   000140   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000143   743A         MOV     A,#0x3a
   \   000145   F0           MOVX    @DPTR,A
    203            }
    204            UIP_IP_BUF->ttl = uip_ds6_if.cur_hop_limit;
   \                     ??uip_icmp6_error_output_5:
   \   000146   90....       MOV     DPTR,#uip_ds6_if + 4
   \   000149   E0           MOVX    A,@DPTR
   \   00014A   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   00014D   F0           MOVX    @DPTR,A
    205          
    206            /* the source should not be unspecified nor multicast, the check for
    207               multicast is done in uip_process */
    208            if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)){
   \   00014E   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   F8           MOV     R0,A
   \   000153   A3           INC     DPTR
   \   000154   E0           MOVX    A,@DPTR
   \   000155   F9           MOV     R1,A
   \   000156   E8           MOV     A,R0
   \   000157   49           ORL     A,R1
   \   000158   7061         JNZ     ??uip_icmp6_error_output_6
   \   00015A   90....       MOV     DPTR,#uip_aligned_buf + 10
   \   00015D   E0           MOVX    A,@DPTR
   \   00015E   F8           MOV     R0,A
   \   00015F   A3           INC     DPTR
   \   000160   E0           MOVX    A,@DPTR
   \   000161   F9           MOV     R1,A
   \   000162   E8           MOV     A,R0
   \   000163   49           ORL     A,R1
   \   000164   7055         JNZ     ??uip_icmp6_error_output_6
   \   000166   90....       MOV     DPTR,#uip_aligned_buf + 12
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   F8           MOV     R0,A
   \   00016B   A3           INC     DPTR
   \   00016C   E0           MOVX    A,@DPTR
   \   00016D   F9           MOV     R1,A
   \   00016E   E8           MOV     A,R0
   \   00016F   49           ORL     A,R1
   \   000170   7049         JNZ     ??uip_icmp6_error_output_6
   \   000172   90....       MOV     DPTR,#uip_aligned_buf + 14
   \   000175   E0           MOVX    A,@DPTR
   \   000176   F8           MOV     R0,A
   \   000177   A3           INC     DPTR
   \   000178   E0           MOVX    A,@DPTR
   \   000179   F9           MOV     R1,A
   \   00017A   E8           MOV     A,R0
   \   00017B   49           ORL     A,R1
   \   00017C   703D         JNZ     ??uip_icmp6_error_output_6
   \   00017E   90....       MOV     DPTR,#uip_aligned_buf + 16
   \   000181   E0           MOVX    A,@DPTR
   \   000182   F8           MOV     R0,A
   \   000183   A3           INC     DPTR
   \   000184   E0           MOVX    A,@DPTR
   \   000185   F9           MOV     R1,A
   \   000186   E8           MOV     A,R0
   \   000187   49           ORL     A,R1
   \   000188   7031         JNZ     ??uip_icmp6_error_output_6
   \   00018A   90....       MOV     DPTR,#uip_aligned_buf + 18
   \   00018D   E0           MOVX    A,@DPTR
   \   00018E   F8           MOV     R0,A
   \   00018F   A3           INC     DPTR
   \   000190   E0           MOVX    A,@DPTR
   \   000191   F9           MOV     R1,A
   \   000192   E8           MOV     A,R0
   \   000193   49           ORL     A,R1
   \   000194   7025         JNZ     ??uip_icmp6_error_output_6
   \   000196   90....       MOV     DPTR,#uip_aligned_buf + 20
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   F8           MOV     R0,A
   \   00019B   A3           INC     DPTR
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   F9           MOV     R1,A
   \   00019E   E8           MOV     A,R0
   \   00019F   49           ORL     A,R1
   \   0001A0   7019         JNZ     ??uip_icmp6_error_output_6
   \   0001A2   90....       MOV     DPTR,#uip_aligned_buf + 22
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   F8           MOV     R0,A
   \   0001A7   A3           INC     DPTR
   \   0001A8   E0           MOVX    A,@DPTR
   \   0001A9   F9           MOV     R1,A
   \   0001AA   E8           MOV     A,R0
   \   0001AB   49           ORL     A,R1
   \   0001AC   700D         JNZ     ??uip_icmp6_error_output_6
    209              uip_len = 0;
   \   0001AE   90....       MOV     DPTR,#uip_len
   \   0001B1   7400         MOV     A,#0x0
   \   0001B3   F0           MOVX    @DPTR,A
   \   0001B4   A3           INC     DPTR
   \   0001B5   7400         MOV     A,#0x0
   \   0001B7   F0           MOVX    @DPTR,A
    210              return;
   \   0001B8   02....       LJMP    ??uip_icmp6_error_output_2 & 0xFFFF
    211            }
    212          
    213            uip_ipaddr_copy(&UIP_IP_BUF->destipaddr, &UIP_IP_BUF->srcipaddr);
   \                     ??uip_icmp6_error_output_6:
   \   0001BB                ; Setup parameters for call to function memcpy
   \   0001BB   75..10       MOV     ?V0 + 4,#0x10
   \   0001BE   75..00       MOV     ?V0 + 5,#0x0
   \   0001C1   78..         MOV     R0,#?V0 + 4
   \   0001C3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001C6   7C..         MOV     R4,#(uip_aligned_buf + 8) & 0xff
   \   0001C8   7D..         MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   0001CA   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0001CC   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0001CE   12....       LCALL   ??memcpy?relay
   \   0001D1   7402         MOV     A,#0x2
   \   0001D3   12....       LCALL   ?DEALLOC_XSTACK8
    214          
    215            if(uip_is_addr_mcast(&tmp_ipaddr)){
   \   0001D6   90....       MOV     DPTR,#tmp_ipaddr
   \   0001D9   E0           MOVX    A,@DPTR
   \   0001DA   64FF         XRL     A,#0xff
   \   0001DC   7024         JNZ     ??uip_icmp6_error_output_7
    216              if(type == ICMP6_PARAM_PROB && code == ICMP6_PARAMPROB_OPTION){
   \   0001DE   7404         MOV     A,#0x4
   \   0001E0   6E           XRL     A,R6
   \   0001E1   7012         JNZ     ??uip_icmp6_error_output_8
   \   0001E3   7402         MOV     A,#0x2
   \   0001E5   6F           XRL     A,R7
   \   0001E6   700D         JNZ     ??uip_icmp6_error_output_8
    217                uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &tmp_ipaddr);
   \   0001E8                ; Setup parameters for call to function uip_ds6_select_src
   \   0001E8   7C..         MOV     R4,#tmp_ipaddr & 0xff
   \   0001EA   7D..         MOV     R5,#(tmp_ipaddr >> 8) & 0xff
   \   0001EC   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   0001EE   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   0001F0   12....       LCALL   ??uip_ds6_select_src?relay
   \   0001F3   8018         SJMP    ??uip_icmp6_error_output_9
    218              } else {
    219                uip_len = 0;
   \                     ??uip_icmp6_error_output_8:
   \   0001F5   90....       MOV     DPTR,#uip_len
   \   0001F8   7400         MOV     A,#0x0
   \   0001FA   F0           MOVX    @DPTR,A
   \   0001FB   A3           INC     DPTR
   \   0001FC   7400         MOV     A,#0x0
   \   0001FE   F0           MOVX    @DPTR,A
    220                return;
   \   0001FF   02....       LJMP    ??uip_icmp6_error_output_2 & 0xFFFF
    221              }
    222            } else {
    223          #if UIP_CONF_ROUTER
    224              /* need to pick a source that corresponds to this node */
    225              uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &tmp_ipaddr);
   \                     ??uip_icmp6_error_output_7:
   \   000202                ; Setup parameters for call to function uip_ds6_select_src
   \   000202   7C..         MOV     R4,#tmp_ipaddr & 0xff
   \   000204   7D..         MOV     R5,#(tmp_ipaddr >> 8) & 0xff
   \   000206   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   000208   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   00020A   12....       LCALL   ??uip_ds6_select_src?relay
    226          #else
    227              uip_ipaddr_copy(&UIP_IP_BUF->srcipaddr, &tmp_ipaddr);
    228          #endif
    229            }
    230          
    231            UIP_ICMP_BUF->type = type;
   \                     ??uip_icmp6_error_output_9:
   \   00020D   EE           MOV     A,R6
   \   00020E   C0E0         PUSH    A
   \   000210   90....       MOV     DPTR,#uip_ext_len
   \   000213   E0           MOVX    A,@DPTR
   \   000214   F8           MOV     R0,A
   \   000215   7900         MOV     R1,#0x0
   \   000217   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000219   28           ADD     A,R0
   \   00021A   F8           MOV     R0,A
   \   00021B   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00021D   39           ADDC    A,R1
   \   00021E   F9           MOV     R1,A
   \   00021F   E8           MOV     A,R0
   \   000220   2428         ADD     A,#0x28
   \   000222   F582         MOV     DPL,A
   \   000224   E9           MOV     A,R1
   \   000225   3400         ADDC    A,#0x0
   \   000227   F583         MOV     DPH,A
   \   000229   D0E0         POP     A
   \   00022B   F0           MOVX    @DPTR,A
    232            UIP_ICMP_BUF->icode = code;
   \   00022C   EF           MOV     A,R7
   \   00022D   C0E0         PUSH    A
   \   00022F   90....       MOV     DPTR,#uip_ext_len
   \   000232   E0           MOVX    A,@DPTR
   \   000233   F8           MOV     R0,A
   \   000234   7900         MOV     R1,#0x0
   \   000236   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000238   28           ADD     A,R0
   \   000239   F8           MOV     R0,A
   \   00023A   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00023C   39           ADDC    A,R1
   \   00023D   F9           MOV     R1,A
   \   00023E   E8           MOV     A,R0
   \   00023F   2429         ADD     A,#0x29
   \   000241   F582         MOV     DPL,A
   \   000243   E9           MOV     A,R1
   \   000244   3400         ADDC    A,#0x0
   \   000246   F583         MOV     DPH,A
   \   000248   D0E0         POP     A
   \   00024A   F0           MOVX    @DPTR,A
    233            UIP_ICMP6_ERROR_BUF->param = uip_htonl(param);
   \   00024B                ; Setup parameters for call to function uip_htonl
   \   00024B   AA..         MOV     R2,?V0 + 0
   \   00024D   AB..         MOV     R3,?V0 + 1
   \   00024F   AC..         MOV     R4,?V0 + 2
   \   000251   AD..         MOV     R5,?V0 + 3
   \   000253   12....       LCALL   ??uip_htonl?relay
   \   000256   8A..         MOV     ?V0 + 0,R2
   \   000258   8B..         MOV     ?V0 + 1,R3
   \   00025A   8C..         MOV     ?V0 + 2,R4
   \   00025C   8D..         MOV     ?V0 + 3,R5
   \   00025E   90....       MOV     DPTR,#uip_ext_len
   \   000261   E0           MOVX    A,@DPTR
   \   000262   F8           MOV     R0,A
   \   000263   7900         MOV     R1,#0x0
   \   000265   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000267   28           ADD     A,R0
   \   000268   F8           MOV     R0,A
   \   000269   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00026B   39           ADDC    A,R1
   \   00026C   F9           MOV     R1,A
   \   00026D   E8           MOV     A,R0
   \   00026E   242C         ADD     A,#0x2c
   \   000270   F582         MOV     DPL,A
   \   000272   E9           MOV     A,R1
   \   000273   3400         ADDC    A,#0x0
   \   000275   F583         MOV     DPH,A
   \   000277   78..         MOV     R0,#?V0 + 0
   \   000279   12....       LCALL   ?L_MOV_TO_X
    234            UIP_IP_BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
   \   00027C   90....       MOV     DPTR,#uip_len
   \   00027F   E0           MOVX    A,@DPTR
   \   000280   24D8         ADD     A,#-0x28
   \   000282   F8           MOV     R0,A
   \   000283   A3           INC     DPTR
   \   000284   E0           MOVX    A,@DPTR
   \   000285   34FF         ADDC    A,#-0x1
   \   000287   F9           MOV     R1,A
   \   000288   E4           CLR     A
   \   000289   E9           MOV     A,R1
   \   00028A   F8           MOV     R0,A
   \   00028B   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   00028E   F0           MOVX    @DPTR,A
    235            UIP_IP_BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
   \   00028F   90....       MOV     DPTR,#uip_len
   \   000292   E0           MOVX    A,@DPTR
   \   000293   F8           MOV     R0,A
   \   000294   A3           INC     DPTR
   \   000295   E0           MOVX    A,@DPTR
   \   000296   F9           MOV     R1,A
   \   000297   E8           MOV     A,R0
   \   000298   24D8         ADD     A,#-0x28
   \   00029A   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   00029D   F0           MOVX    @DPTR,A
    236            UIP_ICMP_BUF->icmpchksum = 0;
   \   00029E   90....       MOV     DPTR,#uip_ext_len
   \   0002A1   E0           MOVX    A,@DPTR
   \   0002A2   F8           MOV     R0,A
   \   0002A3   7900         MOV     R1,#0x0
   \   0002A5   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0002A7   28           ADD     A,R0
   \   0002A8   F8           MOV     R0,A
   \   0002A9   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0002AB   39           ADDC    A,R1
   \   0002AC   F9           MOV     R1,A
   \   0002AD   E8           MOV     A,R0
   \   0002AE   242A         ADD     A,#0x2a
   \   0002B0   F582         MOV     DPL,A
   \   0002B2   E9           MOV     A,R1
   \   0002B3   3400         ADDC    A,#0x0
   \   0002B5   F583         MOV     DPH,A
   \   0002B7   7400         MOV     A,#0x0
   \   0002B9   F0           MOVX    @DPTR,A
   \   0002BA   A3           INC     DPTR
   \   0002BB   7400         MOV     A,#0x0
   \   0002BD   F0           MOVX    @DPTR,A
    237            UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();
   \   0002BE                ; Setup parameters for call to function uip_icmp6chksum
   \   0002BE   12....       LCALL   ??uip_icmp6chksum?relay
   \   0002C1   8A..         MOV     ?V0 + 0,R2
   \   0002C3   8B..         MOV     ?V0 + 1,R3
   \   0002C5   A8..         MOV     R0,?V0 + 0
   \   0002C7   A9..         MOV     R1,?V0 + 1
   \   0002C9   E5..         MOV     A,?V0 + 0
   \   0002CB   F4           CPL     A
   \   0002CC   FA           MOV     R2,A
   \   0002CD   E5..         MOV     A,?V0 + 1
   \   0002CF   F4           CPL     A
   \   0002D0   FB           MOV     R3,A
   \   0002D1   90....       MOV     DPTR,#uip_ext_len
   \   0002D4   E0           MOVX    A,@DPTR
   \   0002D5   F8           MOV     R0,A
   \   0002D6   7900         MOV     R1,#0x0
   \   0002D8   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0002DA   28           ADD     A,R0
   \   0002DB   F8           MOV     R0,A
   \   0002DC   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0002DE   39           ADDC    A,R1
   \   0002DF   F9           MOV     R1,A
   \   0002E0   E8           MOV     A,R0
   \   0002E1   242A         ADD     A,#0x2a
   \   0002E3   F582         MOV     DPL,A
   \   0002E5   E9           MOV     A,R1
   \   0002E6   3400         ADDC    A,#0x0
   \   0002E8   F583         MOV     DPH,A
   \   0002EA   EA           MOV     A,R2
   \   0002EB   F0           MOVX    @DPTR,A
   \   0002EC   A3           INC     DPTR
   \   0002ED   EB           MOV     A,R3
   \   0002EE   F0           MOVX    @DPTR,A
    238          
    239            UIP_STAT(++uip_stat.icmp.sent);
    240          
    241            PRINTF("Sending ICMPv6 ERROR message to");
    242            PRINT6ADDR(&UIP_IP_BUF->destipaddr);
    243            PRINTF("from");
    244            PRINT6ADDR(&UIP_IP_BUF->srcipaddr);
    245            PRINTF("\n");
    246            return;
   \                     ??uip_icmp6_error_output_2:
   \   0002EF   7F06         MOV     R7,#0x6
   \   0002F1   02....       LJMP    ?BANKED_LEAVE_XDATA
    247          }
    248          
    249          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    250          void
    251          uip_icmp6_send(uip_ipaddr_t *dest, int type, int code, int payload_len)
   \                     uip_icmp6_send:
    252          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8C..         MOV     ?V0 + 2,R4
   \   000007   8D..         MOV     ?V0 + 3,R5
   \   000009   740E         MOV     A,#0xe
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 1,A
    253          
    254            UIP_IP_BUF->vtc = 0x60;
   \   000015   90....       MOV     DPTR,#uip_aligned_buf
   \   000018   7460         MOV     A,#0x60
   \   00001A   F0           MOVX    @DPTR,A
    255            UIP_IP_BUF->tcflow = 0;
   \   00001B   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   00001E   7400         MOV     A,#0x0
   \   000020   F0           MOVX    @DPTR,A
    256            UIP_IP_BUF->flow = 0;
   \   000021   90....       MOV     DPTR,#uip_aligned_buf + 2
   \   000024   7400         MOV     A,#0x0
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7400         MOV     A,#0x0
   \   00002A   F0           MOVX    @DPTR,A
    257            UIP_IP_BUF->proto = UIP_PROTO_ICMP6;
   \   00002B   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   00002E   743A         MOV     A,#0x3a
   \   000030   F0           MOVX    @DPTR,A
    258            UIP_IP_BUF->ttl = uip_ds6_if.cur_hop_limit;
   \   000031   90....       MOV     DPTR,#uip_ds6_if + 4
   \   000034   E0           MOVX    A,@DPTR
   \   000035   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   000038   F0           MOVX    @DPTR,A
   \   000039   7410         MOV     A,#0x10
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FE           MOV     R6,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   FF           MOV     R7,A
    259            UIP_IP_BUF->len[0] = (UIP_ICMPH_LEN + payload_len) >> 8;
   \   000043   EE           MOV     A,R6
   \   000044   2404         ADD     A,#0x4
   \   000046   F5..         MOV     ?V0 + 4,A
   \   000048   EF           MOV     A,R7
   \   000049   3400         ADDC    A,#0x0
   \   00004B   F5..         MOV     ?V0 + 5,A
   \   00004D   7408         MOV     A,#0x8
   \   00004F   78..         MOV     R0,#?V0 + 4
   \   000051   12....       LCALL   ?SS_SHR
   \   000054   E5..         MOV     A,?V0 + 4
   \   000056   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   000059   F0           MOVX    @DPTR,A
    260            UIP_IP_BUF->len[1] = (UIP_ICMPH_LEN + payload_len) & 0xff;
   \   00005A   EE           MOV     A,R6
   \   00005B   2404         ADD     A,#0x4
   \   00005D   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   000060   F0           MOVX    @DPTR,A
    261          
    262            memcpy(&UIP_IP_BUF->destipaddr, dest, sizeof(*dest));
   \   000061                ; Setup parameters for call to function memcpy
   \   000061   75..10       MOV     ?V0 + 4,#0x10
   \   000064   75..00       MOV     ?V0 + 5,#0x0
   \   000067   78..         MOV     R0,#?V0 + 4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EA           MOV     A,R2
   \   00006D   FC           MOV     R4,A
   \   00006E   EB           MOV     A,R3
   \   00006F   FD           MOV     R5,A
   \   000070   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   000072   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000074   12....       LCALL   ??memcpy?relay
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
    263            uip_ds6_select_src(&UIP_IP_BUF->srcipaddr, &UIP_IP_BUF->destipaddr);
   \   00007C                ; Setup parameters for call to function uip_ds6_select_src
   \   00007C   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   00007E   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000080   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   000082   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   000084   12....       LCALL   ??uip_ds6_select_src?relay
    264          
    265            UIP_ICMP_BUF->type = type;
   \   000087   E5..         MOV     A,?V0 + 2
   \   000089   90....       MOV     DPTR,#uip_ext_len
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   7900         MOV     R1,#0x0
   \   000090   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000092   28           ADD     A,R0
   \   000093   F8           MOV     R0,A
   \   000094   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000096   39           ADDC    A,R1
   \   000097   F9           MOV     R1,A
   \   000098   E8           MOV     A,R0
   \   000099   2428         ADD     A,#0x28
   \   00009B   F582         MOV     DPL,A
   \   00009D   E9           MOV     A,R1
   \   00009E   3400         ADDC    A,#0x0
   \   0000A0   F583         MOV     DPH,A
   \   0000A2   E5..         MOV     A,?V0 + 2
   \   0000A4   F0           MOVX    @DPTR,A
    266            UIP_ICMP_BUF->icode = code;
   \   0000A5   E5..         MOV     A,?V0 + 0
   \   0000A7   90....       MOV     DPTR,#uip_ext_len
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F8           MOV     R0,A
   \   0000AC   7900         MOV     R1,#0x0
   \   0000AE   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0000B0   28           ADD     A,R0
   \   0000B1   F8           MOV     R0,A
   \   0000B2   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0000B4   39           ADDC    A,R1
   \   0000B5   F9           MOV     R1,A
   \   0000B6   E8           MOV     A,R0
   \   0000B7   2429         ADD     A,#0x29
   \   0000B9   F582         MOV     DPL,A
   \   0000BB   E9           MOV     A,R1
   \   0000BC   3400         ADDC    A,#0x0
   \   0000BE   F583         MOV     DPH,A
   \   0000C0   E5..         MOV     A,?V0 + 0
   \   0000C2   F0           MOVX    @DPTR,A
    267          
    268            UIP_ICMP_BUF->icmpchksum = 0;
   \   0000C3   90....       MOV     DPTR,#uip_ext_len
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F8           MOV     R0,A
   \   0000C8   7900         MOV     R1,#0x0
   \   0000CA   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0000CC   28           ADD     A,R0
   \   0000CD   F8           MOV     R0,A
   \   0000CE   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   0000D0   39           ADDC    A,R1
   \   0000D1   F9           MOV     R1,A
   \   0000D2   E8           MOV     A,R0
   \   0000D3   242A         ADD     A,#0x2a
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   E9           MOV     A,R1
   \   0000D8   3400         ADDC    A,#0x0
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   7400         MOV     A,#0x0
   \   0000DE   F0           MOVX    @DPTR,A
   \   0000DF   A3           INC     DPTR
   \   0000E0   7400         MOV     A,#0x0
   \   0000E2   F0           MOVX    @DPTR,A
    269            UIP_ICMP_BUF->icmpchksum = ~uip_icmp6chksum();
   \   0000E3                ; Setup parameters for call to function uip_icmp6chksum
   \   0000E3   12....       LCALL   ??uip_icmp6chksum?relay
   \   0000E6   8A..         MOV     ?V0 + 0,R2
   \   0000E8   8B..         MOV     ?V0 + 1,R3
   \   0000EA   A8..         MOV     R0,?V0 + 0
   \   0000EC   A9..         MOV     R1,?V0 + 1
   \   0000EE   E5..         MOV     A,?V0 + 0
   \   0000F0   F4           CPL     A
   \   0000F1   FA           MOV     R2,A
   \   0000F2   E5..         MOV     A,?V0 + 1
   \   0000F4   F4           CPL     A
   \   0000F5   FB           MOV     R3,A
   \   0000F6   90....       MOV     DPTR,#uip_ext_len
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   F8           MOV     R0,A
   \   0000FB   7900         MOV     R1,#0x0
   \   0000FD   74..         MOV     A,#uip_aligned_buf & 0xff
   \   0000FF   28           ADD     A,R0
   \   000100   F8           MOV     R0,A
   \   000101   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000103   39           ADDC    A,R1
   \   000104   F9           MOV     R1,A
   \   000105   E8           MOV     A,R0
   \   000106   242A         ADD     A,#0x2a
   \   000108   F582         MOV     DPL,A
   \   00010A   E9           MOV     A,R1
   \   00010B   3400         ADDC    A,#0x0
   \   00010D   F583         MOV     DPH,A
   \   00010F   EA           MOV     A,R2
   \   000110   F0           MOVX    @DPTR,A
   \   000111   A3           INC     DPTR
   \   000112   EB           MOV     A,R3
   \   000113   F0           MOVX    @DPTR,A
    270          
    271            uip_len = UIP_IPH_LEN + UIP_ICMPH_LEN + payload_len;
   \   000114   EE           MOV     A,R6
   \   000115   242C         ADD     A,#0x2c
   \   000117   F8           MOV     R0,A
   \   000118   EF           MOV     A,R7
   \   000119   3400         ADDC    A,#0x0
   \   00011B   F9           MOV     R1,A
   \   00011C   90....       MOV     DPTR,#uip_len
   \   00011F   E8           MOV     A,R0
   \   000120   F0           MOVX    @DPTR,A
   \   000121   A3           INC     DPTR
   \   000122   E9           MOV     A,R1
   \   000123   F0           MOVX    @DPTR,A
    272            tcpip_ipv6_output();
   \   000124                ; Setup parameters for call to function tcpip_ipv6_output
   \   000124   12....       LCALL   ??tcpip_ipv6_output?relay
    273          }
   \   000127   7F06         MOV     R7,#0x6
   \   000129   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_icmp6_echo_request_input?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_icmp6_echo_request_input

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_icmp6_error_output?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_icmp6_error_output

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uip_icmp6_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uip_icmp6_send
    274          /*---------------------------------------------------------------------------*/
    275          
    276          /** @} */
    277          #endif /* UIP_CONF_IPV6 */

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     12  uip_icmp6_echo_request_input
                          0 0 12 -> memcpy
                          0 0 12 -> memmove
                          0 0 10 -> uip_ds6_select_src
                          0 0 10 -> uip_icmp6chksum
       1      0     20  uip_icmp6_error_output
                          0 0 16 -> memcpy
                          0 0 16 -> memmove
                          0 0 14 -> uip_ds6_select_src
                          0 0 14 -> uip_htonl
                          0 0 14 -> uip_icmp6chksum
       1      0     20  uip_icmp6_send
                          0 0 16 -> memcpy
                          0 0 14 -> tcpip_ipv6_output
                          0 0 14 -> uip_ds6_select_src
                          0 0 14 -> uip_icmp6chksum


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??uip_icmp6_echo_request_input?relay
       6  ??uip_icmp6_error_output?relay
       6  ??uip_icmp6_send?relay
      16  tmp_ipaddr
     453  uip_icmp6_echo_request_input
     756  uip_icmp6_error_output
     300  uip_icmp6_send

 
 1 509 bytes in segment BANKED_CODE
    18 bytes in segment BANK_RELAYS
    16 bytes in segment XDATA_Z
 
 1 527 bytes of CODE  memory
    16 bytes of XDATA memory

Errors: none
Warnings: none
