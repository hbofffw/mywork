###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             03/Apr/2014  10:45:41 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\myWork\myWork\core\net\sicslowpan.c             #
#    Command line       =  D:\myWork\myWork\core\net\sicslowpan.c -D          #
#                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC             #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\ -lA D:\myWork\myWork\examples\wsn2530dk\my #
#                          Project\coord\List\ --diag_suppress                #
#                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o          #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\ -e --no_cse --no_unroll --no_inline         #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 --preinclude D:\myWork\myWork\examples\wsn2530d #
#                          k\myProject\..\..\..\cpu\cc253x\cc253x.h -I        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\cpu\cc253x\ -I D:\myWork\myWork\examples\wsn2 #
#                          530dk\myProject\..\..\..\platform\wsn2530dk\ -I    #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\core\ -I D:\myWork\myWork\examples\wsn2530dk\ #
#                          myProject\..\..\..\apps\ -I                        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\ -Ol #
#    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\sicslowpan.lst                              #
#    Object file        =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\sicslowpan.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\myWork\myWork\core\net\sicslowpan.c
      1          /**
      2           * \addtogroup sicslowpan
      3           * @{
      4           */
      5          /*
      6           * Copyright (c) 2008, Swedish Institute of Computer Science.
      7           * All rights reserved.
      8           *
      9           * Redistribution and use in source and binary forms, with or without
     10           * modification, are permitted provided that the following conditions
     11           * are met:
     12           * 1. Redistributions of source code must retain the above copyright
     13           *    notice, this list of conditions and the following disclaimer.
     14           * 2. Redistributions in binary form must reproduce the above copyright
     15           *    notice, this list of conditions and the following disclaimer in the
     16           *    documentation and/or other materials provided with the distribution.
     17           * 3. Neither the name of the Institute nor the names of its contributors
     18           *    may be used to endorse or promote products derived from this software
     19           *    without specific prior written permission.
     20           *
     21           * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
     22           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     23           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     24           * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
     25           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     26           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     27           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     28           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     29           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     30           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     31           * SUCH DAMAGE.
     32           *
     33           * This file is part of the Contiki operating system.
     34           *
     35           */
     36          /**
     37           * \file
     38           *         6lowpan implementation (RFC4944 and draft-ietf-6lowpan-hc-06)
     39           *
     40           * \author Adam Dunkels <adam@sics.se>
     41           * \author Nicolas Tsiftes <nvt@sics.se>
     42           * \author Niclas Finne <nfi@sics.se>
     43           * \author Mathilde Durvy <mdurvy@cisco.com>
     44           * \author Julien Abeille <jabeille@cisco.com>
     45           * \author Joakim Eriksson <joakime@sics.se>
     46           * \author Joel Hoglund <joel@sics.se>
     47           */
     48          
     49          /**
     50           * FOR HC-06 COMPLIANCE TODO:
     51           * -Add compression options to UDP, currently only supports
     52           *  both ports compressed or both ports elided
     53           *  
     54           * -Verify TC/FL compression works
     55           *  
     56           * -Add stateless multicast option
     57           */
     58          
     59          #include <string.h>
     60          
     61          #include "contiki.h"
     62          #include "dev/watchdog.h"
     63          #include "net/tcpip.h"
     64          #include "net/uip.h"
     65          #include "net/uip-ds6.h"
     66          #include "net/rime.h"
     67          #include "net/sicslowpan.h"
     68          #include "net/netstack.h"
     69          
     70          #if UIP_CONF_IPV6
     71          
     72          #include <stdio.h>
     73          
     74          #define DEBUG DEBUG_NONE
     75          #include "net/uip-debug.h"
     76          #if DEBUG
     77          /* PRINTFI and PRINTFO are defined for input and output to debug one without changing the timing of the other */
     78          uint8_t p;
     79          #include <stdio.h>
     80          #define PRINTFI(...) PRINTF(__VA_ARGS__)
     81          #define PRINTFO(...) PRINTF(__VA_ARGS__)
     82          #define PRINTPACKETBUF() PRINTF("RIME buffer: "); for(p = 0; p < packetbuf_datalen(); p++){PRINTF("%.2X", *(rime_ptr + p));} PRINTF("\n")
     83          #define PRINTUIPBUF() PRINTF("UIP buffer: "); for(p = 0; p < uip_len; p++){PRINTF("%.2X", uip_buf[p]);}PRINTF("\n")
     84          #define PRINTSICSLOWPANBUF() PRINTF("SICSLOWPAN buffer: "); for(p = 0; p < sicslowpan_len; p++){PRINTF("%.2X", sicslowpan_buf[p]);}PRINTF("\n")
     85          #else
     86          #define PRINTFI(...)
     87          #define PRINTFO(...)
     88          #define PRINTPACKETBUF()
     89          #define PRINTUIPBUF()
     90          #define PRINTSICSLOWPANBUF()
     91          #endif /* DEBUG == 1*/
     92          
     93          #if UIP_LOGGING
     94          #include <stdio.h>
     95          void uip_log(char *msg);
     96          #define UIP_LOG(m) uip_log(m)
     97          #else
     98          #define UIP_LOG(m)
     99          #endif /* UIP_LOGGING == 1 */
    100          
    101          #ifdef SICSLOWPAN_CONF_MAX_MAC_TRANSMISSIONS
    102          #define SICSLOWPAN_MAX_MAC_TRANSMISSIONS SICSLOWPAN_CONF_MAX_MAC_TRANSMISSIONS
    103          #else
    104          #define SICSLOWPAN_MAX_MAC_TRANSMISSIONS 4
    105          #endif
    106          
    107          #ifndef SICSLOWPAN_COMPRESSION
    108          #ifdef SICSLOWPAN_CONF_COMPRESSION
    109          #define SICSLOWPAN_COMPRESSION SICSLOWPAN_CONF_COMPRESSION
    110          #else
    111          #define SICSLOWPAN_COMPRESSION SICSLOWPAN_COMPRESSION_IPV6
    112          #endif /* SICSLOWPAN_CONF_COMPRESSION */
    113          #endif /* SICSLOWPAN_COMPRESSION */
    114          
    115          #define GET16(ptr,index) (((uint16_t)((ptr)[index] << 8)) | ((ptr)[(index) + 1]))
    116          #define SET16(ptr,index,value) do {     \
    117            (ptr)[index] = ((value) >> 8) & 0xff; \
    118            (ptr)[index + 1] = (value) & 0xff;    \
    119          } while(0)
    120          
    121          /** \name Pointers in the rime buffer
    122           *  @{
    123           */
    124          #define RIME_FRAG_PTR           (rime_ptr)
    125          #define RIME_FRAG_DISPATCH_SIZE 0   /* 16 bit */
    126          #define RIME_FRAG_TAG           2   /* 16 bit */
    127          #define RIME_FRAG_OFFSET        4   /* 8 bit */
    128          
    129          /* define the buffer as a byte array */
    130          #define RIME_IPHC_BUF              ((uint8_t *)(rime_ptr + rime_hdr_len))
    131          
    132          #define RIME_HC1_PTR            (rime_ptr + rime_hdr_len)
    133          #define RIME_HC1_DISPATCH       0 /* 8 bit */
    134          #define RIME_HC1_ENCODING       1 /* 8 bit */
    135          #define RIME_HC1_TTL            2 /* 8 bit */
    136          
    137          #define RIME_HC1_HC_UDP_PTR           (rime_ptr + rime_hdr_len)
    138          #define RIME_HC1_HC_UDP_DISPATCH      0 /* 8 bit */
    139          #define RIME_HC1_HC_UDP_HC1_ENCODING  1 /* 8 bit */
    140          #define RIME_HC1_HC_UDP_UDP_ENCODING  2 /* 8 bit */
    141          #define RIME_HC1_HC_UDP_TTL           3 /* 8 bit */
    142          #define RIME_HC1_HC_UDP_PORTS         4 /* 8 bit */
    143          #define RIME_HC1_HC_UDP_CHKSUM        5 /* 16 bit */
    144          
    145          /** \name Pointers in the sicslowpan and uip buffer
    146           *  @{
    147           */
    148          #define SICSLOWPAN_IP_BUF   ((struct uip_ip_hdr *)&sicslowpan_buf[UIP_LLH_LEN])
    149          #define SICSLOWPAN_UDP_BUF ((struct uip_udp_hdr *)&sicslowpan_buf[UIP_LLIPH_LEN])
    150          
    151          #define UIP_IP_BUF          ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])
    152          #define UIP_UDP_BUF          ((struct uip_udp_hdr *)&uip_buf[UIP_LLIPH_LEN])
    153          #define UIP_TCP_BUF          ((struct uip_tcp_hdr *)&uip_buf[UIP_LLIPH_LEN])
    154          #define UIP_ICMP_BUF          ((struct uip_icmp_hdr *)&uip_buf[UIP_LLIPH_LEN])
    155          /** @} */
    156          
    157          
    158          /** \brief Size of the 802.15.4 payload (127byte - 25 for MAC header) */
    159          #ifdef SICSLOWPAN_CONF_MAC_MAX_PAYLOAD
    160          #define MAC_MAX_PAYLOAD SICSLOWPAN_CONF_MAC_MAX_PAYLOAD
    161          #else /* SICSLOWPAN_CONF_MAC_MAX_PAYLOAD */
    162          #define MAC_MAX_PAYLOAD 102
    163          #endif /* SICSLOWPAN_CONF_MAC_MAX_PAYLOAD */
    164          
    165          
    166          /** \brief Some MAC layers need a minimum payload, which is
    167              configurable through the SICSLOWPAN_CONF_MIN_MAC_PAYLOAD
    168              option. */
    169          #ifdef SICSLOWPAN_CONF_COMPRESSION_THRESHOLD
    170          #define COMPRESSION_THRESHOLD SICSLOWPAN_CONF_COMPRESSION_THRESHOLD
    171          #else
    172          #define COMPRESSION_THRESHOLD 0
    173          #endif
    174          
    175          /** \name General variables
    176           *  @{
    177           */
    178          #ifdef SICSLOWPAN_NH_COMPRESSOR
    179          /** A pointer to the additional compressor */
    180          extern struct sicslowpan_nh_compressor SICSLOWPAN_NH_COMPRESSOR;
    181          #endif
    182          
    183          /**
    184           * A pointer to the rime buffer.
    185           * We initialize it to the beginning of the rime buffer, then
    186           * access different fields by updating the offset rime_hdr_len.
    187           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    188          static uint8_t *rime_ptr;
   \                     rime_ptr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    189          
    190          /**
    191           * rime_hdr_len is the total length of (the processed) 6lowpan headers
    192           * (fragment headers, IPV6 or HC1, HC2, and HC1 and HC2 non compressed
    193           * fields).
    194           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    195          static uint8_t rime_hdr_len;
   \                     rime_hdr_len:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    196          
    197          /**
    198           * The length of the payload in the Rime buffer.
    199           * The payload is what comes after the compressed or uncompressed
    200           * headers (can be the IP payload if the IP header only is compressed
    201           * or the UDP payload if the UDP header is also compressed)
    202           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8_t rime_payload_len;
   \                     rime_payload_len:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    204          
    205          /**
    206           * uncomp_hdr_len is the length of the headers before compression (if HC2
    207           * is used this includes the UDP header in addition to the IP header).
    208           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    209          static uint8_t uncomp_hdr_len;
   \                     uncomp_hdr_len:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    210          
    211          /**
    212           * the result of the last transmitted fragment
    213           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    214          static int last_tx_status;
   \                     last_tx_status:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    215          /** @} */
    216          
    217          #if SICSLOWPAN_CONF_FRAG
    218          /** \name Fragmentation related variables
    219           *  @{
    220           */
    221          
    222          static uint16_t sicslowpan_len;
    223          
    224          /**
    225           * The buffer used for the 6lowpan reassembly.
    226           * This buffer contains only the IPv6 packet (no MAC header, 6lowpan, etc).
    227           * It has a fix size as we do not use dynamic memory allocation.
    228           */
    229          static uip_buf_t sicslowpan_aligned_buf;
    230          #define sicslowpan_buf (sicslowpan_aligned_buf.u8)
    231          
    232          /** The total length of the IPv6 packet in the sicslowpan_buf. */
    233          
    234          /**
    235           * length of the ip packet already sent / received.
    236           * It includes IP and transport headers.
    237           */
    238          static uint16_t processed_ip_in_len;
    239          
    240          /** Datagram tag to be put in the fragments I send. */
    241          static uint16_t my_tag;
    242          
    243          /** When reassembling, the tag in the fragments being merged. */
    244          static uint16_t reass_tag;
    245          
    246          /** When reassembling, the source address of the fragments being merged */
    247          rimeaddr_t frag_sender;
    248          
    249          /** Reassembly %process %timer. */
    250          static struct timer reass_timer;
    251          
    252          /** @} */
    253          #else /* SICSLOWPAN_CONF_FRAG */
    254          /** The buffer used for the 6lowpan processing is uip_buf.
    255              We do not use any additional buffer.*/
    256          #define sicslowpan_buf uip_buf
    257          #define sicslowpan_len uip_len
    258          #endif /* SICSLOWPAN_CONF_FRAG */
    259          
    260          /*-------------------------------------------------------------------------*/
    261          /* Rime Sniffer support for one single listener to enable powertrace of IP */
    262          /*-------------------------------------------------------------------------*/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    263          static struct rime_sniffer *callback = NULL;
   \                     callback:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    264          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    265          void
    266          rime_sniffer_add(struct rime_sniffer *s)
   \                     rime_sniffer_add:
    267          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    268            callback = s;
   \   000004   90....       MOV     DPTR,#callback
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    269          }
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET
    270          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    271          void
    272          rime_sniffer_remove(struct rime_sniffer *s)
   \                     rime_sniffer_remove:
    273          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    274            callback = NULL;
   \   000004   90....       MOV     DPTR,#callback
   \   000007   7400         MOV     A,#0x0
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   7400         MOV     A,#0x0
   \   00000D   F0           MOVX    @DPTR,A
    275          }
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
    276          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    277          static void
    278          set_packet_attrs()
   \                     set_packet_attrs:
    279          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    280            int c = 0;
   \   000005   7E00         MOV     R6,#0x0
   \   000007   7F00         MOV     R7,#0x0
    281            /* set protocol in NETWORK_ID */
    282            packetbuf_set_attr(PACKETBUF_ATTR_NETWORK_ID, UIP_IP_BUF->proto);
   \   000009                ; Setup parameters for call to function packetbuf_set_attr
   \   000009   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FA           MOV     R2,A
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   7902         MOV     R1,#0x2
   \   000012   12....       LCALL   ??packetbuf_set_attr?relay
    283          
    284            /* assign values to the channel attribute (port or type + code) */
    285            if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
   \   000015   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6411         XRL     A,#0x11
   \   00001B   701D         JNZ     ??set_packet_attrs_0
    286              c = UIP_UDP_BUF->srcport;
   \   00001D   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FE           MOV     R6,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   FF           MOV     R7,A
    287              if(UIP_UDP_BUF->destport < c) {
   \   000025   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000028   C3           CLR     C
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   9E           SUBB    A,R6
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   9F           SUBB    A,R7
   \   00002E   504E         JNC     ??set_packet_attrs_1
    288                c = UIP_UDP_BUF->destport;
   \   000030   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FE           MOV     R6,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FF           MOV     R7,A
   \   000038   8044         SJMP    ??set_packet_attrs_1
    289              }
    290            } else if(UIP_IP_BUF->proto == UIP_PROTO_TCP) {
   \                     ??set_packet_attrs_0:
   \   00003A   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6406         XRL     A,#0x6
   \   000040   701D         JNZ     ??set_packet_attrs_2
    291              c = UIP_TCP_BUF->srcport;
   \   000042   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   000045   E0           MOVX    A,@DPTR
   \   000046   FE           MOV     R6,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   FF           MOV     R7,A
    292              if(UIP_TCP_BUF->destport < c) {
   \   00004A   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   00004D   C3           CLR     C
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   9E           SUBB    A,R6
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   9F           SUBB    A,R7
   \   000053   5029         JNC     ??set_packet_attrs_1
    293                c = UIP_TCP_BUF->destport;
   \   000055   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FE           MOV     R6,A
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   FF           MOV     R7,A
   \   00005D   801F         SJMP    ??set_packet_attrs_1
    294              }
    295            } else if(UIP_IP_BUF->proto == UIP_PROTO_ICMP6) {
   \                     ??set_packet_attrs_2:
   \   00005F   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000062   E0           MOVX    A,@DPTR
   \   000063   643A         XRL     A,#0x3a
   \   000065   7017         JNZ     ??set_packet_attrs_1
    296              c = UIP_ICMP_BUF->type << 8 | UIP_ICMP_BUF->icode;
   \   000067   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   F8           MOV     R0,A
   \   00006C   7900         MOV     R1,#0x0
   \   00006E   E4           CLR     A
   \   00006F   C8           XCH     A,R0
   \   000070   F9           MOV     R1,A
   \   000071   90....       MOV     DPTR,#uip_aligned_buf + 41
   \   000074   E0           MOVX    A,@DPTR
   \   000075   FA           MOV     R2,A
   \   000076   7B00         MOV     R3,#0x0
   \   000078   E8           MOV     A,R0
   \   000079   4A           ORL     A,R2
   \   00007A   FE           MOV     R6,A
   \   00007B   E9           MOV     A,R1
   \   00007C   4B           ORL     A,R3
   \   00007D   FF           MOV     R7,A
    297            }
    298          
    299            packetbuf_set_attr(PACKETBUF_ATTR_CHANNEL, c);
   \                     ??set_packet_attrs_1:
   \   00007E                ; Setup parameters for call to function packetbuf_set_attr
   \   00007E   EE           MOV     A,R6
   \   00007F   FA           MOV     R2,A
   \   000080   EF           MOV     A,R7
   \   000081   FB           MOV     R3,A
   \   000082   7901         MOV     R1,#0x1
   \   000084   12....       LCALL   ??packetbuf_set_attr?relay
    300          
    301          /*   if(uip_ds6_is_my_addr(&UIP_IP_BUF->srcipaddr)) { */
    302          /*     own = 1; */
    303          /*   } */
    304          
    305          }
   \   000087   7F01         MOV     R7,#0x1
   \   000089   02....       LJMP    ?BANKED_LEAVE_XDATA
    306          
    307          
    308          
    309          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
    310          /** \name HC06 specific variables
    311           *  @{
    312           */
    313          
    314          /** Addresses contexts for IPHC. */
    315          #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0
    316          static struct sicslowpan_addr_context 

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    317          addr_contexts[SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS];
   \                     addr_contexts:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z
    318          #endif
    319          
    320          /** pointer to an address context. */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    321          static struct sicslowpan_addr_context *context;
   \                     context:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    322          
    323          /** pointer to the byte where to write next inline field. */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    324          static uint8_t *hc06_ptr;
   \                     hc06_ptr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    325          
    326          /* Uncompression of linklocal */
    327          /*   0 -> 16 bytes from packet  */
    328          /*   1 -> 2 bytes from prefix - bunch of zeroes and 8 from packet */
    329          /*   2 -> 2 bytes from prefix - 0000::00ff:fe00:XXXX from packet */
    330          /*   3 -> 2 bytes from prefix - infer 8 bytes from lladdr */
    331          /*   NOTE: => the uncompress function does change 0xf to 0x10 */
    332          /*   NOTE: 0x00 => no-autoconfig => unspecified */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    333          const uint8_t unc_llconf[] = {0x0f,0x28,0x22,0x20};
   \                     unc_llconf:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for unc_llconf>`
   \   000004                REQUIRE __INIT_XDATA_I
    334          
    335          /* Uncompression of ctx-based */
    336          /*   0 -> 0 bits from packet [unspecified / reserved] */
    337          /*   1 -> 8 bytes from prefix - bunch of zeroes and 8 from packet */
    338          /*   2 -> 8 bytes from prefix - 0000::00ff:fe00:XXXX + 2 from packet */
    339          /*   3 -> 8 bytes from prefix - infer 8 bytes from lladdr */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    340          const uint8_t unc_ctxconf[] = {0x00,0x88,0x82,0x80};
   \                     unc_ctxconf:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for unc_ctxconf>`
   \   000004                REQUIRE __INIT_XDATA_I
    341          
    342          /* Uncompression of ctx-based */
    343          /*   0 -> 0 bits from packet  */
    344          /*   1 -> 2 bytes from prefix - bunch of zeroes 5 from packet */
    345          /*   2 -> 2 bytes from prefix - zeroes + 3 from packet */
    346          /*   3 -> 2 bytes from prefix - infer 1 bytes from lladdr */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    347          const uint8_t unc_mxconf[] = {0x0f, 0x25, 0x23, 0x21};
   \                     unc_mxconf:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for unc_mxconf>`
   \   000004                REQUIRE __INIT_XDATA_I
    348          
    349          /* Link local prefix */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    350          const uint8_t llprefix[] = {0xfe, 0x80};
   \                     llprefix:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for llprefix>`
   \   000002                REQUIRE __INIT_XDATA_I
    351          
    352          /* TTL uncompression values */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    353          static const uint8_t ttl_values[] = {0, 1, 64, 255};
   \                     ttl_values:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for ttl_values>`
   \   000004                REQUIRE __INIT_XDATA_I
    354          
    355          /*--------------------------------------------------------------------*/
    356          /** \name HC06 related functions
    357           * @{                                                                 */
    358          /*--------------------------------------------------------------------*/
    359          /** \brief find the context corresponding to prefix ipaddr */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    360          static struct sicslowpan_addr_context*
    361          addr_context_lookup_by_prefix(uip_ipaddr_t *ipaddr)
   \                     addr_context_lookup_by_prefix:
    362          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    363          /* Remove code to avoid warnings and save flash if no context is used */
    364          #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0
    365            int i;
    366            for(i = 0; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
   \   000009   75..00       MOV     ?V0 + 0,#0x0
   \   00000C   75..00       MOV     ?V0 + 1,#0x0
   \   00000F   800C         SJMP    ??addr_context_lookup_by_prefix_0
   \                     ??addr_context_lookup_by_prefix_1:
   \   000011   E5..         MOV     A,?V0 + 0
   \   000013   2401         ADD     A,#0x1
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   E5..         MOV     A,?V0 + 1
   \   000019   3400         ADDC    A,#0x0
   \   00001B   F5..         MOV     ?V0 + 1,A
   \                     ??addr_context_lookup_by_prefix_0:
   \   00001D   C3           CLR     C
   \   00001E   E5..         MOV     A,?V0 + 0
   \   000020   9401         SUBB    A,#0x1
   \   000022   E5..         MOV     A,?V0 + 1
   \   000024   9400         SUBB    A,#0x0
   \   000026   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000028   65D0         XRL     A,PSW
   \   00002A   33           RLC     A
   \   00002B   4003         JC      $+5
   \   00002D   02....       LJMP    ??addr_context_lookup_by_prefix_2 & 0xFFFF
    367              if((addr_contexts[i].used == 1) &&
    368                 uip_ipaddr_prefixcmp(&addr_contexts[i].prefix, ipaddr, 64)) {
   \   000030   A8..         MOV     R0,?V0 + 0
   \   000032   A9..         MOV     R1,?V0 + 1
   \   000034   E8           MOV     A,R0
   \   000035   75F00A       MOV     B,#0xa
   \   000038   A4           MUL     AB
   \   000039   C8           XCH     A,R0
   \   00003A   AAF0         MOV     R2,B
   \   00003C   75F000       MOV     B,#0x0
   \   00003F   A4           MUL     AB
   \   000040   2A           ADD     A,R2
   \   000041   FA           MOV     R2,A
   \   000042   75F00A       MOV     B,#0xa
   \   000045   E5..         MOV     A,?V0 + 1
   \   000047   A4           MUL     AB
   \   000048   2A           ADD     A,R2
   \   000049   F9           MOV     R1,A
   \   00004A   74..         MOV     A,#addr_contexts & 0xff
   \   00004C   28           ADD     A,R0
   \   00004D   F582         MOV     DPL,A
   \   00004F   74..         MOV     A,#(addr_contexts >> 8) & 0xff
   \   000051   39           ADDC    A,R1
   \   000052   F583         MOV     DPH,A
   \   000054   E0           MOVX    A,@DPTR
   \   000055   6401         XRL     A,#0x1
   \   000057   70B8         JNZ     ??addr_context_lookup_by_prefix_1
   \   000059                ; Setup parameters for call to function memcmp
   \   000059   75..08       MOV     ?V0 + 2,#0x8
   \   00005C   75..00       MOV     ?V0 + 3,#0x0
   \   00005F   78..         MOV     R0,#?V0 + 2
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   EE           MOV     A,R6
   \   000065   FC           MOV     R4,A
   \   000066   EF           MOV     A,R7
   \   000067   FD           MOV     R5,A
   \   000068   A8..         MOV     R0,?V0 + 0
   \   00006A   A9..         MOV     R1,?V0 + 1
   \   00006C   E8           MOV     A,R0
   \   00006D   75F00A       MOV     B,#0xa
   \   000070   A4           MUL     AB
   \   000071   C8           XCH     A,R0
   \   000072   AAF0         MOV     R2,B
   \   000074   75F000       MOV     B,#0x0
   \   000077   A4           MUL     AB
   \   000078   2A           ADD     A,R2
   \   000079   FA           MOV     R2,A
   \   00007A   75F00A       MOV     B,#0xa
   \   00007D   E5..         MOV     A,?V0 + 1
   \   00007F   A4           MUL     AB
   \   000080   2A           ADD     A,R2
   \   000081   F9           MOV     R1,A
   \   000082   74..         MOV     A,#(addr_contexts + 2) & 0xff
   \   000084   28           ADD     A,R0
   \   000085   FA           MOV     R2,A
   \   000086   74..         MOV     A,#((addr_contexts + 2) >> 8) & 0xff
   \   000088   39           ADDC    A,R1
   \   000089   FB           MOV     R3,A
   \   00008A   12....       LCALL   ??memcmp?relay
   \   00008D   7402         MOV     A,#0x2
   \   00008F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000092   8A..         MOV     ?V0 + 2,R2
   \   000094   8B..         MOV     ?V0 + 3,R3
   \   000096   E5..         MOV     A,?V0 + 2
   \   000098   45..         ORL     A,?V0 + 3
   \   00009A   6003         JZ      $+5
   \   00009C   02....       LJMP    ??addr_context_lookup_by_prefix_1 & 0xFFFF
    369                return &addr_contexts[i];
   \   00009F   E5..         MOV     A,?V0 + 0
   \   0000A1   75F00A       MOV     B,#0xa
   \   0000A4   A4           MUL     AB
   \   0000A5   C5..         XCH     A,?V0 + 0
   \   0000A7   A8F0         MOV     R0,B
   \   0000A9   75F000       MOV     B,#0x0
   \   0000AC   A4           MUL     AB
   \   0000AD   28           ADD     A,R0
   \   0000AE   F8           MOV     R0,A
   \   0000AF   75F00A       MOV     B,#0xa
   \   0000B2   E5..         MOV     A,?V0 + 1
   \   0000B4   A4           MUL     AB
   \   0000B5   28           ADD     A,R0
   \   0000B6   F5..         MOV     ?V0 + 1,A
   \   0000B8   74..         MOV     A,#addr_contexts & 0xff
   \   0000BA   25..         ADD     A,?V0 + 0
   \   0000BC   FA           MOV     R2,A
   \   0000BD   74..         MOV     A,#(addr_contexts >> 8) & 0xff
   \   0000BF   35..         ADDC    A,?V0 + 1
   \   0000C1   FB           MOV     R3,A
   \   0000C2   8004         SJMP    ??addr_context_lookup_by_prefix_3
    370              }
    371            }
    372          #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 */
    373            return NULL;
   \                     ??addr_context_lookup_by_prefix_2:
   \   0000C4   7A00         MOV     R2,#0x0
   \   0000C6   7B00         MOV     R3,#0x0
   \                     ??addr_context_lookup_by_prefix_3:
   \   0000C8   7F04         MOV     R7,#0x4
   \   0000CA   02....       LJMP    ?BANKED_LEAVE_XDATA
    374          }
    375          /*--------------------------------------------------------------------*/
    376          /** \brief find the context with the given number */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    377          static struct sicslowpan_addr_context*
    378          addr_context_lookup_by_number(uint8_t number)
   \                     addr_context_lookup_by_number:
    379          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    380          /* Remove code to avoid warnings and save flash if no context is used */ 
    381          #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0
    382            int i;
    383            for(i = 0; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
   \   000004   7A00         MOV     R2,#0x0
   \   000006   7B00         MOV     R3,#0x0
   \   000008   8008         SJMP    ??addr_context_lookup_by_number_0
   \                     ??addr_context_lookup_by_number_1:
   \   00000A   EA           MOV     A,R2
   \   00000B   2401         ADD     A,#0x1
   \   00000D   FA           MOV     R2,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   FB           MOV     R3,A
   \                     ??addr_context_lookup_by_number_0:
   \   000012   C3           CLR     C
   \   000013   EA           MOV     A,R2
   \   000014   9401         SUBB    A,#0x1
   \   000016   EB           MOV     A,R3
   \   000017   9400         SUBB    A,#0x0
   \   000019   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00001B   65D0         XRL     A,PSW
   \   00001D   33           RLC     A
   \   00001E   506E         JNC     ??addr_context_lookup_by_number_2
    384              if((addr_contexts[i].used == 1) &&
    385                 addr_contexts[i].number == number) {
   \   000020   EA           MOV     A,R2
   \   000021   FC           MOV     R4,A
   \   000022   EB           MOV     A,R3
   \   000023   FD           MOV     R5,A
   \   000024   EC           MOV     A,R4
   \   000025   75F00A       MOV     B,#0xa
   \   000028   A4           MUL     AB
   \   000029   CC           XCH     A,R4
   \   00002A   A8F0         MOV     R0,B
   \   00002C   75F000       MOV     B,#0x0
   \   00002F   A4           MUL     AB
   \   000030   28           ADD     A,R0
   \   000031   F8           MOV     R0,A
   \   000032   75F00A       MOV     B,#0xa
   \   000035   ED           MOV     A,R5
   \   000036   A4           MUL     AB
   \   000037   28           ADD     A,R0
   \   000038   FD           MOV     R5,A
   \   000039   74..         MOV     A,#addr_contexts & 0xff
   \   00003B   2C           ADD     A,R4
   \   00003C   F582         MOV     DPL,A
   \   00003E   74..         MOV     A,#(addr_contexts >> 8) & 0xff
   \   000040   3D           ADDC    A,R5
   \   000041   F583         MOV     DPH,A
   \   000043   E0           MOVX    A,@DPTR
   \   000044   6401         XRL     A,#0x1
   \   000046   70C2         JNZ     ??addr_context_lookup_by_number_1
   \   000048   EA           MOV     A,R2
   \   000049   FC           MOV     R4,A
   \   00004A   EB           MOV     A,R3
   \   00004B   FD           MOV     R5,A
   \   00004C   EC           MOV     A,R4
   \   00004D   75F00A       MOV     B,#0xa
   \   000050   A4           MUL     AB
   \   000051   CC           XCH     A,R4
   \   000052   A8F0         MOV     R0,B
   \   000054   75F000       MOV     B,#0x0
   \   000057   A4           MUL     AB
   \   000058   28           ADD     A,R0
   \   000059   F8           MOV     R0,A
   \   00005A   75F00A       MOV     B,#0xa
   \   00005D   ED           MOV     A,R5
   \   00005E   A4           MUL     AB
   \   00005F   28           ADD     A,R0
   \   000060   FD           MOV     R5,A
   \   000061   74..         MOV     A,#(addr_contexts + 1) & 0xff
   \   000063   2C           ADD     A,R4
   \   000064   F582         MOV     DPL,A
   \   000066   74..         MOV     A,#((addr_contexts + 1) >> 8) & 0xff
   \   000068   3D           ADDC    A,R5
   \   000069   F583         MOV     DPH,A
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   69           XRL     A,R1
   \   00006D   709B         JNZ     ??addr_context_lookup_by_number_1
    386                return &addr_contexts[i];
   \   00006F   EA           MOV     A,R2
   \   000070   75F00A       MOV     B,#0xa
   \   000073   A4           MUL     AB
   \   000074   CA           XCH     A,R2
   \   000075   A8F0         MOV     R0,B
   \   000077   75F000       MOV     B,#0x0
   \   00007A   A4           MUL     AB
   \   00007B   28           ADD     A,R0
   \   00007C   F8           MOV     R0,A
   \   00007D   75F00A       MOV     B,#0xa
   \   000080   EB           MOV     A,R3
   \   000081   A4           MUL     AB
   \   000082   28           ADD     A,R0
   \   000083   FB           MOV     R3,A
   \   000084   74..         MOV     A,#addr_contexts & 0xff
   \   000086   2A           ADD     A,R2
   \   000087   FA           MOV     R2,A
   \   000088   74..         MOV     A,#(addr_contexts >> 8) & 0xff
   \   00008A   3B           ADDC    A,R3
   \   00008B   FB           MOV     R3,A
   \   00008C   8004         SJMP    ??addr_context_lookup_by_number_3
    387              }
    388            }
    389          #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 */
    390            return NULL;
   \                     ??addr_context_lookup_by_number_2:
   \   00008E   7A00         MOV     R2,#0x0
   \   000090   7B00         MOV     R3,#0x0
   \                     ??addr_context_lookup_by_number_3:
   \   000092   D083         POP     DPH
   \   000094   D082         POP     DPL
   \   000096   02....       LJMP    ?BRET
    391          }
    392          /*--------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    393          static uint8_t
    394          compress_addr_64(uint8_t bitpos, uip_ipaddr_t *ipaddr, uip_lladdr_t *lladdr)
   \                     compress_addr_64:
    395          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    396            if(uip_is_addr_mac_addr_based(ipaddr, lladdr)) {
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   8C82         MOV     DPL,R4
   \   000017   8D83         MOV     DPH,R5
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6402         XRL     A,#0x2
   \   00001C   68           XRL     A,R0
   \   00001D   6003         JZ      $+5
   \   00001F   02....       LJMP    ??compress_addr_64_0 & 0xFFFF
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F8           MOV     R0,A
   \   000031   8C82         MOV     DPL,R4
   \   000033   8D83         MOV     DPH,R5
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   68           XRL     A,R0
   \   000038   6003         JZ      $+5
   \   00003A   02....       LJMP    ??compress_addr_64_0 & 0xFFFF
   \   00003D   8A82         MOV     DPL,R2
   \   00003F   8B83         MOV     DPH,R3
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   F8           MOV     R0,A
   \   00004D   8C82         MOV     DPL,R4
   \   00004F   8D83         MOV     DPH,R5
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   68           XRL     A,R0
   \   000055   6003         JZ      $+5
   \   000057   02....       LJMP    ??compress_addr_64_0 & 0xFFFF
   \   00005A   EA           MOV     A,R2
   \   00005B   240B         ADD     A,#0xb
   \   00005D   F582         MOV     DPL,A
   \   00005F   EB           MOV     A,R3
   \   000060   3400         ADDC    A,#0x0
   \   000062   F583         MOV     DPH,A
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F8           MOV     R0,A
   \   000066   8C82         MOV     DPL,R4
   \   000068   8D83         MOV     DPH,R5
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   68           XRL     A,R0
   \   00006F   7077         JNZ     ??compress_addr_64_0
   \   000071   EA           MOV     A,R2
   \   000072   240C         ADD     A,#0xc
   \   000074   F582         MOV     DPL,A
   \   000076   EB           MOV     A,R3
   \   000077   3400         ADDC    A,#0x0
   \   000079   F583         MOV     DPH,A
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F8           MOV     R0,A
   \   00007D   8C82         MOV     DPL,R4
   \   00007F   8D83         MOV     DPH,R5
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   A3           INC     DPTR
   \   000085   E0           MOVX    A,@DPTR
   \   000086   68           XRL     A,R0
   \   000087   705F         JNZ     ??compress_addr_64_0
   \   000089   EA           MOV     A,R2
   \   00008A   240D         ADD     A,#0xd
   \   00008C   F582         MOV     DPL,A
   \   00008E   EB           MOV     A,R3
   \   00008F   3400         ADDC    A,#0x0
   \   000091   F583         MOV     DPH,A
   \   000093   E0           MOVX    A,@DPTR
   \   000094   F8           MOV     R0,A
   \   000095   8C82         MOV     DPL,R4
   \   000097   8D83         MOV     DPH,R5
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   68           XRL     A,R0
   \   0000A0   7046         JNZ     ??compress_addr_64_0
   \   0000A2   EA           MOV     A,R2
   \   0000A3   240E         ADD     A,#0xe
   \   0000A5   F582         MOV     DPL,A
   \   0000A7   EB           MOV     A,R3
   \   0000A8   3400         ADDC    A,#0x0
   \   0000AA   F583         MOV     DPH,A
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   F8           MOV     R0,A
   \   0000AE   8C82         MOV     DPL,R4
   \   0000B0   8D83         MOV     DPH,R5
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   68           XRL     A,R0
   \   0000BA   702C         JNZ     ??compress_addr_64_0
   \   0000BC   EA           MOV     A,R2
   \   0000BD   240F         ADD     A,#0xf
   \   0000BF   F582         MOV     DPL,A
   \   0000C1   EB           MOV     A,R3
   \   0000C2   3400         ADDC    A,#0x0
   \   0000C4   F583         MOV     DPH,A
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F8           MOV     R0,A
   \   0000C8   8C82         MOV     DPL,R4
   \   0000CA   8D83         MOV     DPH,R5
   \   0000CC   A3           INC     DPTR
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   68           XRL     A,R0
   \   0000D5   7011         JNZ     ??compress_addr_64_0
    397              return 3 << bitpos; /* 0-bits */
   \   0000D7   75..03       MOV     ?V0 + 0,#0x3
   \   0000DA   75..00       MOV     ?V0 + 1,#0x0
   \   0000DD   EE           MOV     A,R6
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?S_SHL
   \   0000E3   A9..         MOV     R1,?V0 + 0
   \   0000E5   02....       LJMP    ??compress_addr_64_1 & 0xFFFF
    398            } else if(sicslowpan_is_iid_16_bit_compressable(ipaddr)) {
   \                     ??compress_addr_64_0:
   \   0000E8   8A82         MOV     DPL,R2
   \   0000EA   8B83         MOV     DPH,R3
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   A3           INC     DPTR
   \   0000F2   A3           INC     DPTR
   \   0000F3   A3           INC     DPTR
   \   0000F4   E0           MOVX    A,@DPTR
   \   0000F5   F8           MOV     R0,A
   \   0000F6   A3           INC     DPTR
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   F9           MOV     R1,A
   \   0000F9   E8           MOV     A,R0
   \   0000FA   49           ORL     A,R1
   \   0000FB   6003         JZ      $+5
   \   0000FD   02....       LJMP    ??compress_addr_64_2 & 0xFFFF
   \   000100   8A82         MOV     DPL,R2
   \   000102   8B83         MOV     DPH,R3
   \   000104   A3           INC     DPTR
   \   000105   A3           INC     DPTR
   \   000106   A3           INC     DPTR
   \   000107   A3           INC     DPTR
   \   000108   A3           INC     DPTR
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   7072         JNZ     ??compress_addr_64_2
   \   000111   EA           MOV     A,R2
   \   000112   240B         ADD     A,#0xb
   \   000114   F582         MOV     DPL,A
   \   000116   EB           MOV     A,R3
   \   000117   3400         ADDC    A,#0x0
   \   000119   F583         MOV     DPH,A
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   64FF         XRL     A,#0xff
   \   00011E   7063         JNZ     ??compress_addr_64_2
   \   000120   EA           MOV     A,R2
   \   000121   240C         ADD     A,#0xc
   \   000123   F582         MOV     DPL,A
   \   000125   EB           MOV     A,R3
   \   000126   3400         ADDC    A,#0x0
   \   000128   F583         MOV     DPH,A
   \   00012A   E0           MOVX    A,@DPTR
   \   00012B   64FE         XRL     A,#0xfe
   \   00012D   7054         JNZ     ??compress_addr_64_2
   \   00012F   EA           MOV     A,R2
   \   000130   240D         ADD     A,#0xd
   \   000132   F582         MOV     DPL,A
   \   000134   EB           MOV     A,R3
   \   000135   3400         ADDC    A,#0x0
   \   000137   F583         MOV     DPH,A
   \   000139   E0           MOVX    A,@DPTR
   \   00013A   7047         JNZ     ??compress_addr_64_2
    399              /* compress IID to 16 bits xxxx::0000:00ff:fe00:XXXX */
    400              memcpy(hc06_ptr, &ipaddr->u16[7], 2);
   \   00013C                ; Setup parameters for call to function memcpy
   \   00013C   75..02       MOV     ?V0 + 0,#0x2
   \   00013F   75..00       MOV     ?V0 + 1,#0x0
   \   000142   78..         MOV     R0,#?V0 + 0
   \   000144   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000147   EA           MOV     A,R2
   \   000148   240E         ADD     A,#0xe
   \   00014A   FC           MOV     R4,A
   \   00014B   EB           MOV     A,R3
   \   00014C   3400         ADDC    A,#0x0
   \   00014E   FD           MOV     R5,A
   \   00014F   90....       MOV     DPTR,#hc06_ptr
   \   000152   E0           MOVX    A,@DPTR
   \   000153   FA           MOV     R2,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   FB           MOV     R3,A
   \   000157   12....       LCALL   ??memcpy?relay
   \   00015A   7402         MOV     A,#0x2
   \   00015C   12....       LCALL   ?DEALLOC_XSTACK8
    401              hc06_ptr += 2;
   \   00015F   90....       MOV     DPTR,#hc06_ptr
   \   000162   E0           MOVX    A,@DPTR
   \   000163   2402         ADD     A,#0x2
   \   000165   F8           MOV     R0,A
   \   000166   A3           INC     DPTR
   \   000167   E0           MOVX    A,@DPTR
   \   000168   3400         ADDC    A,#0x0
   \   00016A   F9           MOV     R1,A
   \   00016B   90....       MOV     DPTR,#hc06_ptr
   \   00016E   E8           MOV     A,R0
   \   00016F   F0           MOVX    @DPTR,A
   \   000170   A3           INC     DPTR
   \   000171   E9           MOV     A,R1
   \   000172   F0           MOVX    @DPTR,A
    402              return 2 << bitpos; /* 16-bits */
   \   000173   75..02       MOV     ?V0 + 0,#0x2
   \   000176   75..00       MOV     ?V0 + 1,#0x0
   \   000179   EE           MOV     A,R6
   \   00017A   78..         MOV     R0,#?V0 + 0
   \   00017C   12....       LCALL   ?S_SHL
   \   00017F   A9..         MOV     R1,?V0 + 0
   \   000181   8045         SJMP    ??compress_addr_64_1
    403            } else {
    404              /* do not compress IID => xxxx::IID */
    405              memcpy(hc06_ptr, &ipaddr->u16[4], 8);
   \                     ??compress_addr_64_2:
   \   000183                ; Setup parameters for call to function memcpy
   \   000183   75..08       MOV     ?V0 + 0,#0x8
   \   000186   75..00       MOV     ?V0 + 1,#0x0
   \   000189   78..         MOV     R0,#?V0 + 0
   \   00018B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00018E   EA           MOV     A,R2
   \   00018F   2408         ADD     A,#0x8
   \   000191   FC           MOV     R4,A
   \   000192   EB           MOV     A,R3
   \   000193   3400         ADDC    A,#0x0
   \   000195   FD           MOV     R5,A
   \   000196   90....       MOV     DPTR,#hc06_ptr
   \   000199   E0           MOVX    A,@DPTR
   \   00019A   FA           MOV     R2,A
   \   00019B   A3           INC     DPTR
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   FB           MOV     R3,A
   \   00019E   12....       LCALL   ??memcpy?relay
   \   0001A1   7402         MOV     A,#0x2
   \   0001A3   12....       LCALL   ?DEALLOC_XSTACK8
    406              hc06_ptr += 8;
   \   0001A6   90....       MOV     DPTR,#hc06_ptr
   \   0001A9   E0           MOVX    A,@DPTR
   \   0001AA   2408         ADD     A,#0x8
   \   0001AC   F8           MOV     R0,A
   \   0001AD   A3           INC     DPTR
   \   0001AE   E0           MOVX    A,@DPTR
   \   0001AF   3400         ADDC    A,#0x0
   \   0001B1   F9           MOV     R1,A
   \   0001B2   90....       MOV     DPTR,#hc06_ptr
   \   0001B5   E8           MOV     A,R0
   \   0001B6   F0           MOVX    @DPTR,A
   \   0001B7   A3           INC     DPTR
   \   0001B8   E9           MOV     A,R1
   \   0001B9   F0           MOVX    @DPTR,A
    407              return 1 << bitpos; /* 64-bits */
   \   0001BA   75..01       MOV     ?V0 + 0,#0x1
   \   0001BD   75..00       MOV     ?V0 + 1,#0x0
   \   0001C0   EE           MOV     A,R6
   \   0001C1   78..         MOV     R0,#?V0 + 0
   \   0001C3   12....       LCALL   ?S_SHL
   \   0001C6   A9..         MOV     R1,?V0 + 0
   \                     ??compress_addr_64_1:
   \   0001C8   7F02         MOV     R7,#0x2
   \   0001CA   02....       LJMP    ?BANKED_LEAVE_XDATA
    408            }
    409          }
    410          
    411          /*-------------------------------------------------------------------- */
    412          /* Uncompress addresses based on a prefix and a postfix with zeroes in
    413           * between. If the postfix is zero in length it will use the link address
    414           * to configure the IP address (autoconf style).
    415           * pref_post_count takes a byte where the first nibble specify prefix count
    416           * and the second postfix count (NOTE: 15/0xf => 16 bytes copy).
    417           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    418          static void
    419          uncompress_addr(uip_ipaddr_t *ipaddr, uint8_t const prefix[],
   \                     uncompress_addr:
    420                          uint8_t pref_post_count, uip_lladdr_t *lladdr)
    421          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   89..         MOV     ?V0 + 4,R1
   \   00000B   7414         MOV     A,#0x14
   \   00000D   12....       LCALL   ?XSTACK_DISP0_8
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 10,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 11,A
    422            uint8_t prefcount = pref_post_count >> 4;
   \   000017   E5..         MOV     A,?V0 + 4
   \   000019   C4           SWAP    A
   \   00001A   540F         ANL     A,#0xf
   \   00001C   F5..         MOV     ?V0 + 0,A
    423            uint8_t postcount = pref_post_count & 0x0f;
   \   00001E   740F         MOV     A,#0xf
   \   000020   55..         ANL     A,?V0 + 4
   \   000022   F5..         MOV     ?V0 + 1,A
    424            /* full nibble 15 => 16 */
    425            prefcount = prefcount == 15 ? 16 : prefcount;
   \   000024   740F         MOV     A,#0xf
   \   000026   65..         XRL     A,?V0 + 0
   \   000028   7005         JNZ     ??uncompress_addr_0
   \   00002A   75..10       MOV     ?V0 + 2,#0x10
   \   00002D   8003         SJMP    ??uncompress_addr_1
   \                     ??uncompress_addr_0:
   \   00002F   85....       MOV     ?V0 + 2,?V0 + 0
   \                     ??uncompress_addr_1:
   \   000032   85....       MOV     ?V0 + 0,?V0 + 2
    426            postcount = postcount == 15 ? 16 : postcount;
   \   000035   740F         MOV     A,#0xf
   \   000037   65..         XRL     A,?V0 + 1
   \   000039   7005         JNZ     ??uncompress_addr_2
   \   00003B   75..10       MOV     ?V0 + 3,#0x10
   \   00003E   8003         SJMP    ??uncompress_addr_3
   \                     ??uncompress_addr_2:
   \   000040   85....       MOV     ?V0 + 3,?V0 + 1
   \                     ??uncompress_addr_3:
   \   000043   85....       MOV     ?V0 + 1,?V0 + 3
    427          
    428            PRINTF("Uncompressing %d + %d => ", prefcount, postcount);
    429          
    430            if(prefcount > 0) {
   \   000046   E5..         MOV     A,?V0 + 0
   \   000048   C3           CLR     C
   \   000049   9401         SUBB    A,#0x1
   \   00004B   4017         JC      ??uncompress_addr_4
    431              memcpy(ipaddr, prefix, prefcount);
   \   00004D                ; Setup parameters for call to function memcpy
   \   00004D   85....       MOV     ?V0 + 6,?V0 + 0
   \   000050   75..00       MOV     ?V0 + 7,#0x0
   \   000053   78..         MOV     R0,#?V0 + 6
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   EE           MOV     A,R6
   \   000059   FA           MOV     R2,A
   \   00005A   EF           MOV     A,R7
   \   00005B   FB           MOV     R3,A
   \   00005C   12....       LCALL   ??memcpy?relay
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
    432            }
    433            if(prefcount + postcount < 16) {
   \                     ??uncompress_addr_4:
   \   000064   85....       MOV     ?V0 + 8,?V0 + 0
   \   000067   75..00       MOV     ?V0 + 9,#0x0
   \   00006A   85....       MOV     ?V0 + 6,?V0 + 1
   \   00006D   75..00       MOV     ?V0 + 7,#0x0
   \   000070   E5..         MOV     A,?V0 + 8
   \   000072   25..         ADD     A,?V0 + 6
   \   000074   F8           MOV     R0,A
   \   000075   E5..         MOV     A,?V0 + 9
   \   000077   35..         ADDC    A,?V0 + 7
   \   000079   F9           MOV     R1,A
   \   00007A   C3           CLR     C
   \   00007B   E8           MOV     A,R0
   \   00007C   9410         SUBB    A,#0x10
   \   00007E   E9           MOV     A,R1
   \   00007F   9400         SUBB    A,#0x0
   \   000081   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000083   65D0         XRL     A,PSW
   \   000085   33           RLC     A
   \   000086   5041         JNC     ??uncompress_addr_5
    434              memset(&ipaddr->u8[prefcount], 0, 16 - (prefcount + postcount));
   \   000088                ; Setup parameters for call to function memset
   \   000088   85....       MOV     ?V0 + 6,?V0 + 0
   \   00008B   75..00       MOV     ?V0 + 7,#0x0
   \   00008E   7410         MOV     A,#0x10
   \   000090   C3           CLR     C
   \   000091   95..         SUBB    A,?V0 + 6
   \   000093   F8           MOV     R0,A
   \   000094   7400         MOV     A,#0x0
   \   000096   95..         SUBB    A,?V0 + 7
   \   000098   F9           MOV     R1,A
   \   000099   85....       MOV     ?V0 + 6,?V0 + 1
   \   00009C   75..00       MOV     ?V0 + 7,#0x0
   \   00009F   E8           MOV     A,R0
   \   0000A0   C3           CLR     C
   \   0000A1   95..         SUBB    A,?V0 + 6
   \   0000A3   F5..         MOV     ?V0 + 6,A
   \   0000A5   E9           MOV     A,R1
   \   0000A6   95..         SUBB    A,?V0 + 7
   \   0000A8   F5..         MOV     ?V0 + 7,A
   \   0000AA   78..         MOV     R0,#?V0 + 6
   \   0000AC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AF   7C00         MOV     R4,#0x0
   \   0000B1   7D00         MOV     R5,#0x0
   \   0000B3   85....       MOV     ?V0 + 6,?V0 + 0
   \   0000B6   75..00       MOV     ?V0 + 7,#0x0
   \   0000B9   EE           MOV     A,R6
   \   0000BA   25..         ADD     A,?V0 + 6
   \   0000BC   FA           MOV     R2,A
   \   0000BD   EF           MOV     A,R7
   \   0000BE   35..         ADDC    A,?V0 + 7
   \   0000C0   FB           MOV     R3,A
   \   0000C1   12....       LCALL   ??memset?relay
   \   0000C4   7402         MOV     A,#0x2
   \   0000C6   12....       LCALL   ?DEALLOC_XSTACK8
    435            }
    436            if(postcount > 0) {
   \                     ??uncompress_addr_5:
   \   0000C9   E5..         MOV     A,?V0 + 1
   \   0000CB   C3           CLR     C
   \   0000CC   9401         SUBB    A,#0x1
   \   0000CE   4077         JC      ??uncompress_addr_6
    437              memcpy(&ipaddr->u8[16 - postcount], hc06_ptr, postcount);
   \   0000D0                ; Setup parameters for call to function memcpy
   \   0000D0   85....       MOV     ?V0 + 6,?V0 + 1
   \   0000D3   75..00       MOV     ?V0 + 7,#0x0
   \   0000D6   78..         MOV     R0,#?V0 + 6
   \   0000D8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DB   90....       MOV     DPTR,#hc06_ptr
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   FC           MOV     R4,A
   \   0000E0   A3           INC     DPTR
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   FD           MOV     R5,A
   \   0000E3   E5..         MOV     A,?V0 + 1
   \   0000E5   A8..         MOV     R0,?V0 + 1
   \   0000E7   7900         MOV     R1,#0x0
   \   0000E9   C3           CLR     C
   \   0000EA   E4           CLR     A
   \   0000EB   98           SUBB    A,R0
   \   0000EC   F8           MOV     R0,A
   \   0000ED   E4           CLR     A
   \   0000EE   99           SUBB    A,R1
   \   0000EF   F9           MOV     R1,A
   \   0000F0   EE           MOV     A,R6
   \   0000F1   28           ADD     A,R0
   \   0000F2   F8           MOV     R0,A
   \   0000F3   EF           MOV     A,R7
   \   0000F4   39           ADDC    A,R1
   \   0000F5   F9           MOV     R1,A
   \   0000F6   E8           MOV     A,R0
   \   0000F7   2410         ADD     A,#0x10
   \   0000F9   FA           MOV     R2,A
   \   0000FA   E9           MOV     A,R1
   \   0000FB   3400         ADDC    A,#0x0
   \   0000FD   FB           MOV     R3,A
   \   0000FE   12....       LCALL   ??memcpy?relay
   \   000101   7402         MOV     A,#0x2
   \   000103   12....       LCALL   ?DEALLOC_XSTACK8
    438              if(postcount == 2 && prefcount < 11) {
   \   000106   7402         MOV     A,#0x2
   \   000108   65..         XRL     A,?V0 + 1
   \   00010A   7021         JNZ     ??uncompress_addr_7
   \   00010C   E5..         MOV     A,?V0 + 0
   \   00010E   C3           CLR     C
   \   00010F   940B         SUBB    A,#0xb
   \   000111   501A         JNC     ??uncompress_addr_7
    439                /* 16 bits uncompression => 0000:00ff:fe00:XXXX */
    440                ipaddr->u8[11] = 0xff;
   \   000113   EE           MOV     A,R6
   \   000114   240B         ADD     A,#0xb
   \   000116   F582         MOV     DPL,A
   \   000118   EF           MOV     A,R7
   \   000119   3400         ADDC    A,#0x0
   \   00011B   F583         MOV     DPH,A
   \   00011D   74FF         MOV     A,#-0x1
   \   00011F   F0           MOVX    @DPTR,A
    441                ipaddr->u8[12] = 0xfe;
   \   000120   EE           MOV     A,R6
   \   000121   240C         ADD     A,#0xc
   \   000123   F582         MOV     DPL,A
   \   000125   EF           MOV     A,R7
   \   000126   3400         ADDC    A,#0x0
   \   000128   F583         MOV     DPH,A
   \   00012A   74FE         MOV     A,#-0x2
   \   00012C   F0           MOVX    @DPTR,A
    442              }
    443              hc06_ptr += postcount;
   \                     ??uncompress_addr_7:
   \   00012D   E5..         MOV     A,?V0 + 1
   \   00012F   A8..         MOV     R0,?V0 + 1
   \   000131   7900         MOV     R1,#0x0
   \   000133   90....       MOV     DPTR,#hc06_ptr
   \   000136   E0           MOVX    A,@DPTR
   \   000137   28           ADD     A,R0
   \   000138   F8           MOV     R0,A
   \   000139   A3           INC     DPTR
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   39           ADDC    A,R1
   \   00013C   F9           MOV     R1,A
   \   00013D   90....       MOV     DPTR,#hc06_ptr
   \   000140   E8           MOV     A,R0
   \   000141   F0           MOVX    @DPTR,A
   \   000142   A3           INC     DPTR
   \   000143   E9           MOV     A,R1
   \   000144   F0           MOVX    @DPTR,A
   \   000145   8012         SJMP    ??uncompress_addr_8
    444            } else if (prefcount > 0) {
   \                     ??uncompress_addr_6:
   \   000147   E5..         MOV     A,?V0 + 0
   \   000149   C3           CLR     C
   \   00014A   9401         SUBB    A,#0x1
   \   00014C   400B         JC      ??uncompress_addr_8
    445              /* no IID based configuration if no prefix and no data => unspec */
    446              uip_ds6_set_addr_iid(ipaddr, lladdr);
   \   00014E                ; Setup parameters for call to function uip_ds6_set_addr_iid
   \   00014E   AC..         MOV     R4,?V0 + 10
   \   000150   AD..         MOV     R5,?V0 + 11
   \   000152   EE           MOV     A,R6
   \   000153   FA           MOV     R2,A
   \   000154   EF           MOV     A,R7
   \   000155   FB           MOV     R3,A
   \   000156   12....       LCALL   ??uip_ds6_set_addr_iid?relay
    447            }
    448          
    449            PRINT6ADDR(ipaddr);
    450            PRINTF("\n");
    451          }
   \                     ??uncompress_addr_8:
   \   000159   7F0C         MOV     R7,#0xc
   \   00015B   02....       LJMP    ?BANKED_LEAVE_XDATA
    452          
    453          /*--------------------------------------------------------------------*/
    454          /**
    455           * \brief Compress IP/UDP header
    456           *
    457           * This function is called by the 6lowpan code to create a compressed
    458           * 6lowpan packet in the packetbuf buffer from a full IPv6 packet in the
    459           * uip_buf buffer.
    460           *
    461           *
    462           * HC-06 (draft-ietf-6lowpan-hc, version 6)\n
    463           * http://tools.ietf.org/html/draft-ietf-6lowpan-hc-06
    464           *
    465           * \note We do not support ISA100_UDP header compression
    466           *
    467           * For LOWPAN_UDP compression, we either compress both ports or none.
    468           * General format with LOWPAN_UDP compression is
    469           * \verbatim
    470           *                      1                   2                   3
    471           *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    472           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    473           * |0|1|1|TF |N|HLI|C|S|SAM|M|D|DAM| SCI   | DCI   | comp. IPv6 hdr|
    474           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    475           * | compressed IPv6 fields .....                                  |
    476           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    477           * | LOWPAN_UDP    | non compressed UDP fields ...                 |
    478           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    479           * | L4 data ...                                                   |
    480           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    481           * \endverbatim
    482           * \note The context number 00 is reserved for the link local prefix.
    483           * For unicast addresses, if we cannot compress the prefix, we neither
    484           * compress the IID.
    485           * \param rime_destaddr L2 destination address, needed to compress IP
    486           * dest
    487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    488          static void
    489          compress_hdr_hc06(rimeaddr_t *rime_destaddr)
   \                     compress_hdr_hc06:
    490          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    491            uint8_t tmp, iphc0, iphc1;
    492          #if DEBUG
    493            { uint16_t ndx;
    494              PRINTF("before compression (%d): ", UIP_IP_BUF->len[1]);
    495              for(ndx = 0; ndx < UIP_IP_BUF->len[1] + 40; ndx++) {
    496                uint8_t data = ((uint8_t *) (UIP_IP_BUF))[ndx];
    497                PRINTF("%02x", data);
    498              }
    499              PRINTF("\n");
    500            }
    501          #endif
    502          
    503            hc06_ptr = rime_ptr + 2;
   \   000009   90....       MOV     DPTR,#rime_ptr
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   2402         ADD     A,#0x2
   \   00000F   F8           MOV     R0,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   3400         ADDC    A,#0x0
   \   000014   F9           MOV     R1,A
   \   000015   90....       MOV     DPTR,#hc06_ptr
   \   000018   E8           MOV     A,R0
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   E9           MOV     A,R1
   \   00001C   F0           MOVX    @DPTR,A
    504            /*
    505             * As we copy some bit-length fields, in the IPHC encoding bytes,
    506             * we sometimes use |=
    507             * If the field is 0, and the current bit value in memory is 1,
    508             * this does not work. We therefore reset the IPHC encoding here
    509             */
    510          
    511            iphc0 = SICSLOWPAN_DISPATCH_IPHC;
   \   00001D   75..60       MOV     ?V0 + 1,#0x60
    512            iphc1 = 0;
   \   000020   75..00       MOV     ?V0 + 0,#0x0
    513            RIME_IPHC_BUF[2] = 0; /* might not be used - but needs to be cleared */
   \   000023   90....       MOV     DPTR,#rime_hdr_len
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F8           MOV     R0,A
   \   000028   7900         MOV     R1,#0x0
   \   00002A   90....       MOV     DPTR,#rime_ptr
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   28           ADD     A,R0
   \   00002F   FA           MOV     R2,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   39           ADDC    A,R1
   \   000033   8A82         MOV     DPL,R2
   \   000035   F583         MOV     DPH,A
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   7400         MOV     A,#0x0
   \   00003B   F0           MOVX    @DPTR,A
    514          
    515            /*
    516             * Address handling needs to be made first since it might
    517             * cause an extra byte with [ SCI | DCI ]
    518             *
    519             */
    520          
    521          
    522            /* check if dest context exists (for allocating third byte) */
    523            /* TODO: fix this so that it remembers the looked up values for
    524               avoiding two lookups - or set the lookup values immediately */
    525            if(addr_context_lookup_by_prefix(&UIP_IP_BUF->destipaddr) != NULL ||
    526               addr_context_lookup_by_prefix(&UIP_IP_BUF->srcipaddr) != NULL) {
   \   00003C                ; Setup parameters for call to function addr_context_lookup_by_prefix
   \   00003C   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   00003E   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000040   12....       LCALL   ??addr_context_lookup_by_prefix?relay
   \   000043   8A..         MOV     ?V0 + 2,R2
   \   000045   8B..         MOV     ?V0 + 3,R3
   \   000047   E5..         MOV     A,?V0 + 2
   \   000049   45..         ORL     A,?V0 + 3
   \   00004B   7011         JNZ     ??compress_hdr_hc06_0
   \   00004D                ; Setup parameters for call to function addr_context_lookup_by_prefix
   \   00004D   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   00004F   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   000051   12....       LCALL   ??addr_context_lookup_by_prefix?relay
   \   000054   8A..         MOV     ?V0 + 2,R2
   \   000056   8B..         MOV     ?V0 + 3,R3
   \   000058   E5..         MOV     A,?V0 + 2
   \   00005A   45..         ORL     A,?V0 + 3
   \   00005C   601B         JZ      ??compress_hdr_hc06_1
    527              /* set context flag and increase hc06_ptr */
    528              PRINTF("IPHC: compressing dest or src ipaddr - setting CID\n");
    529              iphc1 |= SICSLOWPAN_IPHC_CID;
   \                     ??compress_hdr_hc06_0:
   \   00005E   D3           SETB    C
   \   00005F   E5..         MOV     A,?V0 + 0
   \   000061   92E7         MOV     0xE0 /* A   */.7,C
   \   000063   F5..         MOV     ?V0 + 0,A
    530              hc06_ptr++;
   \   000065   90....       MOV     DPTR,#hc06_ptr
   \   000068   E0           MOVX    A,@DPTR
   \   000069   2401         ADD     A,#0x1
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   3400         ADDC    A,#0x0
   \   000070   F9           MOV     R1,A
   \   000071   90....       MOV     DPTR,#hc06_ptr
   \   000074   E8           MOV     A,R0
   \   000075   F0           MOVX    @DPTR,A
   \   000076   A3           INC     DPTR
   \   000077   E9           MOV     A,R1
   \   000078   F0           MOVX    @DPTR,A
    531            }
    532          
    533            /*
    534             * Traffic class, flow label
    535             * If flow label is 0, compress it. If traffic class is 0, compress it
    536             * We have to process both in the same time as the offset of traffic class
    537             * depends on the presence of version and flow label
    538             */
    539           
    540            /* hc06 format of tc is ECN | DSCP , original is DSCP | ECN */
    541            tmp = (UIP_IP_BUF->vtc << 4) | (UIP_IP_BUF->tcflow >> 4);
   \                     ??compress_hdr_hc06_1:
   \   000079   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   C4           SWAP    A
   \   00007E   540F         ANL     A,#0xf
   \   000080   F8           MOV     R0,A
   \   000081   90....       MOV     DPTR,#uip_aligned_buf
   \   000084   E0           MOVX    A,@DPTR
   \   000085   C4           SWAP    A
   \   000086   54F0         ANL     A,#0xf0
   \   000088   48           ORL     A,R0
   \   000089   F5..         MOV     ?V0 + 2,A
    542            tmp = ((tmp & 0x03) << 6) | (tmp >> 2);
   \   00008B   E5..         MOV     A,?V0 + 2
   \   00008D   13           RRC     A
   \   00008E   13           RRC     A
   \   00008F   543F         ANL     A,#0x3f
   \   000091   F8           MOV     R0,A
   \   000092   E5..         MOV     A,?V0 + 2
   \   000094   C4           SWAP    A
   \   000095   33           RLC     A
   \   000096   33           RLC     A
   \   000097   54C0         ANL     A,#0xc0
   \   000099   48           ORL     A,R0
   \   00009A   F5..         MOV     ?V0 + 2,A
    543            
    544            if(((UIP_IP_BUF->tcflow & 0x0F) == 0) &&
    545               (UIP_IP_BUF->flow == 0)) {
   \   00009C   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   540F         ANL     A,#0xf
   \   0000A2   7054         JNZ     ??compress_hdr_hc06_2
   \   0000A4   90....       MOV     DPTR,#uip_aligned_buf + 2
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   F8           MOV     R0,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F9           MOV     R1,A
   \   0000AC   E8           MOV     A,R0
   \   0000AD   49           ORL     A,R1
   \   0000AE   7048         JNZ     ??compress_hdr_hc06_2
    546              /* flow label can be compressed */
    547              iphc0 |= SICSLOWPAN_IPHC_FL_C;
   \   0000B0   D3           SETB    C
   \   0000B1   E5..         MOV     A,?V0 + 1
   \   0000B3   92E4         MOV     0xE0 /* A   */.4,C
   \   0000B5   F5..         MOV     ?V0 + 1,A
    548              if(((UIP_IP_BUF->vtc & 0x0F) == 0) &&
    549                 ((UIP_IP_BUF->tcflow & 0xF0) == 0)) {
   \   0000B7   90....       MOV     DPTR,#uip_aligned_buf
   \   0000BA   E0           MOVX    A,@DPTR
   \   0000BB   540F         ANL     A,#0xf
   \   0000BD   7012         JNZ     ??compress_hdr_hc06_3
   \   0000BF   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   54F0         ANL     A,#0xf0
   \   0000C5   700A         JNZ     ??compress_hdr_hc06_3
    550                /* compress (elide) all */
    551                iphc0 |= SICSLOWPAN_IPHC_TC_C;
   \   0000C7   D3           SETB    C
   \   0000C8   E5..         MOV     A,?V0 + 1
   \   0000CA   92E3         MOV     0xE0 /* A   */.3,C
   \   0000CC   F5..         MOV     ?V0 + 1,A
   \   0000CE   02....       LJMP    ??compress_hdr_hc06_4 & 0xFFFF
    552              } else {
    553                /* compress only the flow label */
    554               *hc06_ptr = tmp;
   \                     ??compress_hdr_hc06_3:
   \   0000D1   E5..         MOV     A,?V0 + 2
   \   0000D3   90....       MOV     DPTR,#hc06_ptr
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   F8           MOV     R0,A
   \   0000D8   A3           INC     DPTR
   \   0000D9   E0           MOVX    A,@DPTR
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   8882         MOV     DPL,R0
   \   0000DE   E5..         MOV     A,?V0 + 2
   \   0000E0   F0           MOVX    @DPTR,A
    555                hc06_ptr += 1;
   \   0000E1   90....       MOV     DPTR,#hc06_ptr
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   2401         ADD     A,#0x1
   \   0000E7   F8           MOV     R0,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   3400         ADDC    A,#0x0
   \   0000EC   F9           MOV     R1,A
   \   0000ED   90....       MOV     DPTR,#hc06_ptr
   \   0000F0   E8           MOV     A,R0
   \   0000F1   F0           MOVX    @DPTR,A
   \   0000F2   A3           INC     DPTR
   \   0000F3   E9           MOV     A,R1
   \   0000F4   F0           MOVX    @DPTR,A
   \   0000F5   02....       LJMP    ??compress_hdr_hc06_4 & 0xFFFF
    556              }
    557            } else {
    558              /* Flow label cannot be compressed */
    559              if(((UIP_IP_BUF->vtc & 0x0F) == 0) &&
    560                 ((UIP_IP_BUF->tcflow & 0xF0) == 0)) {
   \                     ??compress_hdr_hc06_2:
   \   0000F8   90....       MOV     DPTR,#uip_aligned_buf
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   540F         ANL     A,#0xf
   \   0000FE   7064         JNZ     ??compress_hdr_hc06_5
   \   000100   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   000103   E0           MOVX    A,@DPTR
   \   000104   54F0         ANL     A,#0xf0
   \   000106   705C         JNZ     ??compress_hdr_hc06_5
    561                /* compress only traffic class */
    562                iphc0 |= SICSLOWPAN_IPHC_TC_C;
   \   000108   D3           SETB    C
   \   000109   E5..         MOV     A,?V0 + 1
   \   00010B   92E3         MOV     0xE0 /* A   */.3,C
   \   00010D   F5..         MOV     ?V0 + 1,A
    563                *hc06_ptr = (tmp & 0xc0) |
    564                  (UIP_IP_BUF->tcflow & 0x0F);
   \   00010F   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   000112   E0           MOVX    A,@DPTR
   \   000113   540F         ANL     A,#0xf
   \   000115   F8           MOV     R0,A
   \   000116   74C0         MOV     A,#-0x40
   \   000118   55..         ANL     A,?V0 + 2
   \   00011A   48           ORL     A,R0
   \   00011B   C0E0         PUSH    A
   \   00011D   90....       MOV     DPTR,#hc06_ptr
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F8           MOV     R0,A
   \   000122   A3           INC     DPTR
   \   000123   E0           MOVX    A,@DPTR
   \   000124   F583         MOV     DPH,A
   \   000126   8882         MOV     DPL,R0
   \   000128   D0E0         POP     A
   \   00012A   F0           MOVX    @DPTR,A
    565                memcpy(hc06_ptr + 1, &UIP_IP_BUF->flow, 2);
   \   00012B                ; Setup parameters for call to function memcpy
   \   00012B   75..02       MOV     ?V0 + 2,#0x2
   \   00012E   75..00       MOV     ?V0 + 3,#0x0
   \   000131   78..         MOV     R0,#?V0 + 2
   \   000133   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000136   7C..         MOV     R4,#(uip_aligned_buf + 2) & 0xff
   \   000138   7D..         MOV     R5,#((uip_aligned_buf + 2) >> 8) & 0xff
   \   00013A   90....       MOV     DPTR,#hc06_ptr
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   2401         ADD     A,#0x1
   \   000140   FA           MOV     R2,A
   \   000141   A3           INC     DPTR
   \   000142   E0           MOVX    A,@DPTR
   \   000143   3400         ADDC    A,#0x0
   \   000145   FB           MOV     R3,A
   \   000146   12....       LCALL   ??memcpy?relay
   \   000149   7402         MOV     A,#0x2
   \   00014B   12....       LCALL   ?DEALLOC_XSTACK8
    566                hc06_ptr += 3;
   \   00014E   90....       MOV     DPTR,#hc06_ptr
   \   000151   E0           MOVX    A,@DPTR
   \   000152   2403         ADD     A,#0x3
   \   000154   F8           MOV     R0,A
   \   000155   A3           INC     DPTR
   \   000156   E0           MOVX    A,@DPTR
   \   000157   3400         ADDC    A,#0x0
   \   000159   F9           MOV     R1,A
   \   00015A   90....       MOV     DPTR,#hc06_ptr
   \   00015D   E8           MOV     A,R0
   \   00015E   F0           MOVX    @DPTR,A
   \   00015F   A3           INC     DPTR
   \   000160   E9           MOV     A,R1
   \   000161   F0           MOVX    @DPTR,A
   \   000162   8043         SJMP    ??compress_hdr_hc06_4
    567              } else {
    568                /* compress nothing */
    569                memcpy(hc06_ptr, &UIP_IP_BUF->vtc, 4);
   \                     ??compress_hdr_hc06_5:
   \   000164                ; Setup parameters for call to function memcpy
   \   000164   75..04       MOV     ?V0 + 4,#0x4
   \   000167   75..00       MOV     ?V0 + 5,#0x0
   \   00016A   78..         MOV     R0,#?V0 + 4
   \   00016C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016F   7C..         MOV     R4,#uip_aligned_buf & 0xff
   \   000171   7D..         MOV     R5,#(uip_aligned_buf >> 8) & 0xff
   \   000173   90....       MOV     DPTR,#hc06_ptr
   \   000176   E0           MOVX    A,@DPTR
   \   000177   FA           MOV     R2,A
   \   000178   A3           INC     DPTR
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   FB           MOV     R3,A
   \   00017B   12....       LCALL   ??memcpy?relay
   \   00017E   7402         MOV     A,#0x2
   \   000180   12....       LCALL   ?DEALLOC_XSTACK8
    570                /* but replace the top byte with the new ECN | DSCP format*/
    571                *hc06_ptr = tmp;
   \   000183   E5..         MOV     A,?V0 + 2
   \   000185   90....       MOV     DPTR,#hc06_ptr
   \   000188   E0           MOVX    A,@DPTR
   \   000189   F8           MOV     R0,A
   \   00018A   A3           INC     DPTR
   \   00018B   E0           MOVX    A,@DPTR
   \   00018C   F583         MOV     DPH,A
   \   00018E   8882         MOV     DPL,R0
   \   000190   E5..         MOV     A,?V0 + 2
   \   000192   F0           MOVX    @DPTR,A
    572                hc06_ptr += 4;
   \   000193   90....       MOV     DPTR,#hc06_ptr
   \   000196   E0           MOVX    A,@DPTR
   \   000197   2404         ADD     A,#0x4
   \   000199   F8           MOV     R0,A
   \   00019A   A3           INC     DPTR
   \   00019B   E0           MOVX    A,@DPTR
   \   00019C   3400         ADDC    A,#0x0
   \   00019E   F9           MOV     R1,A
   \   00019F   90....       MOV     DPTR,#hc06_ptr
   \   0001A2   E8           MOV     A,R0
   \   0001A3   F0           MOVX    @DPTR,A
   \   0001A4   A3           INC     DPTR
   \   0001A5   E9           MOV     A,R1
   \   0001A6   F0           MOVX    @DPTR,A
    573             }
    574            }
    575          
    576            /* Note that the payload length is always compressed */
    577          
    578            /* Next header. We compress it if UDP */
    579          #if UIP_CONF_UDP || UIP_CONF_ROUTER
    580            if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
   \                     ??compress_hdr_hc06_4:
   \   0001A7   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   0001AA   E0           MOVX    A,@DPTR
   \   0001AB   6411         XRL     A,#0x11
   \   0001AD   7007         JNZ     ??compress_hdr_hc06_6
    581              iphc0 |= SICSLOWPAN_IPHC_NH_C;
   \   0001AF   D3           SETB    C
   \   0001B0   E5..         MOV     A,?V0 + 1
   \   0001B2   92E2         MOV     0xE0 /* A   */.2,C
   \   0001B4   F5..         MOV     ?V0 + 1,A
    582            }
    583          #endif /*UIP_CONF_UDP*/
    584          #ifdef SICSLOWPAN_NH_COMPRESSOR 
    585            if(SICSLOWPAN_NH_COMPRESSOR.is_compressable(UIP_IP_BUF->proto)) {
    586              iphc0 |= SICSLOWPAN_IPHC_NH_C;
    587            }
    588          #endif
    589            if ((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {
   \                     ??compress_hdr_hc06_6:
   \   0001B6   E5..         MOV     A,?V0 + 1
   \   0001B8   A2E2         MOV     C,0xE0 /* A   */.2
   \   0001BA   4028         JC      ??compress_hdr_hc06_7
    590              *hc06_ptr = UIP_IP_BUF->proto;
   \   0001BC   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   0001BF   E0           MOVX    A,@DPTR
   \   0001C0   C0E0         PUSH    A
   \   0001C2   90....       MOV     DPTR,#hc06_ptr
   \   0001C5   E0           MOVX    A,@DPTR
   \   0001C6   F8           MOV     R0,A
   \   0001C7   A3           INC     DPTR
   \   0001C8   E0           MOVX    A,@DPTR
   \   0001C9   F583         MOV     DPH,A
   \   0001CB   8882         MOV     DPL,R0
   \   0001CD   D0E0         POP     A
   \   0001CF   F0           MOVX    @DPTR,A
    591              hc06_ptr += 1;
   \   0001D0   90....       MOV     DPTR,#hc06_ptr
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   2401         ADD     A,#0x1
   \   0001D6   F8           MOV     R0,A
   \   0001D7   A3           INC     DPTR
   \   0001D8   E0           MOVX    A,@DPTR
   \   0001D9   3400         ADDC    A,#0x0
   \   0001DB   F9           MOV     R1,A
   \   0001DC   90....       MOV     DPTR,#hc06_ptr
   \   0001DF   E8           MOV     A,R0
   \   0001E0   F0           MOVX    @DPTR,A
   \   0001E1   A3           INC     DPTR
   \   0001E2   E9           MOV     A,R1
   \   0001E3   F0           MOVX    @DPTR,A
    592            }
    593          
    594            /*
    595             * Hop limit
    596             * if 1: compress, encoding is 01
    597             * if 64: compress, encoding is 10
    598             * if 255: compress, encoding is 11
    599             * else do not compress
    600             */
    601            switch(UIP_IP_BUF->ttl) {
   \                     ??compress_hdr_hc06_7:
   \   0001E4   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   0001E7   E0           MOVX    A,@DPTR
   \   0001E8   14           DEC     A
   \   0001E9   600A         JZ      ??compress_hdr_hc06_8
   \   0001EB   24C1         ADD     A,#-0x3f
   \   0001ED   600F         JZ      ??compress_hdr_hc06_9
   \   0001EF   2441         ADD     A,#0x41
   \   0001F1   6014         JZ      ??compress_hdr_hc06_10
   \   0001F3   8017         SJMP    ??compress_hdr_hc06_11
    602              case 1:
    603                iphc0 |= SICSLOWPAN_IPHC_TTL_1;
   \                     ??compress_hdr_hc06_8:
   \   0001F5   D3           SETB    C
   \   0001F6   E5..         MOV     A,?V0 + 1
   \   0001F8   92E0         MOV     0xE0 /* A   */.0,C
   \   0001FA   F5..         MOV     ?V0 + 1,A
    604                break;
   \   0001FC   8036         SJMP    ??compress_hdr_hc06_12
    605              case 64:
    606                iphc0 |= SICSLOWPAN_IPHC_TTL_64;
   \                     ??compress_hdr_hc06_9:
   \   0001FE   D3           SETB    C
   \   0001FF   E5..         MOV     A,?V0 + 1
   \   000201   92E1         MOV     0xE0 /* A   */.1,C
   \   000203   F5..         MOV     ?V0 + 1,A
    607                break;
   \   000205   802D         SJMP    ??compress_hdr_hc06_12
    608              case 255:
    609                iphc0 |= SICSLOWPAN_IPHC_TTL_255;
   \                     ??compress_hdr_hc06_10:
   \   000207   43..03       ORL     ?V0 + 1,#0x3
    610                break;
   \   00020A   8028         SJMP    ??compress_hdr_hc06_12
    611              default:
    612                *hc06_ptr = UIP_IP_BUF->ttl;
   \                     ??compress_hdr_hc06_11:
   \   00020C   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   00020F   E0           MOVX    A,@DPTR
   \   000210   C0E0         PUSH    A
   \   000212   90....       MOV     DPTR,#hc06_ptr
   \   000215   E0           MOVX    A,@DPTR
   \   000216   F8           MOV     R0,A
   \   000217   A3           INC     DPTR
   \   000218   E0           MOVX    A,@DPTR
   \   000219   F583         MOV     DPH,A
   \   00021B   8882         MOV     DPL,R0
   \   00021D   D0E0         POP     A
   \   00021F   F0           MOVX    @DPTR,A
    613                hc06_ptr += 1;
   \   000220   90....       MOV     DPTR,#hc06_ptr
   \   000223   E0           MOVX    A,@DPTR
   \   000224   2401         ADD     A,#0x1
   \   000226   F8           MOV     R0,A
   \   000227   A3           INC     DPTR
   \   000228   E0           MOVX    A,@DPTR
   \   000229   3400         ADDC    A,#0x0
   \   00022B   F9           MOV     R1,A
   \   00022C   90....       MOV     DPTR,#hc06_ptr
   \   00022F   E8           MOV     A,R0
   \   000230   F0           MOVX    @DPTR,A
   \   000231   A3           INC     DPTR
   \   000232   E9           MOV     A,R1
   \   000233   F0           MOVX    @DPTR,A
    614                break;
    615            }
    616          
    617            /* source address - cannot be multicast */
    618            if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
   \                     ??compress_hdr_hc06_12:
   \   000234   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   000237   E0           MOVX    A,@DPTR
   \   000238   F8           MOV     R0,A
   \   000239   A3           INC     DPTR
   \   00023A   E0           MOVX    A,@DPTR
   \   00023B   F9           MOV     R1,A
   \   00023C   E8           MOV     A,R0
   \   00023D   49           ORL     A,R1
   \   00023E   705E         JNZ     ??compress_hdr_hc06_13
   \   000240   90....       MOV     DPTR,#uip_aligned_buf + 10
   \   000243   E0           MOVX    A,@DPTR
   \   000244   F8           MOV     R0,A
   \   000245   A3           INC     DPTR
   \   000246   E0           MOVX    A,@DPTR
   \   000247   F9           MOV     R1,A
   \   000248   E8           MOV     A,R0
   \   000249   49           ORL     A,R1
   \   00024A   7052         JNZ     ??compress_hdr_hc06_13
   \   00024C   90....       MOV     DPTR,#uip_aligned_buf + 12
   \   00024F   E0           MOVX    A,@DPTR
   \   000250   F8           MOV     R0,A
   \   000251   A3           INC     DPTR
   \   000252   E0           MOVX    A,@DPTR
   \   000253   F9           MOV     R1,A
   \   000254   E8           MOV     A,R0
   \   000255   49           ORL     A,R1
   \   000256   7046         JNZ     ??compress_hdr_hc06_13
   \   000258   90....       MOV     DPTR,#uip_aligned_buf + 14
   \   00025B   E0           MOVX    A,@DPTR
   \   00025C   F8           MOV     R0,A
   \   00025D   A3           INC     DPTR
   \   00025E   E0           MOVX    A,@DPTR
   \   00025F   F9           MOV     R1,A
   \   000260   E8           MOV     A,R0
   \   000261   49           ORL     A,R1
   \   000262   703A         JNZ     ??compress_hdr_hc06_13
   \   000264   90....       MOV     DPTR,#uip_aligned_buf + 16
   \   000267   E0           MOVX    A,@DPTR
   \   000268   F8           MOV     R0,A
   \   000269   A3           INC     DPTR
   \   00026A   E0           MOVX    A,@DPTR
   \   00026B   F9           MOV     R1,A
   \   00026C   E8           MOV     A,R0
   \   00026D   49           ORL     A,R1
   \   00026E   702E         JNZ     ??compress_hdr_hc06_13
   \   000270   90....       MOV     DPTR,#uip_aligned_buf + 18
   \   000273   E0           MOVX    A,@DPTR
   \   000274   F8           MOV     R0,A
   \   000275   A3           INC     DPTR
   \   000276   E0           MOVX    A,@DPTR
   \   000277   F9           MOV     R1,A
   \   000278   E8           MOV     A,R0
   \   000279   49           ORL     A,R1
   \   00027A   7022         JNZ     ??compress_hdr_hc06_13
   \   00027C   90....       MOV     DPTR,#uip_aligned_buf + 20
   \   00027F   E0           MOVX    A,@DPTR
   \   000280   F8           MOV     R0,A
   \   000281   A3           INC     DPTR
   \   000282   E0           MOVX    A,@DPTR
   \   000283   F9           MOV     R1,A
   \   000284   E8           MOV     A,R0
   \   000285   49           ORL     A,R1
   \   000286   7016         JNZ     ??compress_hdr_hc06_13
   \   000288   90....       MOV     DPTR,#uip_aligned_buf + 22
   \   00028B   E0           MOVX    A,@DPTR
   \   00028C   F8           MOV     R0,A
   \   00028D   A3           INC     DPTR
   \   00028E   E0           MOVX    A,@DPTR
   \   00028F   F9           MOV     R1,A
   \   000290   E8           MOV     A,R0
   \   000291   49           ORL     A,R1
   \   000292   700A         JNZ     ??compress_hdr_hc06_13
    619              PRINTF("IPHC: compressing unspecified - setting SAC\n");
    620              iphc1 |= SICSLOWPAN_IPHC_SAC;
   \   000294   D3           SETB    C
   \   000295   E5..         MOV     A,?V0 + 0
   \   000297   92E6         MOV     0xE0 /* A   */.6,C
   \   000299   F5..         MOV     ?V0 + 0,A
    621              iphc1 |= SICSLOWPAN_IPHC_SAM_00;
   \   00029B   02....       LJMP    ??compress_hdr_hc06_14 & 0xFFFF
    622            } else if((context = addr_context_lookup_by_prefix(&UIP_IP_BUF->srcipaddr))
    623               != NULL) {
   \                     ??compress_hdr_hc06_13:
   \   00029E                ; Setup parameters for call to function addr_context_lookup_by_prefix
   \   00029E   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   0002A0   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   0002A2   12....       LCALL   ??addr_context_lookup_by_prefix?relay
   \   0002A5   8A..         MOV     ?V0 + 2,R2
   \   0002A7   8B..         MOV     ?V0 + 3,R3
   \   0002A9   A8..         MOV     R0,?V0 + 2
   \   0002AB   A9..         MOV     R1,?V0 + 3
   \   0002AD   90....       MOV     DPTR,#context
   \   0002B0   E8           MOV     A,R0
   \   0002B1   F0           MOVX    @DPTR,A
   \   0002B2   A3           INC     DPTR
   \   0002B3   E9           MOV     A,R1
   \   0002B4   F0           MOVX    @DPTR,A
   \   0002B5   E8           MOV     A,R0
   \   0002B6   49           ORL     A,R1
   \   0002B7   603F         JZ      ??compress_hdr_hc06_15
    624              /* elide the prefix - indicate by CID and set context + SAC */
    625              PRINTF("IPHC: compressing src with context - setting CID & SAC ctx: %d\n",
    626          	   context->number);
    627              iphc1 |= SICSLOWPAN_IPHC_CID | SICSLOWPAN_IPHC_SAC;
   \   0002B9   43..C0       ORL     ?V0 + 0,#0xc0
    628              RIME_IPHC_BUF[2] |= context->number << 4;
   \   0002BC   90....       MOV     DPTR,#context
   \   0002BF   E0           MOVX    A,@DPTR
   \   0002C0   F8           MOV     R0,A
   \   0002C1   A3           INC     DPTR
   \   0002C2   E0           MOVX    A,@DPTR
   \   0002C3   F583         MOV     DPH,A
   \   0002C5   8882         MOV     DPL,R0
   \   0002C7   A3           INC     DPTR
   \   0002C8   E0           MOVX    A,@DPTR
   \   0002C9   C4           SWAP    A
   \   0002CA   54F0         ANL     A,#0xf0
   \   0002CC   FB           MOV     R3,A
   \   0002CD   90....       MOV     DPTR,#rime_hdr_len
   \   0002D0   E0           MOVX    A,@DPTR
   \   0002D1   F8           MOV     R0,A
   \   0002D2   7900         MOV     R1,#0x0
   \   0002D4   90....       MOV     DPTR,#rime_ptr
   \   0002D7   E0           MOVX    A,@DPTR
   \   0002D8   28           ADD     A,R0
   \   0002D9   FA           MOV     R2,A
   \   0002DA   A3           INC     DPTR
   \   0002DB   E0           MOVX    A,@DPTR
   \   0002DC   39           ADDC    A,R1
   \   0002DD   8A82         MOV     DPL,R2
   \   0002DF   F583         MOV     DPH,A
   \   0002E1   A3           INC     DPTR
   \   0002E2   A3           INC     DPTR
   \   0002E3   E0           MOVX    A,@DPTR
   \   0002E4   4B           ORL     A,R3
   \   0002E5   F0           MOVX    @DPTR,A
    629              /* compession compare with this nodes address (source) */
    630          
    631              iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_SAM_BIT,
    632                                        &UIP_IP_BUF->srcipaddr, &uip_lladdr);
   \   0002E6                ; Setup parameters for call to function compress_addr_64
   \   0002E6   7C..         MOV     R4,#uip_lladdr & 0xff
   \   0002E8   7D..         MOV     R5,#(uip_lladdr >> 8) & 0xff
   \   0002EA   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   0002EC   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   0002EE   7904         MOV     R1,#0x4
   \   0002F0   12....       LCALL   ??compress_addr_64?relay
   \   0002F3   E9           MOV     A,R1
   \   0002F4   42..         ORL     ?V0 + 0,A
   \   0002F6   8079         SJMP    ??compress_hdr_hc06_14
    633              /* No context found for this address */
    634            } else if(uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr) &&
    635          	    UIP_IP_BUF->destipaddr.u16[1] == 0 &&
    636          	    UIP_IP_BUF->destipaddr.u16[2] == 0 &&
    637          	    UIP_IP_BUF->destipaddr.u16[3] == 0) {
   \                     ??compress_hdr_hc06_15:
   \   0002F8   90....       MOV     DPTR,#uip_aligned_buf + 8
   \   0002FB   E0           MOVX    A,@DPTR
   \   0002FC   64FE         XRL     A,#0xfe
   \   0002FE   703E         JNZ     ??compress_hdr_hc06_16
   \   000300   90....       MOV     DPTR,#uip_aligned_buf + 9
   \   000303   E0           MOVX    A,@DPTR
   \   000304   6480         XRL     A,#0x80
   \   000306   7036         JNZ     ??compress_hdr_hc06_16
   \   000308   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   00030B   E0           MOVX    A,@DPTR
   \   00030C   F8           MOV     R0,A
   \   00030D   A3           INC     DPTR
   \   00030E   E0           MOVX    A,@DPTR
   \   00030F   F9           MOV     R1,A
   \   000310   E8           MOV     A,R0
   \   000311   49           ORL     A,R1
   \   000312   702A         JNZ     ??compress_hdr_hc06_16
   \   000314   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   000317   E0           MOVX    A,@DPTR
   \   000318   F8           MOV     R0,A
   \   000319   A3           INC     DPTR
   \   00031A   E0           MOVX    A,@DPTR
   \   00031B   F9           MOV     R1,A
   \   00031C   E8           MOV     A,R0
   \   00031D   49           ORL     A,R1
   \   00031E   701E         JNZ     ??compress_hdr_hc06_16
   \   000320   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   000323   E0           MOVX    A,@DPTR
   \   000324   F8           MOV     R0,A
   \   000325   A3           INC     DPTR
   \   000326   E0           MOVX    A,@DPTR
   \   000327   F9           MOV     R1,A
   \   000328   E8           MOV     A,R0
   \   000329   49           ORL     A,R1
   \   00032A   7012         JNZ     ??compress_hdr_hc06_16
    638              iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_SAM_BIT,
    639                                        &UIP_IP_BUF->srcipaddr, &uip_lladdr);
   \   00032C                ; Setup parameters for call to function compress_addr_64
   \   00032C   7C..         MOV     R4,#uip_lladdr & 0xff
   \   00032E   7D..         MOV     R5,#(uip_lladdr >> 8) & 0xff
   \   000330   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   000332   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   000334   7904         MOV     R1,#0x4
   \   000336   12....       LCALL   ??compress_addr_64?relay
   \   000339   E9           MOV     A,R1
   \   00033A   42..         ORL     ?V0 + 0,A
   \   00033C   8033         SJMP    ??compress_hdr_hc06_14
    640            } else {
    641              /* send the full address => SAC = 0, SAM = 00 */
    642              iphc1 |= SICSLOWPAN_IPHC_SAM_00; /* 128-bits */
    643              memcpy(hc06_ptr, &UIP_IP_BUF->srcipaddr.u16[0], 16);
   \                     ??compress_hdr_hc06_16:
   \   00033E                ; Setup parameters for call to function memcpy
   \   00033E   75..10       MOV     ?V0 + 2,#0x10
   \   000341   75..00       MOV     ?V0 + 3,#0x0
   \   000344   78..         MOV     R0,#?V0 + 2
   \   000346   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000349   7C..         MOV     R4,#(uip_aligned_buf + 8) & 0xff
   \   00034B   7D..         MOV     R5,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   00034D   90....       MOV     DPTR,#hc06_ptr
   \   000350   E0           MOVX    A,@DPTR
   \   000351   FA           MOV     R2,A
   \   000352   A3           INC     DPTR
   \   000353   E0           MOVX    A,@DPTR
   \   000354   FB           MOV     R3,A
   \   000355   12....       LCALL   ??memcpy?relay
   \   000358   7402         MOV     A,#0x2
   \   00035A   12....       LCALL   ?DEALLOC_XSTACK8
    644              hc06_ptr += 16;
   \   00035D   90....       MOV     DPTR,#hc06_ptr
   \   000360   E0           MOVX    A,@DPTR
   \   000361   2410         ADD     A,#0x10
   \   000363   F8           MOV     R0,A
   \   000364   A3           INC     DPTR
   \   000365   E0           MOVX    A,@DPTR
   \   000366   3400         ADDC    A,#0x0
   \   000368   F9           MOV     R1,A
   \   000369   90....       MOV     DPTR,#hc06_ptr
   \   00036C   E8           MOV     A,R0
   \   00036D   F0           MOVX    @DPTR,A
   \   00036E   A3           INC     DPTR
   \   00036F   E9           MOV     A,R1
   \   000370   F0           MOVX    @DPTR,A
    645            }
    646          
    647            /* dest address*/
    648            if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
   \                     ??compress_hdr_hc06_14:
   \   000371   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   000374   E0           MOVX    A,@DPTR
   \   000375   64FF         XRL     A,#0xff
   \   000377   6003         JZ      $+5
   \   000379   02....       LJMP    ??compress_hdr_hc06_17 & 0xFFFF
    649              /* Address is multicast, try to compress */
    650              iphc1 |= SICSLOWPAN_IPHC_M;
   \   00037C   D3           SETB    C
   \   00037D   E5..         MOV     A,?V0 + 0
   \   00037F   92E3         MOV     0xE0 /* A   */.3,C
   \   000381   F5..         MOV     ?V0 + 0,A
    651              if(sicslowpan_is_mcast_addr_compressable8(&UIP_IP_BUF->destipaddr)) {
   \   000383   90....       MOV     DPTR,#uip_aligned_buf + 25
   \   000386   E0           MOVX    A,@DPTR
   \   000387   6402         XRL     A,#0x2
   \   000389   707C         JNZ     ??compress_hdr_hc06_18
   \   00038B   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   00038E   E0           MOVX    A,@DPTR
   \   00038F   F8           MOV     R0,A
   \   000390   A3           INC     DPTR
   \   000391   E0           MOVX    A,@DPTR
   \   000392   F9           MOV     R1,A
   \   000393   E8           MOV     A,R0
   \   000394   49           ORL     A,R1
   \   000395   7070         JNZ     ??compress_hdr_hc06_18
   \   000397   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   00039A   E0           MOVX    A,@DPTR
   \   00039B   F8           MOV     R0,A
   \   00039C   A3           INC     DPTR
   \   00039D   E0           MOVX    A,@DPTR
   \   00039E   F9           MOV     R1,A
   \   00039F   E8           MOV     A,R0
   \   0003A0   49           ORL     A,R1
   \   0003A1   7064         JNZ     ??compress_hdr_hc06_18
   \   0003A3   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   0003A6   E0           MOVX    A,@DPTR
   \   0003A7   F8           MOV     R0,A
   \   0003A8   A3           INC     DPTR
   \   0003A9   E0           MOVX    A,@DPTR
   \   0003AA   F9           MOV     R1,A
   \   0003AB   E8           MOV     A,R0
   \   0003AC   49           ORL     A,R1
   \   0003AD   7058         JNZ     ??compress_hdr_hc06_18
   \   0003AF   90....       MOV     DPTR,#uip_aligned_buf + 32
   \   0003B2   E0           MOVX    A,@DPTR
   \   0003B3   F8           MOV     R0,A
   \   0003B4   A3           INC     DPTR
   \   0003B5   E0           MOVX    A,@DPTR
   \   0003B6   F9           MOV     R1,A
   \   0003B7   E8           MOV     A,R0
   \   0003B8   49           ORL     A,R1
   \   0003B9   704C         JNZ     ??compress_hdr_hc06_18
   \   0003BB   90....       MOV     DPTR,#uip_aligned_buf + 34
   \   0003BE   E0           MOVX    A,@DPTR
   \   0003BF   F8           MOV     R0,A
   \   0003C0   A3           INC     DPTR
   \   0003C1   E0           MOVX    A,@DPTR
   \   0003C2   F9           MOV     R1,A
   \   0003C3   E8           MOV     A,R0
   \   0003C4   49           ORL     A,R1
   \   0003C5   7040         JNZ     ??compress_hdr_hc06_18
   \   0003C7   90....       MOV     DPTR,#uip_aligned_buf + 36
   \   0003CA   E0           MOVX    A,@DPTR
   \   0003CB   F8           MOV     R0,A
   \   0003CC   A3           INC     DPTR
   \   0003CD   E0           MOVX    A,@DPTR
   \   0003CE   F9           MOV     R1,A
   \   0003CF   E8           MOV     A,R0
   \   0003D0   49           ORL     A,R1
   \   0003D1   7034         JNZ     ??compress_hdr_hc06_18
   \   0003D3   90....       MOV     DPTR,#uip_aligned_buf + 38
   \   0003D6   E0           MOVX    A,@DPTR
   \   0003D7   702E         JNZ     ??compress_hdr_hc06_18
    652                iphc1 |= SICSLOWPAN_IPHC_DAM_11;
   \   0003D9   43..03       ORL     ?V0 + 0,#0x3
    653                /* use last byte */
    654                *hc06_ptr = UIP_IP_BUF->destipaddr.u8[15];
   \   0003DC   90....       MOV     DPTR,#uip_aligned_buf + 39
   \   0003DF   E0           MOVX    A,@DPTR
   \   0003E0   C0E0         PUSH    A
   \   0003E2   90....       MOV     DPTR,#hc06_ptr
   \   0003E5   E0           MOVX    A,@DPTR
   \   0003E6   F8           MOV     R0,A
   \   0003E7   A3           INC     DPTR
   \   0003E8   E0           MOVX    A,@DPTR
   \   0003E9   F583         MOV     DPH,A
   \   0003EB   8882         MOV     DPL,R0
   \   0003ED   D0E0         POP     A
   \   0003EF   F0           MOVX    @DPTR,A
    655                hc06_ptr += 1;
   \   0003F0   90....       MOV     DPTR,#hc06_ptr
   \   0003F3   E0           MOVX    A,@DPTR
   \   0003F4   2401         ADD     A,#0x1
   \   0003F6   F8           MOV     R0,A
   \   0003F7   A3           INC     DPTR
   \   0003F8   E0           MOVX    A,@DPTR
   \   0003F9   3400         ADDC    A,#0x0
   \   0003FB   F9           MOV     R1,A
   \   0003FC   90....       MOV     DPTR,#hc06_ptr
   \   0003FF   E8           MOV     A,R0
   \   000400   F0           MOVX    @DPTR,A
   \   000401   A3           INC     DPTR
   \   000402   E9           MOV     A,R1
   \   000403   F0           MOVX    @DPTR,A
   \   000404   02....       LJMP    ??compress_hdr_hc06_19 & 0xFFFF
    656              } else if(sicslowpan_is_mcast_addr_compressable32(&UIP_IP_BUF->destipaddr)) {
   \                     ??compress_hdr_hc06_18:
   \   000407   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   00040A   E0           MOVX    A,@DPTR
   \   00040B   F8           MOV     R0,A
   \   00040C   A3           INC     DPTR
   \   00040D   E0           MOVX    A,@DPTR
   \   00040E   F9           MOV     R1,A
   \   00040F   E8           MOV     A,R0
   \   000410   49           ORL     A,R1
   \   000411   6003         JZ      $+5
   \   000413   02....       LJMP    ??compress_hdr_hc06_20 & 0xFFFF
   \   000416   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   000419   E0           MOVX    A,@DPTR
   \   00041A   F8           MOV     R0,A
   \   00041B   A3           INC     DPTR
   \   00041C   E0           MOVX    A,@DPTR
   \   00041D   F9           MOV     R1,A
   \   00041E   E8           MOV     A,R0
   \   00041F   49           ORL     A,R1
   \   000420   707F         JNZ     ??compress_hdr_hc06_20
   \   000422   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   000425   E0           MOVX    A,@DPTR
   \   000426   F8           MOV     R0,A
   \   000427   A3           INC     DPTR
   \   000428   E0           MOVX    A,@DPTR
   \   000429   F9           MOV     R1,A
   \   00042A   E8           MOV     A,R0
   \   00042B   49           ORL     A,R1
   \   00042C   7073         JNZ     ??compress_hdr_hc06_20
   \   00042E   90....       MOV     DPTR,#uip_aligned_buf + 32
   \   000431   E0           MOVX    A,@DPTR
   \   000432   F8           MOV     R0,A
   \   000433   A3           INC     DPTR
   \   000434   E0           MOVX    A,@DPTR
   \   000435   F9           MOV     R1,A
   \   000436   E8           MOV     A,R0
   \   000437   49           ORL     A,R1
   \   000438   7067         JNZ     ??compress_hdr_hc06_20
   \   00043A   90....       MOV     DPTR,#uip_aligned_buf + 34
   \   00043D   E0           MOVX    A,@DPTR
   \   00043E   F8           MOV     R0,A
   \   00043F   A3           INC     DPTR
   \   000440   E0           MOVX    A,@DPTR
   \   000441   F9           MOV     R1,A
   \   000442   E8           MOV     A,R0
   \   000443   49           ORL     A,R1
   \   000444   705B         JNZ     ??compress_hdr_hc06_20
   \   000446   90....       MOV     DPTR,#uip_aligned_buf + 36
   \   000449   E0           MOVX    A,@DPTR
   \   00044A   7055         JNZ     ??compress_hdr_hc06_20
    657                iphc1 |= SICSLOWPAN_IPHC_DAM_10;
   \   00044C   D3           SETB    C
   \   00044D   E5..         MOV     A,?V0 + 0
   \   00044F   92E1         MOV     0xE0 /* A   */.1,C
   \   000451   F5..         MOV     ?V0 + 0,A
    658                /* second byte + the last three */
    659                *hc06_ptr = UIP_IP_BUF->destipaddr.u8[1];
   \   000453   90....       MOV     DPTR,#uip_aligned_buf + 25
   \   000456   E0           MOVX    A,@DPTR
   \   000457   C0E0         PUSH    A
   \   000459   90....       MOV     DPTR,#hc06_ptr
   \   00045C   E0           MOVX    A,@DPTR
   \   00045D   F8           MOV     R0,A
   \   00045E   A3           INC     DPTR
   \   00045F   E0           MOVX    A,@DPTR
   \   000460   F583         MOV     DPH,A
   \   000462   8882         MOV     DPL,R0
   \   000464   D0E0         POP     A
   \   000466   F0           MOVX    @DPTR,A
    660                memcpy(hc06_ptr + 1, &UIP_IP_BUF->destipaddr.u8[13], 3);
   \   000467                ; Setup parameters for call to function memcpy
   \   000467   75..03       MOV     ?V0 + 2,#0x3
   \   00046A   75..00       MOV     ?V0 + 3,#0x0
   \   00046D   78..         MOV     R0,#?V0 + 2
   \   00046F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000472   7C..         MOV     R4,#(uip_aligned_buf + 37) & 0xff
   \   000474   7D..         MOV     R5,#((uip_aligned_buf + 37) >> 8) & 0xff
   \   000476   90....       MOV     DPTR,#hc06_ptr
   \   000479   E0           MOVX    A,@DPTR
   \   00047A   2401         ADD     A,#0x1
   \   00047C   FA           MOV     R2,A
   \   00047D   A3           INC     DPTR
   \   00047E   E0           MOVX    A,@DPTR
   \   00047F   3400         ADDC    A,#0x0
   \   000481   FB           MOV     R3,A
   \   000482   12....       LCALL   ??memcpy?relay
   \   000485   7402         MOV     A,#0x2
   \   000487   12....       LCALL   ?DEALLOC_XSTACK8
    661                hc06_ptr += 4;
   \   00048A   90....       MOV     DPTR,#hc06_ptr
   \   00048D   E0           MOVX    A,@DPTR
   \   00048E   2404         ADD     A,#0x4
   \   000490   F8           MOV     R0,A
   \   000491   A3           INC     DPTR
   \   000492   E0           MOVX    A,@DPTR
   \   000493   3400         ADDC    A,#0x0
   \   000495   F9           MOV     R1,A
   \   000496   90....       MOV     DPTR,#hc06_ptr
   \   000499   E8           MOV     A,R0
   \   00049A   F0           MOVX    @DPTR,A
   \   00049B   A3           INC     DPTR
   \   00049C   E9           MOV     A,R1
   \   00049D   F0           MOVX    @DPTR,A
   \   00049E   02....       LJMP    ??compress_hdr_hc06_19 & 0xFFFF
    662              } else if(sicslowpan_is_mcast_addr_compressable48(&UIP_IP_BUF->destipaddr)) {
   \                     ??compress_hdr_hc06_20:
   \   0004A1   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   0004A4   E0           MOVX    A,@DPTR
   \   0004A5   F8           MOV     R0,A
   \   0004A6   A3           INC     DPTR
   \   0004A7   E0           MOVX    A,@DPTR
   \   0004A8   F9           MOV     R1,A
   \   0004A9   E8           MOV     A,R0
   \   0004AA   49           ORL     A,R1
   \   0004AB   707F         JNZ     ??compress_hdr_hc06_21
   \   0004AD   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   0004B0   E0           MOVX    A,@DPTR
   \   0004B1   F8           MOV     R0,A
   \   0004B2   A3           INC     DPTR
   \   0004B3   E0           MOVX    A,@DPTR
   \   0004B4   F9           MOV     R1,A
   \   0004B5   E8           MOV     A,R0
   \   0004B6   49           ORL     A,R1
   \   0004B7   7073         JNZ     ??compress_hdr_hc06_21
   \   0004B9   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   0004BC   E0           MOVX    A,@DPTR
   \   0004BD   F8           MOV     R0,A
   \   0004BE   A3           INC     DPTR
   \   0004BF   E0           MOVX    A,@DPTR
   \   0004C0   F9           MOV     R1,A
   \   0004C1   E8           MOV     A,R0
   \   0004C2   49           ORL     A,R1
   \   0004C3   7067         JNZ     ??compress_hdr_hc06_21
   \   0004C5   90....       MOV     DPTR,#uip_aligned_buf + 32
   \   0004C8   E0           MOVX    A,@DPTR
   \   0004C9   F8           MOV     R0,A
   \   0004CA   A3           INC     DPTR
   \   0004CB   E0           MOVX    A,@DPTR
   \   0004CC   F9           MOV     R1,A
   \   0004CD   E8           MOV     A,R0
   \   0004CE   49           ORL     A,R1
   \   0004CF   705B         JNZ     ??compress_hdr_hc06_21
   \   0004D1   90....       MOV     DPTR,#uip_aligned_buf + 34
   \   0004D4   E0           MOVX    A,@DPTR
   \   0004D5   7055         JNZ     ??compress_hdr_hc06_21
    663                iphc1 |= SICSLOWPAN_IPHC_DAM_01;
   \   0004D7   D3           SETB    C
   \   0004D8   E5..         MOV     A,?V0 + 0
   \   0004DA   92E0         MOV     0xE0 /* A   */.0,C
   \   0004DC   F5..         MOV     ?V0 + 0,A
    664                /* second byte + the last five */
    665                *hc06_ptr = UIP_IP_BUF->destipaddr.u8[1];
   \   0004DE   90....       MOV     DPTR,#uip_aligned_buf + 25
   \   0004E1   E0           MOVX    A,@DPTR
   \   0004E2   C0E0         PUSH    A
   \   0004E4   90....       MOV     DPTR,#hc06_ptr
   \   0004E7   E0           MOVX    A,@DPTR
   \   0004E8   F8           MOV     R0,A
   \   0004E9   A3           INC     DPTR
   \   0004EA   E0           MOVX    A,@DPTR
   \   0004EB   F583         MOV     DPH,A
   \   0004ED   8882         MOV     DPL,R0
   \   0004EF   D0E0         POP     A
   \   0004F1   F0           MOVX    @DPTR,A
    666                memcpy(hc06_ptr + 1, &UIP_IP_BUF->destipaddr.u8[11], 5);
   \   0004F2                ; Setup parameters for call to function memcpy
   \   0004F2   75..05       MOV     ?V0 + 2,#0x5
   \   0004F5   75..00       MOV     ?V0 + 3,#0x0
   \   0004F8   78..         MOV     R0,#?V0 + 2
   \   0004FA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0004FD   7C..         MOV     R4,#(uip_aligned_buf + 35) & 0xff
   \   0004FF   7D..         MOV     R5,#((uip_aligned_buf + 35) >> 8) & 0xff
   \   000501   90....       MOV     DPTR,#hc06_ptr
   \   000504   E0           MOVX    A,@DPTR
   \   000505   2401         ADD     A,#0x1
   \   000507   FA           MOV     R2,A
   \   000508   A3           INC     DPTR
   \   000509   E0           MOVX    A,@DPTR
   \   00050A   3400         ADDC    A,#0x0
   \   00050C   FB           MOV     R3,A
   \   00050D   12....       LCALL   ??memcpy?relay
   \   000510   7402         MOV     A,#0x2
   \   000512   12....       LCALL   ?DEALLOC_XSTACK8
    667                hc06_ptr += 6;
   \   000515   90....       MOV     DPTR,#hc06_ptr
   \   000518   E0           MOVX    A,@DPTR
   \   000519   2406         ADD     A,#0x6
   \   00051B   F8           MOV     R0,A
   \   00051C   A3           INC     DPTR
   \   00051D   E0           MOVX    A,@DPTR
   \   00051E   3400         ADDC    A,#0x0
   \   000520   F9           MOV     R1,A
   \   000521   90....       MOV     DPTR,#hc06_ptr
   \   000524   E8           MOV     A,R0
   \   000525   F0           MOVX    @DPTR,A
   \   000526   A3           INC     DPTR
   \   000527   E9           MOV     A,R1
   \   000528   F0           MOVX    @DPTR,A
   \   000529   02....       LJMP    ??compress_hdr_hc06_19 & 0xFFFF
    668              } else {
    669                iphc1 |= SICSLOWPAN_IPHC_DAM_00;
    670                /* full address */
    671                memcpy(hc06_ptr, &UIP_IP_BUF->destipaddr.u8[0], 16);
   \                     ??compress_hdr_hc06_21:
   \   00052C                ; Setup parameters for call to function memcpy
   \   00052C   75..10       MOV     ?V0 + 2,#0x10
   \   00052F   75..00       MOV     ?V0 + 3,#0x0
   \   000532   78..         MOV     R0,#?V0 + 2
   \   000534   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000537   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   000539   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   00053B   90....       MOV     DPTR,#hc06_ptr
   \   00053E   E0           MOVX    A,@DPTR
   \   00053F   FA           MOV     R2,A
   \   000540   A3           INC     DPTR
   \   000541   E0           MOVX    A,@DPTR
   \   000542   FB           MOV     R3,A
   \   000543   12....       LCALL   ??memcpy?relay
   \   000546   7402         MOV     A,#0x2
   \   000548   12....       LCALL   ?DEALLOC_XSTACK8
    672                hc06_ptr += 16;
   \   00054B   90....       MOV     DPTR,#hc06_ptr
   \   00054E   E0           MOVX    A,@DPTR
   \   00054F   2410         ADD     A,#0x10
   \   000551   F8           MOV     R0,A
   \   000552   A3           INC     DPTR
   \   000553   E0           MOVX    A,@DPTR
   \   000554   3400         ADDC    A,#0x0
   \   000556   F9           MOV     R1,A
   \   000557   90....       MOV     DPTR,#hc06_ptr
   \   00055A   E8           MOV     A,R0
   \   00055B   F0           MOVX    @DPTR,A
   \   00055C   A3           INC     DPTR
   \   00055D   E9           MOV     A,R1
   \   00055E   F0           MOVX    @DPTR,A
   \   00055F   02....       LJMP    ??compress_hdr_hc06_19 & 0xFFFF
    673              }
    674            } else {
    675              /* Address is unicast, try to compress */
    676              if((context = addr_context_lookup_by_prefix(&UIP_IP_BUF->destipaddr)) != NULL) {
   \                     ??compress_hdr_hc06_17:
   \   000562                ; Setup parameters for call to function addr_context_lookup_by_prefix
   \   000562   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   000564   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000566   12....       LCALL   ??addr_context_lookup_by_prefix?relay
   \   000569   8A..         MOV     ?V0 + 2,R2
   \   00056B   8B..         MOV     ?V0 + 3,R3
   \   00056D   A8..         MOV     R0,?V0 + 2
   \   00056F   A9..         MOV     R1,?V0 + 3
   \   000571   90....       MOV     DPTR,#context
   \   000574   E8           MOV     A,R0
   \   000575   F0           MOVX    @DPTR,A
   \   000576   A3           INC     DPTR
   \   000577   E9           MOV     A,R1
   \   000578   F0           MOVX    @DPTR,A
   \   000579   E8           MOV     A,R0
   \   00057A   49           ORL     A,R1
   \   00057B   6040         JZ      ??compress_hdr_hc06_22
    677                /* elide the prefix */
    678                iphc1 |= SICSLOWPAN_IPHC_DAC;
   \   00057D   D3           SETB    C
   \   00057E   E5..         MOV     A,?V0 + 0
   \   000580   92E2         MOV     0xE0 /* A   */.2,C
   \   000582   F5..         MOV     ?V0 + 0,A
    679                RIME_IPHC_BUF[2] |= context->number;
   \   000584   90....       MOV     DPTR,#context
   \   000587   E0           MOVX    A,@DPTR
   \   000588   F8           MOV     R0,A
   \   000589   A3           INC     DPTR
   \   00058A   E0           MOVX    A,@DPTR
   \   00058B   F583         MOV     DPH,A
   \   00058D   8882         MOV     DPL,R0
   \   00058F   A3           INC     DPTR
   \   000590   E0           MOVX    A,@DPTR
   \   000591   FB           MOV     R3,A
   \   000592   90....       MOV     DPTR,#rime_hdr_len
   \   000595   E0           MOVX    A,@DPTR
   \   000596   F8           MOV     R0,A
   \   000597   7900         MOV     R1,#0x0
   \   000599   90....       MOV     DPTR,#rime_ptr
   \   00059C   E0           MOVX    A,@DPTR
   \   00059D   28           ADD     A,R0
   \   00059E   FA           MOV     R2,A
   \   00059F   A3           INC     DPTR
   \   0005A0   E0           MOVX    A,@DPTR
   \   0005A1   39           ADDC    A,R1
   \   0005A2   8A82         MOV     DPL,R2
   \   0005A4   F583         MOV     DPH,A
   \   0005A6   A3           INC     DPTR
   \   0005A7   A3           INC     DPTR
   \   0005A8   E0           MOVX    A,@DPTR
   \   0005A9   4B           ORL     A,R3
   \   0005AA   F0           MOVX    @DPTR,A
    680                /* compession compare with link adress (destination) */
    681          
    682                iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_DAM_BIT,
    683          	       &UIP_IP_BUF->destipaddr, (uip_lladdr_t *)rime_destaddr);
   \   0005AB                ; Setup parameters for call to function compress_addr_64
   \   0005AB   EE           MOV     A,R6
   \   0005AC   FC           MOV     R4,A
   \   0005AD   EF           MOV     A,R7
   \   0005AE   FD           MOV     R5,A
   \   0005AF   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0005B1   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0005B3   7900         MOV     R1,#0x0
   \   0005B5   12....       LCALL   ??compress_addr_64?relay
   \   0005B8   E9           MOV     A,R1
   \   0005B9   42..         ORL     ?V0 + 0,A
   \   0005BB   8079         SJMP    ??compress_hdr_hc06_19
    684                /* No context found for this address */
    685              } else if(uip_is_addr_link_local(&UIP_IP_BUF->destipaddr) &&
    686          	      UIP_IP_BUF->destipaddr.u16[1] == 0 &&
    687          	      UIP_IP_BUF->destipaddr.u16[2] == 0 &&
    688          	      UIP_IP_BUF->destipaddr.u16[3] == 0) {
   \                     ??compress_hdr_hc06_22:
   \   0005BD   90....       MOV     DPTR,#uip_aligned_buf + 24
   \   0005C0   E0           MOVX    A,@DPTR
   \   0005C1   64FE         XRL     A,#0xfe
   \   0005C3   703E         JNZ     ??compress_hdr_hc06_23
   \   0005C5   90....       MOV     DPTR,#uip_aligned_buf + 25
   \   0005C8   E0           MOVX    A,@DPTR
   \   0005C9   6480         XRL     A,#0x80
   \   0005CB   7036         JNZ     ??compress_hdr_hc06_23
   \   0005CD   90....       MOV     DPTR,#uip_aligned_buf + 26
   \   0005D0   E0           MOVX    A,@DPTR
   \   0005D1   F8           MOV     R0,A
   \   0005D2   A3           INC     DPTR
   \   0005D3   E0           MOVX    A,@DPTR
   \   0005D4   F9           MOV     R1,A
   \   0005D5   E8           MOV     A,R0
   \   0005D6   49           ORL     A,R1
   \   0005D7   702A         JNZ     ??compress_hdr_hc06_23
   \   0005D9   90....       MOV     DPTR,#uip_aligned_buf + 28
   \   0005DC   E0           MOVX    A,@DPTR
   \   0005DD   F8           MOV     R0,A
   \   0005DE   A3           INC     DPTR
   \   0005DF   E0           MOVX    A,@DPTR
   \   0005E0   F9           MOV     R1,A
   \   0005E1   E8           MOV     A,R0
   \   0005E2   49           ORL     A,R1
   \   0005E3   701E         JNZ     ??compress_hdr_hc06_23
   \   0005E5   90....       MOV     DPTR,#uip_aligned_buf + 30
   \   0005E8   E0           MOVX    A,@DPTR
   \   0005E9   F8           MOV     R0,A
   \   0005EA   A3           INC     DPTR
   \   0005EB   E0           MOVX    A,@DPTR
   \   0005EC   F9           MOV     R1,A
   \   0005ED   E8           MOV     A,R0
   \   0005EE   49           ORL     A,R1
   \   0005EF   7012         JNZ     ??compress_hdr_hc06_23
    689                iphc1 |= compress_addr_64(SICSLOWPAN_IPHC_DAM_BIT,
    690                         &UIP_IP_BUF->destipaddr, (uip_lladdr_t *)rime_destaddr);
   \   0005F1                ; Setup parameters for call to function compress_addr_64
   \   0005F1   EE           MOV     A,R6
   \   0005F2   FC           MOV     R4,A
   \   0005F3   EF           MOV     A,R7
   \   0005F4   FD           MOV     R5,A
   \   0005F5   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0005F7   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0005F9   7900         MOV     R1,#0x0
   \   0005FB   12....       LCALL   ??compress_addr_64?relay
   \   0005FE   E9           MOV     A,R1
   \   0005FF   42..         ORL     ?V0 + 0,A
   \   000601   8033         SJMP    ??compress_hdr_hc06_19
    691              } else {
    692                /* send the full address */
    693                iphc1 |= SICSLOWPAN_IPHC_DAM_00; /* 128-bits */
    694                memcpy(hc06_ptr, &UIP_IP_BUF->destipaddr.u16[0], 16);
   \                     ??compress_hdr_hc06_23:
   \   000603                ; Setup parameters for call to function memcpy
   \   000603   75..10       MOV     ?V0 + 2,#0x10
   \   000606   75..00       MOV     ?V0 + 3,#0x0
   \   000609   78..         MOV     R0,#?V0 + 2
   \   00060B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00060E   7C..         MOV     R4,#(uip_aligned_buf + 24) & 0xff
   \   000610   7D..         MOV     R5,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000612   90....       MOV     DPTR,#hc06_ptr
   \   000615   E0           MOVX    A,@DPTR
   \   000616   FA           MOV     R2,A
   \   000617   A3           INC     DPTR
   \   000618   E0           MOVX    A,@DPTR
   \   000619   FB           MOV     R3,A
   \   00061A   12....       LCALL   ??memcpy?relay
   \   00061D   7402         MOV     A,#0x2
   \   00061F   12....       LCALL   ?DEALLOC_XSTACK8
    695                hc06_ptr += 16;
   \   000622   90....       MOV     DPTR,#hc06_ptr
   \   000625   E0           MOVX    A,@DPTR
   \   000626   2410         ADD     A,#0x10
   \   000628   F8           MOV     R0,A
   \   000629   A3           INC     DPTR
   \   00062A   E0           MOVX    A,@DPTR
   \   00062B   3400         ADDC    A,#0x0
   \   00062D   F9           MOV     R1,A
   \   00062E   90....       MOV     DPTR,#hc06_ptr
   \   000631   E8           MOV     A,R0
   \   000632   F0           MOVX    @DPTR,A
   \   000633   A3           INC     DPTR
   \   000634   E9           MOV     A,R1
   \   000635   F0           MOVX    @DPTR,A
    696              }
    697            }
    698          
    699            uncomp_hdr_len = UIP_IPH_LEN;
   \                     ??compress_hdr_hc06_19:
   \   000636   90....       MOV     DPTR,#uncomp_hdr_len
   \   000639   7428         MOV     A,#0x28
   \   00063B   F0           MOVX    @DPTR,A
    700          
    701          #if UIP_CONF_UDP || UIP_CONF_ROUTER
    702            /* UDP header compression */
    703            if(UIP_IP_BUF->proto == UIP_PROTO_UDP) {
   \   00063C   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   00063F   E0           MOVX    A,@DPTR
   \   000640   6411         XRL     A,#0x11
   \   000642   6003         JZ      $+5
   \   000644   02....       LJMP    ??compress_hdr_hc06_24 & 0xFFFF
    704              PRINTF("IPHC: Uncompressed UDP ports on send side: %x, %x\n",
    705          	   UIP_HTONS(UIP_UDP_BUF->srcport), UIP_HTONS(UIP_UDP_BUF->destport));
    706              /* Mask out the last 4 bits can be used as a mask */
    707              if(((UIP_HTONS(UIP_UDP_BUF->srcport) & 0xfff0) == SICSLOWPAN_UDP_4_BIT_PORT_MIN) &&
    708                 ((UIP_HTONS(UIP_UDP_BUF->destport) & 0xfff0) == SICSLOWPAN_UDP_4_BIT_PORT_MIN)) {
   \   000647   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   00064A   E0           MOVX    A,@DPTR
   \   00064B   FA           MOV     R2,A
   \   00064C   A3           INC     DPTR
   \   00064D   E0           MOVX    A,@DPTR
   \   00064E   FB           MOV     R3,A
   \   00064F   E4           CLR     A
   \   000650   CA           XCH     A,R2
   \   000651   FB           MOV     R3,A
   \   000652   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   000655   E0           MOVX    A,@DPTR
   \   000656   F8           MOV     R0,A
   \   000657   A3           INC     DPTR
   \   000658   E0           MOVX    A,@DPTR
   \   000659   F9           MOV     R1,A
   \   00065A   E4           CLR     A
   \   00065B   C9           XCH     A,R1
   \   00065C   F8           MOV     R0,A
   \   00065D   EA           MOV     A,R2
   \   00065E   48           ORL     A,R0
   \   00065F   F8           MOV     R0,A
   \   000660   EB           MOV     A,R3
   \   000661   49           ORL     A,R1
   \   000662   F9           MOV     R1,A
   \   000663   E8           MOV     A,R0
   \   000664   54F0         ANL     A,#0xf0
   \   000666   F8           MOV     R0,A
   \   000667   E9           MOV     A,R1
   \   000668   54FF         ANL     A,#0xff
   \   00066A   F9           MOV     R1,A
   \   00066B   74B0         MOV     A,#-0x50
   \   00066D   68           XRL     A,R0
   \   00066E   7003         JNZ     ??compress_hdr_hc06_25
   \   000670   74F0         MOV     A,#-0x10
   \   000672   69           XRL     A,R1
   \                     ??compress_hdr_hc06_25:
   \   000673   6003         JZ      $+5
   \   000675   02....       LJMP    ??compress_hdr_hc06_26 & 0xFFFF
   \   000678   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   00067B   E0           MOVX    A,@DPTR
   \   00067C   FA           MOV     R2,A
   \   00067D   A3           INC     DPTR
   \   00067E   E0           MOVX    A,@DPTR
   \   00067F   FB           MOV     R3,A
   \   000680   E4           CLR     A
   \   000681   CA           XCH     A,R2
   \   000682   FB           MOV     R3,A
   \   000683   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000686   E0           MOVX    A,@DPTR
   \   000687   F8           MOV     R0,A
   \   000688   A3           INC     DPTR
   \   000689   E0           MOVX    A,@DPTR
   \   00068A   F9           MOV     R1,A
   \   00068B   E4           CLR     A
   \   00068C   C9           XCH     A,R1
   \   00068D   F8           MOV     R0,A
   \   00068E   EA           MOV     A,R2
   \   00068F   48           ORL     A,R0
   \   000690   F8           MOV     R0,A
   \   000691   EB           MOV     A,R3
   \   000692   49           ORL     A,R1
   \   000693   F9           MOV     R1,A
   \   000694   E8           MOV     A,R0
   \   000695   54F0         ANL     A,#0xf0
   \   000697   F8           MOV     R0,A
   \   000698   E9           MOV     A,R1
   \   000699   54FF         ANL     A,#0xff
   \   00069B   F9           MOV     R1,A
   \   00069C   74B0         MOV     A,#-0x50
   \   00069E   68           XRL     A,R0
   \   00069F   7003         JNZ     ??compress_hdr_hc06_27
   \   0006A1   74F0         MOV     A,#-0x10
   \   0006A3   69           XRL     A,R1
   \                     ??compress_hdr_hc06_27:
   \   0006A4   7065         JNZ     ??compress_hdr_hc06_26
    709                /* we can compress 12 bits of both source and dest */
    710                *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_11;
   \   0006A6   90....       MOV     DPTR,#hc06_ptr
   \   0006A9   E0           MOVX    A,@DPTR
   \   0006AA   F8           MOV     R0,A
   \   0006AB   A3           INC     DPTR
   \   0006AC   E0           MOVX    A,@DPTR
   \   0006AD   F583         MOV     DPH,A
   \   0006AF   8882         MOV     DPL,R0
   \   0006B1   74F3         MOV     A,#-0xd
   \   0006B3   F0           MOVX    @DPTR,A
    711                PRINTF("IPHC: remove 12 b of both source & dest with prefix 0xFOB\n");
    712                *(hc06_ptr + 1) =
    713          	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->srcport) -
    714          		SICSLOWPAN_UDP_4_BIT_PORT_MIN) << 4) +
    715          	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->destport) -
    716          		SICSLOWPAN_UDP_4_BIT_PORT_MIN));
   \   0006B4   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   0006B7   E0           MOVX    A,@DPTR
   \   0006B8   F8           MOV     R0,A
   \   0006B9   A3           INC     DPTR
   \   0006BA   E0           MOVX    A,@DPTR
   \   0006BB   F9           MOV     R1,A
   \   0006BC   E4           CLR     A
   \   0006BD   E9           MOV     A,R1
   \   0006BE   F8           MOV     R0,A
   \   0006BF   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   0006C2   E0           MOVX    A,@DPTR
   \   0006C3   FA           MOV     R2,A
   \   0006C4   A3           INC     DPTR
   \   0006C5   E0           MOVX    A,@DPTR
   \   0006C6   FB           MOV     R3,A
   \   0006C7   EA           MOV     A,R2
   \   0006C8   E4           CLR     A
   \   0006C9   48           ORL     A,R0
   \   0006CA   2450         ADD     A,#0x50
   \   0006CC   F9           MOV     R1,A
   \   0006CD   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   0006D0   E0           MOVX    A,@DPTR
   \   0006D1   F5..         MOV     ?V0 + 2,A
   \   0006D3   A3           INC     DPTR
   \   0006D4   E0           MOVX    A,@DPTR
   \   0006D5   F5..         MOV     ?V0 + 3,A
   \   0006D7   7404         MOV     A,#0x4
   \   0006D9   78..         MOV     R0,#?V0 + 2
   \   0006DB   12....       LCALL   ?US_SHR
   \   0006DE   E5..         MOV     A,?V0 + 2
   \   0006E0   54F0         ANL     A,#0xf0
   \   0006E2   29           ADD     A,R1
   \   0006E3   C0E0         PUSH    A
   \   0006E5   90....       MOV     DPTR,#hc06_ptr
   \   0006E8   E0           MOVX    A,@DPTR
   \   0006E9   F8           MOV     R0,A
   \   0006EA   A3           INC     DPTR
   \   0006EB   E0           MOVX    A,@DPTR
   \   0006EC   F583         MOV     DPH,A
   \   0006EE   8882         MOV     DPL,R0
   \   0006F0   A3           INC     DPTR
   \   0006F1   D0E0         POP     A
   \   0006F3   F0           MOVX    @DPTR,A
    717                hc06_ptr += 2;
   \   0006F4   90....       MOV     DPTR,#hc06_ptr
   \   0006F7   E0           MOVX    A,@DPTR
   \   0006F8   2402         ADD     A,#0x2
   \   0006FA   F8           MOV     R0,A
   \   0006FB   A3           INC     DPTR
   \   0006FC   E0           MOVX    A,@DPTR
   \   0006FD   3400         ADDC    A,#0x0
   \   0006FF   F9           MOV     R1,A
   \   000700   90....       MOV     DPTR,#hc06_ptr
   \   000703   E8           MOV     A,R0
   \   000704   F0           MOVX    @DPTR,A
   \   000705   A3           INC     DPTR
   \   000706   E9           MOV     A,R1
   \   000707   F0           MOVX    @DPTR,A
   \   000708   02....       LJMP    ??compress_hdr_hc06_28 & 0xFFFF
    718              } else if((UIP_HTONS(UIP_UDP_BUF->destport) & 0xff00) == SICSLOWPAN_UDP_8_BIT_PORT_MIN) {
   \                     ??compress_hdr_hc06_26:
   \   00070B   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   00070E   E0           MOVX    A,@DPTR
   \   00070F   F8           MOV     R0,A
   \   000710   A3           INC     DPTR
   \   000711   E0           MOVX    A,@DPTR
   \   000712   F9           MOV     R1,A
   \   000713   E8           MOV     A,R0
   \   000714   54FF         ANL     A,#0xff
   \   000716   64F0         XRL     A,#0xf0
   \   000718   7071         JNZ     ??compress_hdr_hc06_29
    719                /* we can compress 8 bits of dest, leave source. */
    720                *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_01;
   \   00071A   90....       MOV     DPTR,#hc06_ptr
   \   00071D   E0           MOVX    A,@DPTR
   \   00071E   F8           MOV     R0,A
   \   00071F   A3           INC     DPTR
   \   000720   E0           MOVX    A,@DPTR
   \   000721   F583         MOV     DPH,A
   \   000723   8882         MOV     DPL,R0
   \   000725   74F1         MOV     A,#-0xf
   \   000727   F0           MOVX    @DPTR,A
    721                PRINTF("IPHC: leave source, remove 8 bits of dest with prefix 0xF0\n");
    722                memcpy(hc06_ptr + 1, &UIP_UDP_BUF->srcport, 2);
   \   000728                ; Setup parameters for call to function memcpy
   \   000728   75..02       MOV     ?V0 + 2,#0x2
   \   00072B   75..00       MOV     ?V0 + 3,#0x0
   \   00072E   78..         MOV     R0,#?V0 + 2
   \   000730   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000733   7C..         MOV     R4,#(uip_aligned_buf + 40) & 0xff
   \   000735   7D..         MOV     R5,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000737   90....       MOV     DPTR,#hc06_ptr
   \   00073A   E0           MOVX    A,@DPTR
   \   00073B   2401         ADD     A,#0x1
   \   00073D   FA           MOV     R2,A
   \   00073E   A3           INC     DPTR
   \   00073F   E0           MOVX    A,@DPTR
   \   000740   3400         ADDC    A,#0x0
   \   000742   FB           MOV     R3,A
   \   000743   12....       LCALL   ??memcpy?relay
   \   000746   7402         MOV     A,#0x2
   \   000748   12....       LCALL   ?DEALLOC_XSTACK8
    723                *(hc06_ptr + 3) =
    724          	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->destport) -
    725          		SICSLOWPAN_UDP_8_BIT_PORT_MIN));
   \   00074B   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   00074E   E0           MOVX    A,@DPTR
   \   00074F   F8           MOV     R0,A
   \   000750   A3           INC     DPTR
   \   000751   E0           MOVX    A,@DPTR
   \   000752   F9           MOV     R1,A
   \   000753   E4           CLR     A
   \   000754   E9           MOV     A,R1
   \   000755   F8           MOV     R0,A
   \   000756   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   000759   E0           MOVX    A,@DPTR
   \   00075A   FA           MOV     R2,A
   \   00075B   A3           INC     DPTR
   \   00075C   E0           MOVX    A,@DPTR
   \   00075D   FB           MOV     R3,A
   \   00075E   EA           MOV     A,R2
   \   00075F   E4           CLR     A
   \   000760   48           ORL     A,R0
   \   000761   C0E0         PUSH    A
   \   000763   90....       MOV     DPTR,#hc06_ptr
   \   000766   E0           MOVX    A,@DPTR
   \   000767   F8           MOV     R0,A
   \   000768   A3           INC     DPTR
   \   000769   E0           MOVX    A,@DPTR
   \   00076A   F583         MOV     DPH,A
   \   00076C   8882         MOV     DPL,R0
   \   00076E   A3           INC     DPTR
   \   00076F   A3           INC     DPTR
   \   000770   A3           INC     DPTR
   \   000771   D0E0         POP     A
   \   000773   F0           MOVX    @DPTR,A
    726                hc06_ptr += 4;
   \   000774   90....       MOV     DPTR,#hc06_ptr
   \   000777   E0           MOVX    A,@DPTR
   \   000778   2404         ADD     A,#0x4
   \   00077A   F8           MOV     R0,A
   \   00077B   A3           INC     DPTR
   \   00077C   E0           MOVX    A,@DPTR
   \   00077D   3400         ADDC    A,#0x0
   \   00077F   F9           MOV     R1,A
   \   000780   90....       MOV     DPTR,#hc06_ptr
   \   000783   E8           MOV     A,R0
   \   000784   F0           MOVX    @DPTR,A
   \   000785   A3           INC     DPTR
   \   000786   E9           MOV     A,R1
   \   000787   F0           MOVX    @DPTR,A
   \   000788   02....       LJMP    ??compress_hdr_hc06_28 & 0xFFFF
    727              } else if((UIP_HTONS(UIP_UDP_BUF->srcport) & 0xff00) == SICSLOWPAN_UDP_8_BIT_PORT_MIN) {
   \                     ??compress_hdr_hc06_29:
   \   00078B   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   00078E   E0           MOVX    A,@DPTR
   \   00078F   F8           MOV     R0,A
   \   000790   A3           INC     DPTR
   \   000791   E0           MOVX    A,@DPTR
   \   000792   F9           MOV     R1,A
   \   000793   E8           MOV     A,R0
   \   000794   54FF         ANL     A,#0xff
   \   000796   64F0         XRL     A,#0xf0
   \   000798   706E         JNZ     ??compress_hdr_hc06_30
    728                /* we can compress 8 bits of src, leave dest. Copy compressed port */
    729                *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_10;
   \   00079A   90....       MOV     DPTR,#hc06_ptr
   \   00079D   E0           MOVX    A,@DPTR
   \   00079E   F8           MOV     R0,A
   \   00079F   A3           INC     DPTR
   \   0007A0   E0           MOVX    A,@DPTR
   \   0007A1   F583         MOV     DPH,A
   \   0007A3   8882         MOV     DPL,R0
   \   0007A5   74F2         MOV     A,#-0xe
   \   0007A7   F0           MOVX    @DPTR,A
    730                PRINTF("IPHC: remove 8 bits of source with prefix 0xF0, leave dest. hch: %i\n", *hc06_ptr);
    731                *(hc06_ptr + 1) =
    732          	(uint8_t)((UIP_HTONS(UIP_UDP_BUF->srcport) -
    733          		SICSLOWPAN_UDP_8_BIT_PORT_MIN));
   \   0007A8   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   0007AB   E0           MOVX    A,@DPTR
   \   0007AC   F8           MOV     R0,A
   \   0007AD   A3           INC     DPTR
   \   0007AE   E0           MOVX    A,@DPTR
   \   0007AF   F9           MOV     R1,A
   \   0007B0   E4           CLR     A
   \   0007B1   E9           MOV     A,R1
   \   0007B2   F8           MOV     R0,A
   \   0007B3   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   0007B6   E0           MOVX    A,@DPTR
   \   0007B7   FA           MOV     R2,A
   \   0007B8   A3           INC     DPTR
   \   0007B9   E0           MOVX    A,@DPTR
   \   0007BA   FB           MOV     R3,A
   \   0007BB   EA           MOV     A,R2
   \   0007BC   E4           CLR     A
   \   0007BD   48           ORL     A,R0
   \   0007BE   C0E0         PUSH    A
   \   0007C0   90....       MOV     DPTR,#hc06_ptr
   \   0007C3   E0           MOVX    A,@DPTR
   \   0007C4   F8           MOV     R0,A
   \   0007C5   A3           INC     DPTR
   \   0007C6   E0           MOVX    A,@DPTR
   \   0007C7   F583         MOV     DPH,A
   \   0007C9   8882         MOV     DPL,R0
   \   0007CB   A3           INC     DPTR
   \   0007CC   D0E0         POP     A
   \   0007CE   F0           MOVX    @DPTR,A
    734                memcpy(hc06_ptr + 2, &UIP_UDP_BUF->destport, 2);
   \   0007CF                ; Setup parameters for call to function memcpy
   \   0007CF   75..02       MOV     ?V0 + 2,#0x2
   \   0007D2   75..00       MOV     ?V0 + 3,#0x0
   \   0007D5   78..         MOV     R0,#?V0 + 2
   \   0007D7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0007DA   7C..         MOV     R4,#(uip_aligned_buf + 42) & 0xff
   \   0007DC   7D..         MOV     R5,#((uip_aligned_buf + 42) >> 8) & 0xff
   \   0007DE   90....       MOV     DPTR,#hc06_ptr
   \   0007E1   E0           MOVX    A,@DPTR
   \   0007E2   2402         ADD     A,#0x2
   \   0007E4   FA           MOV     R2,A
   \   0007E5   A3           INC     DPTR
   \   0007E6   E0           MOVX    A,@DPTR
   \   0007E7   3400         ADDC    A,#0x0
   \   0007E9   FB           MOV     R3,A
   \   0007EA   12....       LCALL   ??memcpy?relay
   \   0007ED   7402         MOV     A,#0x2
   \   0007EF   12....       LCALL   ?DEALLOC_XSTACK8
    735                hc06_ptr += 4;
   \   0007F2   90....       MOV     DPTR,#hc06_ptr
   \   0007F5   E0           MOVX    A,@DPTR
   \   0007F6   2404         ADD     A,#0x4
   \   0007F8   F8           MOV     R0,A
   \   0007F9   A3           INC     DPTR
   \   0007FA   E0           MOVX    A,@DPTR
   \   0007FB   3400         ADDC    A,#0x0
   \   0007FD   F9           MOV     R1,A
   \   0007FE   90....       MOV     DPTR,#hc06_ptr
   \   000801   E8           MOV     A,R0
   \   000802   F0           MOVX    @DPTR,A
   \   000803   A3           INC     DPTR
   \   000804   E9           MOV     A,R1
   \   000805   F0           MOVX    @DPTR,A
   \   000806   8045         SJMP    ??compress_hdr_hc06_28
    736              } else {
    737                /* we cannot compress. Copy uncompressed ports, full checksum  */
    738                *hc06_ptr = SICSLOWPAN_NHC_UDP_CS_P_00;
   \                     ??compress_hdr_hc06_30:
   \   000808   90....       MOV     DPTR,#hc06_ptr
   \   00080B   E0           MOVX    A,@DPTR
   \   00080C   F8           MOV     R0,A
   \   00080D   A3           INC     DPTR
   \   00080E   E0           MOVX    A,@DPTR
   \   00080F   F583         MOV     DPH,A
   \   000811   8882         MOV     DPL,R0
   \   000813   74F0         MOV     A,#-0x10
   \   000815   F0           MOVX    @DPTR,A
    739                PRINTF("IPHC: cannot compress headers\n");
    740                memcpy(hc06_ptr + 1, &UIP_UDP_BUF->srcport, 4);
   \   000816                ; Setup parameters for call to function memcpy
   \   000816   75..04       MOV     ?V0 + 2,#0x4
   \   000819   75..00       MOV     ?V0 + 3,#0x0
   \   00081C   78..         MOV     R0,#?V0 + 2
   \   00081E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000821   7C..         MOV     R4,#(uip_aligned_buf + 40) & 0xff
   \   000823   7D..         MOV     R5,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000825   90....       MOV     DPTR,#hc06_ptr
   \   000828   E0           MOVX    A,@DPTR
   \   000829   2401         ADD     A,#0x1
   \   00082B   FA           MOV     R2,A
   \   00082C   A3           INC     DPTR
   \   00082D   E0           MOVX    A,@DPTR
   \   00082E   3400         ADDC    A,#0x0
   \   000830   FB           MOV     R3,A
   \   000831   12....       LCALL   ??memcpy?relay
   \   000834   7402         MOV     A,#0x2
   \   000836   12....       LCALL   ?DEALLOC_XSTACK8
    741                hc06_ptr += 5;
   \   000839   90....       MOV     DPTR,#hc06_ptr
   \   00083C   E0           MOVX    A,@DPTR
   \   00083D   2405         ADD     A,#0x5
   \   00083F   F8           MOV     R0,A
   \   000840   A3           INC     DPTR
   \   000841   E0           MOVX    A,@DPTR
   \   000842   3400         ADDC    A,#0x0
   \   000844   F9           MOV     R1,A
   \   000845   90....       MOV     DPTR,#hc06_ptr
   \   000848   E8           MOV     A,R0
   \   000849   F0           MOVX    @DPTR,A
   \   00084A   A3           INC     DPTR
   \   00084B   E9           MOV     A,R1
   \   00084C   F0           MOVX    @DPTR,A
    742              }
    743              /* always inline the checksum  */
    744              if(1) {
    745                memcpy(hc06_ptr, &UIP_UDP_BUF->udpchksum, 2);
   \                     ??compress_hdr_hc06_28:
   \   00084D                ; Setup parameters for call to function memcpy
   \   00084D   75..02       MOV     ?V0 + 2,#0x2
   \   000850   75..00       MOV     ?V0 + 3,#0x0
   \   000853   78..         MOV     R0,#?V0 + 2
   \   000855   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000858   7C..         MOV     R4,#(uip_aligned_buf + 46) & 0xff
   \   00085A   7D..         MOV     R5,#((uip_aligned_buf + 46) >> 8) & 0xff
   \   00085C   90....       MOV     DPTR,#hc06_ptr
   \   00085F   E0           MOVX    A,@DPTR
   \   000860   FA           MOV     R2,A
   \   000861   A3           INC     DPTR
   \   000862   E0           MOVX    A,@DPTR
   \   000863   FB           MOV     R3,A
   \   000864   12....       LCALL   ??memcpy?relay
   \   000867   7402         MOV     A,#0x2
   \   000869   12....       LCALL   ?DEALLOC_XSTACK8
    746                hc06_ptr += 2;
   \   00086C   90....       MOV     DPTR,#hc06_ptr
   \   00086F   E0           MOVX    A,@DPTR
   \   000870   2402         ADD     A,#0x2
   \   000872   F8           MOV     R0,A
   \   000873   A3           INC     DPTR
   \   000874   E0           MOVX    A,@DPTR
   \   000875   3400         ADDC    A,#0x0
   \   000877   F9           MOV     R1,A
   \   000878   90....       MOV     DPTR,#hc06_ptr
   \   00087B   E8           MOV     A,R0
   \   00087C   F0           MOVX    @DPTR,A
   \   00087D   A3           INC     DPTR
   \   00087E   E9           MOV     A,R1
   \   00087F   F0           MOVX    @DPTR,A
    747              }
    748              uncomp_hdr_len += UIP_UDPH_LEN;
   \   000880   90....       MOV     DPTR,#uncomp_hdr_len
   \   000883   E0           MOVX    A,@DPTR
   \   000884   2408         ADD     A,#0x8
   \   000886   F0           MOVX    @DPTR,A
    749            }
    750          #endif /*UIP_CONF_UDP*/
    751          
    752          #ifdef SICSLOWPAN_NH_COMPRESSOR
    753            /* if nothing to compress just return zero  */
    754            hc06_ptr += SICSLOWPAN_NH_COMPRESSOR.compress(hc06_ptr, &uncomp_hdr_len);
    755          #endif
    756          
    757            /* before the rime_hdr_len operation */
    758            RIME_IPHC_BUF[0] = iphc0;
   \                     ??compress_hdr_hc06_24:
   \   000887   E5..         MOV     A,?V0 + 1
   \   000889   90....       MOV     DPTR,#rime_hdr_len
   \   00088C   E0           MOVX    A,@DPTR
   \   00088D   F8           MOV     R0,A
   \   00088E   7900         MOV     R1,#0x0
   \   000890   90....       MOV     DPTR,#rime_ptr
   \   000893   E0           MOVX    A,@DPTR
   \   000894   28           ADD     A,R0
   \   000895   FA           MOV     R2,A
   \   000896   A3           INC     DPTR
   \   000897   E0           MOVX    A,@DPTR
   \   000898   39           ADDC    A,R1
   \   000899   8A82         MOV     DPL,R2
   \   00089B   F583         MOV     DPH,A
   \   00089D   E5..         MOV     A,?V0 + 1
   \   00089F   F0           MOVX    @DPTR,A
    759            RIME_IPHC_BUF[1] = iphc1;
   \   0008A0   E5..         MOV     A,?V0 + 0
   \   0008A2   90....       MOV     DPTR,#rime_hdr_len
   \   0008A5   E0           MOVX    A,@DPTR
   \   0008A6   F8           MOV     R0,A
   \   0008A7   7900         MOV     R1,#0x0
   \   0008A9   90....       MOV     DPTR,#rime_ptr
   \   0008AC   E0           MOVX    A,@DPTR
   \   0008AD   28           ADD     A,R0
   \   0008AE   FA           MOV     R2,A
   \   0008AF   A3           INC     DPTR
   \   0008B0   E0           MOVX    A,@DPTR
   \   0008B1   39           ADDC    A,R1
   \   0008B2   8A82         MOV     DPL,R2
   \   0008B4   F583         MOV     DPH,A
   \   0008B6   A3           INC     DPTR
   \   0008B7   E5..         MOV     A,?V0 + 0
   \   0008B9   F0           MOVX    @DPTR,A
    760          
    761            rime_hdr_len = hc06_ptr - rime_ptr;
   \   0008BA   90....       MOV     DPTR,#rime_ptr
   \   0008BD   E0           MOVX    A,@DPTR
   \   0008BE   F8           MOV     R0,A
   \   0008BF   A3           INC     DPTR
   \   0008C0   E0           MOVX    A,@DPTR
   \   0008C1   F9           MOV     R1,A
   \   0008C2   90....       MOV     DPTR,#hc06_ptr
   \   0008C5   E0           MOVX    A,@DPTR
   \   0008C6   FA           MOV     R2,A
   \   0008C7   A3           INC     DPTR
   \   0008C8   E0           MOVX    A,@DPTR
   \   0008C9   FB           MOV     R3,A
   \   0008CA   EA           MOV     A,R2
   \   0008CB   C3           CLR     C
   \   0008CC   98           SUBB    A,R0
   \   0008CD   90....       MOV     DPTR,#rime_hdr_len
   \   0008D0   F0           MOVX    @DPTR,A
    762            return;
   \   0008D1   7F06         MOV     R7,#0x6
   \   0008D3   02....       LJMP    ?BANKED_LEAVE_XDATA
    763          }
    764          
    765          /*--------------------------------------------------------------------*/
    766          /**
    767           * \brief Uncompress HC06 (i.e., IPHC and LOWPAN_UDP) headers and put
    768           * them in sicslowpan_buf
    769           *
    770           * This function is called by the input function when the dispatch is
    771           * HC06.
    772           * We %process the packet in the rime buffer, uncompress the header
    773           * fields, and copy the result in the sicslowpan buffer.
    774           * At the end of the decompression, rime_hdr_len and uncompressed_hdr_len
    775           * are set to the appropriate values
    776           *
    777           * \param ip_len Equal to 0 if the packet is not a fragment (IP length
    778           * is then inferred from the L2 length), non 0 if the packet is a 1st
    779           * fragment.
    780           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    781          static void
    782          uncompress_hdr_hc06(uint16_t ip_len)
   \                     uncompress_hdr_hc06:
    783          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    784            uint8_t tmp, iphc0, iphc1;
    785            /* at least two byte will be used for the encoding */
    786            hc06_ptr = rime_ptr + rime_hdr_len + 2;
   \   00000E   90....       MOV     DPTR,#rime_hdr_len
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   7900         MOV     R1,#0x0
   \   000015   90....       MOV     DPTR,#rime_ptr
   \   000018   E0           MOVX    A,@DPTR
   \   000019   28           ADD     A,R0
   \   00001A   FA           MOV     R2,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   39           ADDC    A,R1
   \   00001E   8A82         MOV     DPL,R2
   \   000020   F583         MOV     DPH,A
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A882         MOV     R0,DPL
   \   000026   A983         MOV     R1,DPH
   \   000028   90....       MOV     DPTR,#hc06_ptr
   \   00002B   E8           MOV     A,R0
   \   00002C   F0           MOVX    @DPTR,A
   \   00002D   A3           INC     DPTR
   \   00002E   E9           MOV     A,R1
   \   00002F   F0           MOVX    @DPTR,A
    787          
    788            iphc0 = RIME_IPHC_BUF[0];
   \   000030   90....       MOV     DPTR,#rime_hdr_len
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   7900         MOV     R1,#0x0
   \   000037   90....       MOV     DPTR,#rime_ptr
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   28           ADD     A,R0
   \   00003C   FA           MOV     R2,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   39           ADDC    A,R1
   \   000040   8A82         MOV     DPL,R2
   \   000042   F583         MOV     DPH,A
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5..         MOV     ?V0 + 1,A
    789            iphc1 = RIME_IPHC_BUF[1];
   \   000047   90....       MOV     DPTR,#rime_hdr_len
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F8           MOV     R0,A
   \   00004C   7900         MOV     R1,#0x0
   \   00004E   90....       MOV     DPTR,#rime_ptr
   \   000051   E0           MOVX    A,@DPTR
   \   000052   28           ADD     A,R0
   \   000053   FA           MOV     R2,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   39           ADDC    A,R1
   \   000057   8A82         MOV     DPL,R2
   \   000059   F583         MOV     DPH,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   F5..         MOV     ?V0 + 0,A
    790          
    791            /* another if the CID flag is set */
    792            if(iphc1 & SICSLOWPAN_IPHC_CID) {
   \   00005F   E5..         MOV     A,?V0 + 0
   \   000061   A2E7         MOV     C,0xE0 /* A   */.7
   \   000063   5014         JNC     ??uncompress_hdr_hc06_0
    793              PRINTF("IPHC: CID flag set - increase header with one\n");
    794              hc06_ptr++;
   \   000065   90....       MOV     DPTR,#hc06_ptr
   \   000068   E0           MOVX    A,@DPTR
   \   000069   2401         ADD     A,#0x1
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   3400         ADDC    A,#0x0
   \   000070   F9           MOV     R1,A
   \   000071   90....       MOV     DPTR,#hc06_ptr
   \   000074   E8           MOV     A,R0
   \   000075   F0           MOVX    @DPTR,A
   \   000076   A3           INC     DPTR
   \   000077   E9           MOV     A,R1
   \   000078   F0           MOVX    @DPTR,A
    795            }
    796          
    797            /* Traffic class and flow label */
    798              if((iphc0 & SICSLOWPAN_IPHC_FL_C) == 0) {
   \                     ??uncompress_hdr_hc06_0:
   \   000079   E5..         MOV     A,?V0 + 1
   \   00007B   A2E4         MOV     C,0xE0 /* A   */.4
   \   00007D   5003         JNC     $+5
   \   00007F   02....       LJMP    ??uncompress_hdr_hc06_1 & 0xFFFF
    799                /* Flow label are carried inline */
    800                if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {
   \   000082   E5..         MOV     A,?V0 + 1
   \   000084   A2E3         MOV     C,0xE0 /* A   */.3
   \   000086   4073         JC      ??uncompress_hdr_hc06_2
    801                  /* Traffic class is carried inline */
    802                  memcpy(&SICSLOWPAN_IP_BUF->tcflow, hc06_ptr + 1, 3);
   \   000088                ; Setup parameters for call to function memcpy
   \   000088   75..03       MOV     ?V0 + 2,#0x3
   \   00008B   75..00       MOV     ?V0 + 3,#0x0
   \   00008E   78..         MOV     R0,#?V0 + 2
   \   000090   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000093   90....       MOV     DPTR,#hc06_ptr
   \   000096   E0           MOVX    A,@DPTR
   \   000097   2401         ADD     A,#0x1
   \   000099   FC           MOV     R4,A
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   3400         ADDC    A,#0x0
   \   00009E   FD           MOV     R5,A
   \   00009F   7A..         MOV     R2,#(uip_aligned_buf + 1) & 0xff
   \   0000A1   7B..         MOV     R3,#((uip_aligned_buf + 1) >> 8) & 0xff
   \   0000A3   12....       LCALL   ??memcpy?relay
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
    803                  tmp = *hc06_ptr;
   \   0000AB   90....       MOV     DPTR,#hc06_ptr
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F8           MOV     R0,A
   \   0000B0   A3           INC     DPTR
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   F583         MOV     DPH,A
   \   0000B4   8882         MOV     DPL,R0
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   F5..         MOV     ?V0 + 4,A
    804                  hc06_ptr += 4;
   \   0000B9   90....       MOV     DPTR,#hc06_ptr
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   2404         ADD     A,#0x4
   \   0000BF   F8           MOV     R0,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   3400         ADDC    A,#0x0
   \   0000C4   F9           MOV     R1,A
   \   0000C5   90....       MOV     DPTR,#hc06_ptr
   \   0000C8   E8           MOV     A,R0
   \   0000C9   F0           MOVX    @DPTR,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E9           MOV     A,R1
   \   0000CC   F0           MOVX    @DPTR,A
    805                  /* hc06 format of tc is ECN | DSCP , original is DSCP | ECN */
    806                  /* set version, pick highest DSCP bits and set in vtc */
    807                  SICSLOWPAN_IP_BUF->vtc = 0x60 | ((tmp >> 2) & 0x0f);
   \   0000CD   E5..         MOV     A,?V0 + 4
   \   0000CF   13           RRC     A
   \   0000D0   13           RRC     A
   \   0000D1   543F         ANL     A,#0x3f
   \   0000D3   540F         ANL     A,#0xf
   \   0000D5   4460         ORL     A,#0x60
   \   0000D7   90....       MOV     DPTR,#uip_aligned_buf
   \   0000DA   F0           MOVX    @DPTR,A
    808                  /* ECN rolled down two steps + lowest DSCP bits at top two bits */
    809                  SICSLOWPAN_IP_BUF->tcflow = ((tmp >> 2) & 0x30) | (tmp << 6) |
    810            	(SICSLOWPAN_IP_BUF->tcflow & 0x0f);
   \   0000DB   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   540F         ANL     A,#0xf
   \   0000E1   F9           MOV     R1,A
   \   0000E2   E5..         MOV     A,?V0 + 4
   \   0000E4   C4           SWAP    A
   \   0000E5   33           RLC     A
   \   0000E6   33           RLC     A
   \   0000E7   54C0         ANL     A,#0xc0
   \   0000E9   F8           MOV     R0,A
   \   0000EA   E5..         MOV     A,?V0 + 4
   \   0000EC   13           RRC     A
   \   0000ED   13           RRC     A
   \   0000EE   543F         ANL     A,#0x3f
   \   0000F0   5430         ANL     A,#0x30
   \   0000F2   48           ORL     A,R0
   \   0000F3   49           ORL     A,R1
   \   0000F4   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   0000F7   F0           MOVX    @DPTR,A
   \   0000F8   02....       LJMP    ??uncompress_hdr_hc06_3 & 0xFFFF
    811                } else {
    812                  /* Traffic class is compressed (set version and no TC)*/
    813                  SICSLOWPAN_IP_BUF->vtc = 0x60;
   \                     ??uncompress_hdr_hc06_2:
   \   0000FB   90....       MOV     DPTR,#uip_aligned_buf
   \   0000FE   7460         MOV     A,#0x60
   \   000100   F0           MOVX    @DPTR,A
    814                  /* highest flow label bits + ECN bits */
    815                  SICSLOWPAN_IP_BUF->tcflow = (*hc06_ptr & 0x0F) |
    816            	((*hc06_ptr >> 2) & 0x30);
   \   000101   90....       MOV     DPTR,#hc06_ptr
   \   000104   E0           MOVX    A,@DPTR
   \   000105   F8           MOV     R0,A
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   F583         MOV     DPH,A
   \   00010A   8882         MOV     DPL,R0
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   13           RRC     A
   \   00010E   13           RRC     A
   \   00010F   543F         ANL     A,#0x3f
   \   000111   5430         ANL     A,#0x30
   \   000113   F8           MOV     R0,A
   \   000114   90....       MOV     DPTR,#hc06_ptr
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   A3           INC     DPTR
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   F583         MOV     DPH,A
   \   00011D   8982         MOV     DPL,R1
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   540F         ANL     A,#0xf
   \   000122   48           ORL     A,R0
   \   000123   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   000126   F0           MOVX    @DPTR,A
    817                  memcpy(&SICSLOWPAN_IP_BUF->flow, hc06_ptr + 1, 2);
   \   000127                ; Setup parameters for call to function memcpy
   \   000127   75..02       MOV     ?V0 + 2,#0x2
   \   00012A   75..00       MOV     ?V0 + 3,#0x0
   \   00012D   78..         MOV     R0,#?V0 + 2
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000132   90....       MOV     DPTR,#hc06_ptr
   \   000135   E0           MOVX    A,@DPTR
   \   000136   2401         ADD     A,#0x1
   \   000138   FC           MOV     R4,A
   \   000139   A3           INC     DPTR
   \   00013A   E0           MOVX    A,@DPTR
   \   00013B   3400         ADDC    A,#0x0
   \   00013D   FD           MOV     R5,A
   \   00013E   7A..         MOV     R2,#(uip_aligned_buf + 2) & 0xff
   \   000140   7B..         MOV     R3,#((uip_aligned_buf + 2) >> 8) & 0xff
   \   000142   12....       LCALL   ??memcpy?relay
   \   000145   7402         MOV     A,#0x2
   \   000147   12....       LCALL   ?DEALLOC_XSTACK8
    818                  hc06_ptr += 3;
   \   00014A   90....       MOV     DPTR,#hc06_ptr
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   2403         ADD     A,#0x3
   \   000150   F8           MOV     R0,A
   \   000151   A3           INC     DPTR
   \   000152   E0           MOVX    A,@DPTR
   \   000153   3400         ADDC    A,#0x0
   \   000155   F9           MOV     R1,A
   \   000156   90....       MOV     DPTR,#hc06_ptr
   \   000159   E8           MOV     A,R0
   \   00015A   F0           MOVX    @DPTR,A
   \   00015B   A3           INC     DPTR
   \   00015C   E9           MOV     A,R1
   \   00015D   F0           MOVX    @DPTR,A
   \   00015E   807D         SJMP    ??uncompress_hdr_hc06_3
    819                }
    820              } else {
    821                /* Version is always 6! */
    822                /* Version and flow label are compressed */
    823                if((iphc0 & SICSLOWPAN_IPHC_TC_C) == 0) {
   \                     ??uncompress_hdr_hc06_1:
   \   000160   E5..         MOV     A,?V0 + 1
   \   000162   A2E3         MOV     C,0xE0 /* A   */.3
   \   000164   4061         JC      ??uncompress_hdr_hc06_4
    824                  /* Traffic class is inline */
    825                    SICSLOWPAN_IP_BUF->vtc = 0x60 | ((*hc06_ptr >> 2) & 0x0f);
   \   000166   90....       MOV     DPTR,#hc06_ptr
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   F8           MOV     R0,A
   \   00016B   A3           INC     DPTR
   \   00016C   E0           MOVX    A,@DPTR
   \   00016D   F583         MOV     DPH,A
   \   00016F   8882         MOV     DPL,R0
   \   000171   E0           MOVX    A,@DPTR
   \   000172   13           RRC     A
   \   000173   13           RRC     A
   \   000174   543F         ANL     A,#0x3f
   \   000176   540F         ANL     A,#0xf
   \   000178   4460         ORL     A,#0x60
   \   00017A   90....       MOV     DPTR,#uip_aligned_buf
   \   00017D   F0           MOVX    @DPTR,A
    826                    SICSLOWPAN_IP_BUF->tcflow = ((*hc06_ptr << 6) & 0xC0) | ((*hc06_ptr >> 2) & 0x30);
   \   00017E   90....       MOV     DPTR,#hc06_ptr
   \   000181   E0           MOVX    A,@DPTR
   \   000182   F8           MOV     R0,A
   \   000183   A3           INC     DPTR
   \   000184   E0           MOVX    A,@DPTR
   \   000185   F583         MOV     DPH,A
   \   000187   8882         MOV     DPL,R0
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   13           RRC     A
   \   00018B   13           RRC     A
   \   00018C   543F         ANL     A,#0x3f
   \   00018E   5430         ANL     A,#0x30
   \   000190   F8           MOV     R0,A
   \   000191   90....       MOV     DPTR,#hc06_ptr
   \   000194   E0           MOVX    A,@DPTR
   \   000195   F9           MOV     R1,A
   \   000196   A3           INC     DPTR
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F583         MOV     DPH,A
   \   00019A   8982         MOV     DPL,R1
   \   00019C   E0           MOVX    A,@DPTR
   \   00019D   C4           SWAP    A
   \   00019E   33           RLC     A
   \   00019F   33           RLC     A
   \   0001A0   54C0         ANL     A,#0xc0
   \   0001A2   48           ORL     A,R0
   \   0001A3   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   0001A6   F0           MOVX    @DPTR,A
    827                    SICSLOWPAN_IP_BUF->flow = 0;
   \   0001A7   90....       MOV     DPTR,#uip_aligned_buf + 2
   \   0001AA   7400         MOV     A,#0x0
   \   0001AC   F0           MOVX    @DPTR,A
   \   0001AD   A3           INC     DPTR
   \   0001AE   7400         MOV     A,#0x0
   \   0001B0   F0           MOVX    @DPTR,A
    828                    hc06_ptr += 1;
   \   0001B1   90....       MOV     DPTR,#hc06_ptr
   \   0001B4   E0           MOVX    A,@DPTR
   \   0001B5   2401         ADD     A,#0x1
   \   0001B7   F8           MOV     R0,A
   \   0001B8   A3           INC     DPTR
   \   0001B9   E0           MOVX    A,@DPTR
   \   0001BA   3400         ADDC    A,#0x0
   \   0001BC   F9           MOV     R1,A
   \   0001BD   90....       MOV     DPTR,#hc06_ptr
   \   0001C0   E8           MOV     A,R0
   \   0001C1   F0           MOVX    @DPTR,A
   \   0001C2   A3           INC     DPTR
   \   0001C3   E9           MOV     A,R1
   \   0001C4   F0           MOVX    @DPTR,A
   \   0001C5   8016         SJMP    ??uncompress_hdr_hc06_3
    829                } else {
    830                  /* Traffic class is compressed */
    831                  SICSLOWPAN_IP_BUF->vtc = 0x60;
   \                     ??uncompress_hdr_hc06_4:
   \   0001C7   90....       MOV     DPTR,#uip_aligned_buf
   \   0001CA   7460         MOV     A,#0x60
   \   0001CC   F0           MOVX    @DPTR,A
    832                  SICSLOWPAN_IP_BUF->tcflow = 0;
   \   0001CD   90....       MOV     DPTR,#uip_aligned_buf + 1
   \   0001D0   7400         MOV     A,#0x0
   \   0001D2   F0           MOVX    @DPTR,A
    833                  SICSLOWPAN_IP_BUF->flow = 0;
   \   0001D3   90....       MOV     DPTR,#uip_aligned_buf + 2
   \   0001D6   7400         MOV     A,#0x0
   \   0001D8   F0           MOVX    @DPTR,A
   \   0001D9   A3           INC     DPTR
   \   0001DA   7400         MOV     A,#0x0
   \   0001DC   F0           MOVX    @DPTR,A
    834                }
    835              }
    836          
    837            /* Next Header */
    838            if((iphc0 & SICSLOWPAN_IPHC_NH_C) == 0) {
   \                     ??uncompress_hdr_hc06_3:
   \   0001DD   E5..         MOV     A,?V0 + 1
   \   0001DF   A2E2         MOV     C,0xE0 /* A   */.2
   \   0001E1   4024         JC      ??uncompress_hdr_hc06_5
    839              /* Next header is carried inline */
    840              SICSLOWPAN_IP_BUF->proto = *hc06_ptr;
   \   0001E3   90....       MOV     DPTR,#hc06_ptr
   \   0001E6   E0           MOVX    A,@DPTR
   \   0001E7   F8           MOV     R0,A
   \   0001E8   A3           INC     DPTR
   \   0001E9   E0           MOVX    A,@DPTR
   \   0001EA   F583         MOV     DPH,A
   \   0001EC   8882         MOV     DPL,R0
   \   0001EE   E0           MOVX    A,@DPTR
   \   0001EF   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   0001F2   F0           MOVX    @DPTR,A
    841              PRINTF("IPHC: next header inline: %d\n", SICSLOWPAN_IP_BUF->proto);
    842              hc06_ptr += 1;
   \   0001F3   90....       MOV     DPTR,#hc06_ptr
   \   0001F6   E0           MOVX    A,@DPTR
   \   0001F7   2401         ADD     A,#0x1
   \   0001F9   F8           MOV     R0,A
   \   0001FA   A3           INC     DPTR
   \   0001FB   E0           MOVX    A,@DPTR
   \   0001FC   3400         ADDC    A,#0x0
   \   0001FE   F9           MOV     R1,A
   \   0001FF   90....       MOV     DPTR,#hc06_ptr
   \   000202   E8           MOV     A,R0
   \   000203   F0           MOVX    @DPTR,A
   \   000204   A3           INC     DPTR
   \   000205   E9           MOV     A,R1
   \   000206   F0           MOVX    @DPTR,A
    843            }
    844          
    845            /* Hop limit */
    846            if((iphc0 & 0x03) != SICSLOWPAN_IPHC_TTL_I) {
   \                     ??uncompress_hdr_hc06_5:
   \   000207   7403         MOV     A,#0x3
   \   000209   55..         ANL     A,?V0 + 1
   \   00020B   6021         JZ      ??uncompress_hdr_hc06_6
    847              SICSLOWPAN_IP_BUF->ttl = ttl_values[iphc0 & 0x03];
   \   00020D   85....       MOV     ?V0 + 2,?V0 + 1
   \   000210   75..00       MOV     ?V0 + 3,#0x0
   \   000213   E5..         MOV     A,?V0 + 2
   \   000215   5403         ANL     A,#0x3
   \   000217   F8           MOV     R0,A
   \   000218   E5..         MOV     A,?V0 + 3
   \   00021A   5400         ANL     A,#0x0
   \   00021C   F9           MOV     R1,A
   \   00021D   74..         MOV     A,#ttl_values & 0xff
   \   00021F   28           ADD     A,R0
   \   000220   F582         MOV     DPL,A
   \   000222   74..         MOV     A,#(ttl_values >> 8) & 0xff
   \   000224   39           ADDC    A,R1
   \   000225   F583         MOV     DPH,A
   \   000227   E0           MOVX    A,@DPTR
   \   000228   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   00022B   F0           MOVX    @DPTR,A
   \   00022C   8024         SJMP    ??uncompress_hdr_hc06_7
    848            } else {
    849              SICSLOWPAN_IP_BUF->ttl = *hc06_ptr;
   \                     ??uncompress_hdr_hc06_6:
   \   00022E   90....       MOV     DPTR,#hc06_ptr
   \   000231   E0           MOVX    A,@DPTR
   \   000232   F8           MOV     R0,A
   \   000233   A3           INC     DPTR
   \   000234   E0           MOVX    A,@DPTR
   \   000235   F583         MOV     DPH,A
   \   000237   8882         MOV     DPL,R0
   \   000239   E0           MOVX    A,@DPTR
   \   00023A   90....       MOV     DPTR,#uip_aligned_buf + 7
   \   00023D   F0           MOVX    @DPTR,A
    850              hc06_ptr += 1;
   \   00023E   90....       MOV     DPTR,#hc06_ptr
   \   000241   E0           MOVX    A,@DPTR
   \   000242   2401         ADD     A,#0x1
   \   000244   F8           MOV     R0,A
   \   000245   A3           INC     DPTR
   \   000246   E0           MOVX    A,@DPTR
   \   000247   3400         ADDC    A,#0x0
   \   000249   F9           MOV     R1,A
   \   00024A   90....       MOV     DPTR,#hc06_ptr
   \   00024D   E8           MOV     A,R0
   \   00024E   F0           MOVX    @DPTR,A
   \   00024F   A3           INC     DPTR
   \   000250   E9           MOV     A,R1
   \   000251   F0           MOVX    @DPTR,A
    851            }
    852          
    853            /* put the source address compression mode SAM in the tmp var */
    854            tmp = ((iphc1 & SICSLOWPAN_IPHC_SAM_11) >> SICSLOWPAN_IPHC_SAM_BIT) & 0x03;
   \                     ??uncompress_hdr_hc06_7:
   \   000252   E5..         MOV     A,?V0 + 0
   \   000254   C4           SWAP    A
   \   000255   540F         ANL     A,#0xf
   \   000257   5403         ANL     A,#0x3
   \   000259   F5..         MOV     ?V0 + 4,A
    855          
    856            /* context based compression */
    857            if(iphc1 & SICSLOWPAN_IPHC_SAC) {
   \   00025B   E5..         MOV     A,?V0 + 0
   \   00025D   A2E6         MOV     C,0xE0 /* A   */.6
   \   00025F   4003         JC      $+5
   \   000261   02....       LJMP    ??uncompress_hdr_hc06_8 & 0xFFFF
    858              uint8_t sci = (iphc1 & SICSLOWPAN_IPHC_CID) ?
    859                RIME_IPHC_BUF[2] >> 4 : 0;
   \   000264   E5..         MOV     A,?V0 + 0
   \   000266   A2E7         MOV     C,0xE0 /* A   */.7
   \   000268   501C         JNC     ??uncompress_hdr_hc06_9
   \   00026A   90....       MOV     DPTR,#rime_hdr_len
   \   00026D   E0           MOVX    A,@DPTR
   \   00026E   F8           MOV     R0,A
   \   00026F   7900         MOV     R1,#0x0
   \   000271   90....       MOV     DPTR,#rime_ptr
   \   000274   E0           MOVX    A,@DPTR
   \   000275   28           ADD     A,R0
   \   000276   FA           MOV     R2,A
   \   000277   A3           INC     DPTR
   \   000278   E0           MOVX    A,@DPTR
   \   000279   39           ADDC    A,R1
   \   00027A   8A82         MOV     DPL,R2
   \   00027C   F583         MOV     DPH,A
   \   00027E   A3           INC     DPTR
   \   00027F   A3           INC     DPTR
   \   000280   E0           MOVX    A,@DPTR
   \   000281   C4           SWAP    A
   \   000282   540F         ANL     A,#0xf
   \   000284   8002         SJMP    ??uncompress_hdr_hc06_10
   \                     ??uncompress_hdr_hc06_9:
   \   000286   7400         MOV     A,#0x0
   \                     ??uncompress_hdr_hc06_10:
   \   000288   F5..         MOV     ?V0 + 2,A
    860          
    861              /* Source address - check context != NULL only if SAM bits are != 0*/
    862              if (tmp != 0) {
   \   00028A   E5..         MOV     A,?V0 + 4
   \   00028C   601C         JZ      ??uncompress_hdr_hc06_11
    863                context = addr_context_lookup_by_number(sci);
   \   00028E                ; Setup parameters for call to function addr_context_lookup_by_number
   \   00028E   A9..         MOV     R1,?V0 + 2
   \   000290   12....       LCALL   ??addr_context_lookup_by_number?relay
   \   000293   90....       MOV     DPTR,#context
   \   000296   EA           MOV     A,R2
   \   000297   F0           MOVX    @DPTR,A
   \   000298   A3           INC     DPTR
   \   000299   EB           MOV     A,R3
   \   00029A   F0           MOVX    @DPTR,A
    864                if(context == NULL) {
   \   00029B   90....       MOV     DPTR,#context
   \   00029E   E0           MOVX    A,@DPTR
   \   00029F   F8           MOV     R0,A
   \   0002A0   A3           INC     DPTR
   \   0002A1   E0           MOVX    A,@DPTR
   \   0002A2   F9           MOV     R1,A
   \   0002A3   E8           MOV     A,R0
   \   0002A4   49           ORL     A,R1
   \   0002A5   7003         JNZ     $+5
   \   0002A7   02....       LJMP    ??uncompress_hdr_hc06_12 & 0xFFFF
    865                  PRINTF("sicslowpan uncompress_hdr: error context not found\n");
    866                  return;
    867                }
    868              }
    869              /* if tmp == 0 we do not have a context and therefore no prefix */
    870              uncompress_addr(&SICSLOWPAN_IP_BUF->srcipaddr,
    871                              tmp != 0 ? context->prefix : NULL, unc_ctxconf[tmp],
    872                              (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
   \                     ??uncompress_hdr_hc06_11:
   \   0002AA                ; Setup parameters for call to function packetbuf_addr
   \   0002AA   7918         MOV     R1,#0x18
   \   0002AC   12....       LCALL   ??packetbuf_addr?relay
   \   0002AF   8A..         MOV     ?V0 + 8,R2
   \   0002B1   8B..         MOV     ?V0 + 9,R3
   \   0002B3   85....       MOV     ?V0 + 6,?V0 + 8
   \   0002B6   85....       MOV     ?V0 + 7,?V0 + 9
   \   0002B9   E5..         MOV     A,?V0 + 4
   \   0002BB   600E         JZ      ??uncompress_hdr_hc06_13
   \   0002BD   90....       MOV     DPTR,#context
   \   0002C0   E0           MOVX    A,@DPTR
   \   0002C1   2402         ADD     A,#0x2
   \   0002C3   FC           MOV     R4,A
   \   0002C4   A3           INC     DPTR
   \   0002C5   E0           MOVX    A,@DPTR
   \   0002C6   3400         ADDC    A,#0x0
   \   0002C8   FD           MOV     R5,A
   \   0002C9   8004         SJMP    ??uncompress_hdr_hc06_14
   \                     ??uncompress_hdr_hc06_13:
   \   0002CB   7C00         MOV     R4,#0x0
   \   0002CD   7D00         MOV     R5,#0x0
   \                     ??uncompress_hdr_hc06_14:
   \   0002CF                ; Setup parameters for call to function uncompress_addr
   \   0002CF   78..         MOV     R0,#?V0 + 6
   \   0002D1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002D4   75..00       MOV     ?V0 + 5,#0x0
   \   0002D7   74..         MOV     A,#unc_ctxconf & 0xff
   \   0002D9   25..         ADD     A,?V0 + 4
   \   0002DB   F582         MOV     DPL,A
   \   0002DD   74..         MOV     A,#(unc_ctxconf >> 8) & 0xff
   \   0002DF   35..         ADDC    A,?V0 + 5
   \   0002E1   F583         MOV     DPH,A
   \   0002E3   E0           MOVX    A,@DPTR
   \   0002E4   F9           MOV     R1,A
   \   0002E5   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   0002E7   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   0002E9   12....       LCALL   ??uncompress_addr?relay
   \   0002EC   7402         MOV     A,#0x2
   \   0002EE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002F1   8035         SJMP    ??uncompress_hdr_hc06_15
    873            } else {
    874              /* no compression and link local */
    875              uncompress_addr(&SICSLOWPAN_IP_BUF->srcipaddr, llprefix, unc_llconf[tmp],
    876                              (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
   \                     ??uncompress_hdr_hc06_8:
   \   0002F3                ; Setup parameters for call to function packetbuf_addr
   \   0002F3   7918         MOV     R1,#0x18
   \   0002F5   12....       LCALL   ??packetbuf_addr?relay
   \   0002F8   8A..         MOV     ?V0 + 8,R2
   \   0002FA   8B..         MOV     ?V0 + 9,R3
   \   0002FC   85....       MOV     ?V0 + 6,?V0 + 8
   \   0002FF   85....       MOV     ?V0 + 7,?V0 + 9
   \   000302                ; Setup parameters for call to function uncompress_addr
   \   000302   78..         MOV     R0,#?V0 + 6
   \   000304   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000307   75..00       MOV     ?V0 + 5,#0x0
   \   00030A   74..         MOV     A,#unc_llconf & 0xff
   \   00030C   25..         ADD     A,?V0 + 4
   \   00030E   F582         MOV     DPL,A
   \   000310   74..         MOV     A,#(unc_llconf >> 8) & 0xff
   \   000312   35..         ADDC    A,?V0 + 5
   \   000314   F583         MOV     DPH,A
   \   000316   E0           MOVX    A,@DPTR
   \   000317   F9           MOV     R1,A
   \   000318   7C..         MOV     R4,#llprefix & 0xff
   \   00031A   7D..         MOV     R5,#(llprefix >> 8) & 0xff
   \   00031C   7A..         MOV     R2,#(uip_aligned_buf + 8) & 0xff
   \   00031E   7B..         MOV     R3,#((uip_aligned_buf + 8) >> 8) & 0xff
   \   000320   12....       LCALL   ??uncompress_addr?relay
   \   000323   7402         MOV     A,#0x2
   \   000325   12....       LCALL   ?DEALLOC_XSTACK8
    877            }
    878          
    879            /* Destination address */
    880            /* put the destination address compression mode into tmp */
    881            tmp = ((iphc1 & SICSLOWPAN_IPHC_DAM_11) >> SICSLOWPAN_IPHC_DAM_BIT) & 0x03;
   \                     ??uncompress_hdr_hc06_15:
   \   000328   7403         MOV     A,#0x3
   \   00032A   55..         ANL     A,?V0 + 0
   \   00032C   F5..         MOV     ?V0 + 4,A
    882          
    883            /* multicast compression */
    884            if(iphc1 & SICSLOWPAN_IPHC_M) {
   \   00032E   E5..         MOV     A,?V0 + 0
   \   000330   A2E3         MOV     C,0xE0 /* A   */.3
   \   000332   4003         JC      $+5
   \   000334   02....       LJMP    ??uncompress_hdr_hc06_16 & 0xFFFF
    885              /* context based multicast compression */
    886              if(iphc1 & SICSLOWPAN_IPHC_DAC) {
   \   000337   E5..         MOV     A,?V0 + 0
   \   000339   A2E2         MOV     C,0xE0 /* A   */.2
   \   00033B   5003         JNC     $+5
   \   00033D   02....       LJMP    ??uncompress_hdr_hc06_17 & 0xFFFF
    887                /* TODO: implement this */
    888              } else {
    889                /* non-context based multicast compression - */
    890                /* DAM_00: 128 bits  */
    891                /* DAM_01:  48 bits FFXX::00XX:XXXX:XXXX */
    892                /* DAM_10:  32 bits FFXX::00XX:XXXX */
    893                /* DAM_11:   8 bits FF02::00XX */
    894                uint8_t prefix[] = {0xff, 0x02};
   \   000340   90....       MOV     DPTR,#`?<Constant {255, 2}>`
   \   000343   C082         PUSH    DPL
   \   000345   C083         PUSH    DPH
   \   000347   85..82       MOV     DPL,?XSP + 0
   \   00034A   85..83       MOV     DPH,?XSP + 1
   \   00034D   AC82         MOV     R4,DPL
   \   00034F   AD83         MOV     R5,DPH
   \   000351   D083         POP     DPH
   \   000353   D082         POP     DPL
   \   000355   7402         MOV     A,#0x2
   \   000357   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    895                if(tmp > 0 && tmp < 3) {
   \   00035A   E5..         MOV     A,?V0 + 4
   \   00035C   C3           CLR     C
   \   00035D   9401         SUBB    A,#0x1
   \   00035F   C3           CLR     C
   \   000360   9402         SUBB    A,#0x2
   \   000362   502A         JNC     ??uncompress_hdr_hc06_18
    896                  prefix[1] = *hc06_ptr;
   \   000364   90....       MOV     DPTR,#hc06_ptr
   \   000367   E0           MOVX    A,@DPTR
   \   000368   F8           MOV     R0,A
   \   000369   A3           INC     DPTR
   \   00036A   E0           MOVX    A,@DPTR
   \   00036B   F583         MOV     DPH,A
   \   00036D   8882         MOV     DPL,R0
   \   00036F   E0           MOVX    A,@DPTR
   \   000370   C0E0         PUSH    A
   \   000372   7401         MOV     A,#0x1
   \   000374   12....       LCALL   ?XSTACK_DISP0_8
   \   000377   D0E0         POP     A
   \   000379   F0           MOVX    @DPTR,A
    897                  hc06_ptr++;
   \   00037A   90....       MOV     DPTR,#hc06_ptr
   \   00037D   E0           MOVX    A,@DPTR
   \   00037E   2401         ADD     A,#0x1
   \   000380   F8           MOV     R0,A
   \   000381   A3           INC     DPTR
   \   000382   E0           MOVX    A,@DPTR
   \   000383   3400         ADDC    A,#0x0
   \   000385   F9           MOV     R1,A
   \   000386   90....       MOV     DPTR,#hc06_ptr
   \   000389   E8           MOV     A,R0
   \   00038A   F0           MOVX    @DPTR,A
   \   00038B   A3           INC     DPTR
   \   00038C   E9           MOV     A,R1
   \   00038D   F0           MOVX    @DPTR,A
    898                }
    899          
    900                uncompress_addr(&SICSLOWPAN_IP_BUF->destipaddr, prefix,
    901                                unc_mxconf[tmp], NULL);
   \                     ??uncompress_hdr_hc06_18:
   \   00038E                ; Setup parameters for call to function uncompress_addr
   \   00038E   E4           CLR     A
   \   00038F   F5..         MOV     ?V0 + 6,A
   \   000391   F5..         MOV     ?V0 + 7,A
   \   000393   78..         MOV     R0,#?V0 + 6
   \   000395   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000398   75..00       MOV     ?V0 + 5,#0x0
   \   00039B   74..         MOV     A,#unc_mxconf & 0xff
   \   00039D   25..         ADD     A,?V0 + 4
   \   00039F   F582         MOV     DPL,A
   \   0003A1   74..         MOV     A,#(unc_mxconf >> 8) & 0xff
   \   0003A3   35..         ADDC    A,?V0 + 5
   \   0003A5   F583         MOV     DPH,A
   \   0003A7   E0           MOVX    A,@DPTR
   \   0003A8   F9           MOV     R1,A
   \   0003A9   7402         MOV     A,#0x2
   \   0003AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003AE   AC82         MOV     R4,DPL
   \   0003B0   AD83         MOV     R5,DPH
   \   0003B2   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   0003B4   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   0003B6   12....       LCALL   ??uncompress_addr?relay
   \   0003B9   7402         MOV     A,#0x2
   \   0003BB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0003BE   02....       LJMP    ??uncompress_hdr_hc06_17 & 0xFFFF
    902              }
    903            } else {
    904              /* no multicast */
    905              /* Context based */
    906              if(iphc1 & SICSLOWPAN_IPHC_DAC) {
   \                     ??uncompress_hdr_hc06_16:
   \   0003C1   E5..         MOV     A,?V0 + 0
   \   0003C3   A2E2         MOV     C,0xE0 /* A   */.2
   \   0003C5   4003         JC      $+5
   \   0003C7   02....       LJMP    ??uncompress_hdr_hc06_19 & 0xFFFF
    907                uint8_t dci = (iphc1 & SICSLOWPAN_IPHC_CID) ?
    908          	RIME_IPHC_BUF[2] & 0x0f : 0;
   \   0003CA   E5..         MOV     A,?V0 + 0
   \   0003CC   A2E7         MOV     C,0xE0 /* A   */.7
   \   0003CE   501B         JNC     ??uncompress_hdr_hc06_20
   \   0003D0   90....       MOV     DPTR,#rime_hdr_len
   \   0003D3   E0           MOVX    A,@DPTR
   \   0003D4   F8           MOV     R0,A
   \   0003D5   7900         MOV     R1,#0x0
   \   0003D7   90....       MOV     DPTR,#rime_ptr
   \   0003DA   E0           MOVX    A,@DPTR
   \   0003DB   28           ADD     A,R0
   \   0003DC   FA           MOV     R2,A
   \   0003DD   A3           INC     DPTR
   \   0003DE   E0           MOVX    A,@DPTR
   \   0003DF   39           ADDC    A,R1
   \   0003E0   8A82         MOV     DPL,R2
   \   0003E2   F583         MOV     DPH,A
   \   0003E4   A3           INC     DPTR
   \   0003E5   A3           INC     DPTR
   \   0003E6   E0           MOVX    A,@DPTR
   \   0003E7   540F         ANL     A,#0xf
   \   0003E9   8002         SJMP    ??uncompress_hdr_hc06_21
   \                     ??uncompress_hdr_hc06_20:
   \   0003EB   7400         MOV     A,#0x0
   \                     ??uncompress_hdr_hc06_21:
   \   0003ED   F5..         MOV     ?V0 + 0,A
    909                context = addr_context_lookup_by_number(dci);
   \   0003EF                ; Setup parameters for call to function addr_context_lookup_by_number
   \   0003EF   A9..         MOV     R1,?V0 + 0
   \   0003F1   12....       LCALL   ??addr_context_lookup_by_number?relay
   \   0003F4   90....       MOV     DPTR,#context
   \   0003F7   EA           MOV     A,R2
   \   0003F8   F0           MOVX    @DPTR,A
   \   0003F9   A3           INC     DPTR
   \   0003FA   EB           MOV     A,R3
   \   0003FB   F0           MOVX    @DPTR,A
    910          
    911                /* all valid cases below need the context! */
    912                if(context == NULL) {
   \   0003FC   90....       MOV     DPTR,#context
   \   0003FF   E0           MOVX    A,@DPTR
   \   000400   F8           MOV     R0,A
   \   000401   A3           INC     DPTR
   \   000402   E0           MOVX    A,@DPTR
   \   000403   F9           MOV     R1,A
   \   000404   E8           MOV     A,R0
   \   000405   49           ORL     A,R1
   \   000406   7003         JNZ     $+5
   \   000408   02....       LJMP    ??uncompress_hdr_hc06_12 & 0xFFFF
    913          	PRINTF("sicslowpan uncompress_hdr: error context not found\n");
    914          	return;
    915                }
    916                uncompress_addr(&SICSLOWPAN_IP_BUF->destipaddr, context->prefix,
    917                                unc_ctxconf[tmp],
    918                                (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
   \   00040B                ; Setup parameters for call to function packetbuf_addr
   \   00040B   7919         MOV     R1,#0x19
   \   00040D   12....       LCALL   ??packetbuf_addr?relay
   \   000410   8A..         MOV     ?V0 + 8,R2
   \   000412   8B..         MOV     ?V0 + 9,R3
   \   000414   85....       MOV     ?V0 + 6,?V0 + 8
   \   000417   85....       MOV     ?V0 + 7,?V0 + 9
   \   00041A                ; Setup parameters for call to function uncompress_addr
   \   00041A   78..         MOV     R0,#?V0 + 6
   \   00041C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00041F   75..00       MOV     ?V0 + 5,#0x0
   \   000422   74..         MOV     A,#unc_ctxconf & 0xff
   \   000424   25..         ADD     A,?V0 + 4
   \   000426   F582         MOV     DPL,A
   \   000428   74..         MOV     A,#(unc_ctxconf >> 8) & 0xff
   \   00042A   35..         ADDC    A,?V0 + 5
   \   00042C   F583         MOV     DPH,A
   \   00042E   E0           MOVX    A,@DPTR
   \   00042F   F9           MOV     R1,A
   \   000430   90....       MOV     DPTR,#context
   \   000433   E0           MOVX    A,@DPTR
   \   000434   2402         ADD     A,#0x2
   \   000436   FC           MOV     R4,A
   \   000437   A3           INC     DPTR
   \   000438   E0           MOVX    A,@DPTR
   \   000439   3400         ADDC    A,#0x0
   \   00043B   FD           MOV     R5,A
   \   00043C   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   00043E   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000440   12....       LCALL   ??uncompress_addr?relay
   \   000443   7402         MOV     A,#0x2
   \   000445   12....       LCALL   ?DEALLOC_XSTACK8
   \   000448   8035         SJMP    ??uncompress_hdr_hc06_17
    919              } else {
    920                /* not context based => link local M = 0, DAC = 0 - same as SAC */
    921                uncompress_addr(&SICSLOWPAN_IP_BUF->destipaddr, llprefix,
    922                                unc_llconf[tmp],
    923                                (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
   \                     ??uncompress_hdr_hc06_19:
   \   00044A                ; Setup parameters for call to function packetbuf_addr
   \   00044A   7919         MOV     R1,#0x19
   \   00044C   12....       LCALL   ??packetbuf_addr?relay
   \   00044F   8A..         MOV     ?V0 + 8,R2
   \   000451   8B..         MOV     ?V0 + 9,R3
   \   000453   85....       MOV     ?V0 + 6,?V0 + 8
   \   000456   85....       MOV     ?V0 + 7,?V0 + 9
   \   000459                ; Setup parameters for call to function uncompress_addr
   \   000459   78..         MOV     R0,#?V0 + 6
   \   00045B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00045E   75..00       MOV     ?V0 + 5,#0x0
   \   000461   74..         MOV     A,#unc_llconf & 0xff
   \   000463   25..         ADD     A,?V0 + 4
   \   000465   F582         MOV     DPL,A
   \   000467   74..         MOV     A,#(unc_llconf >> 8) & 0xff
   \   000469   35..         ADDC    A,?V0 + 5
   \   00046B   F583         MOV     DPH,A
   \   00046D   E0           MOVX    A,@DPTR
   \   00046E   F9           MOV     R1,A
   \   00046F   7C..         MOV     R4,#llprefix & 0xff
   \   000471   7D..         MOV     R5,#(llprefix >> 8) & 0xff
   \   000473   7A..         MOV     R2,#(uip_aligned_buf + 24) & 0xff
   \   000475   7B..         MOV     R3,#((uip_aligned_buf + 24) >> 8) & 0xff
   \   000477   12....       LCALL   ??uncompress_addr?relay
   \   00047A   7402         MOV     A,#0x2
   \   00047C   12....       LCALL   ?DEALLOC_XSTACK8
    924              }
    925            }
    926            uncomp_hdr_len += UIP_IPH_LEN;
   \                     ??uncompress_hdr_hc06_17:
   \   00047F   90....       MOV     DPTR,#uncomp_hdr_len
   \   000482   E0           MOVX    A,@DPTR
   \   000483   2428         ADD     A,#0x28
   \   000485   F0           MOVX    @DPTR,A
    927          
    928            /* Next header processing - continued */
    929            if((iphc0 & SICSLOWPAN_IPHC_NH_C)) {
   \   000486   E5..         MOV     A,?V0 + 1
   \   000488   A2E2         MOV     C,0xE0 /* A   */.2
   \   00048A   4003         JC      $+5
   \   00048C   02....       LJMP    ??uncompress_hdr_hc06_22 & 0xFFFF
    930              /* The next header is compressed, NHC is following */
    931              if((*hc06_ptr & SICSLOWPAN_NHC_UDP_MASK) == SICSLOWPAN_NHC_UDP_ID) {
   \   00048F   90....       MOV     DPTR,#hc06_ptr
   \   000492   E0           MOVX    A,@DPTR
   \   000493   F8           MOV     R0,A
   \   000494   A3           INC     DPTR
   \   000495   E0           MOVX    A,@DPTR
   \   000496   F583         MOV     DPH,A
   \   000498   8882         MOV     DPL,R0
   \   00049A   E0           MOVX    A,@DPTR
   \   00049B   54F8         ANL     A,#0xf8
   \   00049D   64F0         XRL     A,#0xf0
   \   00049F   6003         JZ      $+5
   \   0004A1   02....       LJMP    ??uncompress_hdr_hc06_22 & 0xFFFF
    932                uint8_t checksum_compressed;
    933                SICSLOWPAN_IP_BUF->proto = UIP_PROTO_UDP;
   \   0004A4   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   0004A7   7411         MOV     A,#0x11
   \   0004A9   F0           MOVX    @DPTR,A
    934                checksum_compressed = *hc06_ptr & SICSLOWPAN_NHC_UDP_CHECKSUMC;
   \   0004AA   90....       MOV     DPTR,#hc06_ptr
   \   0004AD   E0           MOVX    A,@DPTR
   \   0004AE   F8           MOV     R0,A
   \   0004AF   A3           INC     DPTR
   \   0004B0   E0           MOVX    A,@DPTR
   \   0004B1   F583         MOV     DPH,A
   \   0004B3   8882         MOV     DPL,R0
   \   0004B5   E0           MOVX    A,@DPTR
   \   0004B6   5404         ANL     A,#0x4
   \   0004B8   F5..         MOV     ?V0 + 1,A
    935                PRINTF("IPHC: Incoming header value: %i\n", *hc06_ptr);
    936                switch(*hc06_ptr & SICSLOWPAN_NHC_UDP_CS_P_11) {
   \   0004BA   90....       MOV     DPTR,#hc06_ptr
   \   0004BD   E0           MOVX    A,@DPTR
   \   0004BE   F8           MOV     R0,A
   \   0004BF   A3           INC     DPTR
   \   0004C0   E0           MOVX    A,@DPTR
   \   0004C1   F583         MOV     DPH,A
   \   0004C3   8882         MOV     DPL,R0
   \   0004C5   E0           MOVX    A,@DPTR
   \   0004C6   F8           MOV     R0,A
   \   0004C7   7900         MOV     R1,#0x0
   \   0004C9   54F3         ANL     A,#0xf3
   \   0004CB   F8           MOV     R0,A
   \   0004CC   E9           MOV     A,R1
   \   0004CD   5400         ANL     A,#0x0
   \   0004CF   F9           MOV     R1,A
   \   0004D0   E8           MOV     A,R0
   \   0004D1   2410         ADD     A,#0x10
   \   0004D3   6015         JZ      ??uncompress_hdr_hc06_23
   \   0004D5   14           DEC     A
   \   0004D6   7003         JNZ     $+5
   \   0004D8   02....       LJMP    ??uncompress_hdr_hc06_24 & 0xFFFF
   \   0004DB   14           DEC     A
   \   0004DC   7003         JNZ     $+5
   \   0004DE   02....       LJMP    ??uncompress_hdr_hc06_25 & 0xFFFF
   \   0004E1   14           DEC     A
   \   0004E2   7003         JNZ     $+5
   \   0004E4   02....       LJMP    ??uncompress_hdr_hc06_26 & 0xFFFF
   \   0004E7   02....       LJMP    ??uncompress_hdr_hc06_12 & 0xFFFF
    937                case SICSLOWPAN_NHC_UDP_CS_P_00:
    938          	/* 1 byte for NHC, 4 byte for ports, 2 bytes chksum */
    939          	memcpy(&SICSLOWPAN_UDP_BUF->srcport, hc06_ptr + 1, 2);
   \                     ??uncompress_hdr_hc06_23:
   \   0004EA                ; Setup parameters for call to function memcpy
   \   0004EA   75..02       MOV     ?V0 + 4,#0x2
   \   0004ED   75..00       MOV     ?V0 + 5,#0x0
   \   0004F0   78..         MOV     R0,#?V0 + 4
   \   0004F2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0004F5   90....       MOV     DPTR,#hc06_ptr
   \   0004F8   E0           MOVX    A,@DPTR
   \   0004F9   2401         ADD     A,#0x1
   \   0004FB   FC           MOV     R4,A
   \   0004FC   A3           INC     DPTR
   \   0004FD   E0           MOVX    A,@DPTR
   \   0004FE   3400         ADDC    A,#0x0
   \   000500   FD           MOV     R5,A
   \   000501   7A..         MOV     R2,#(uip_aligned_buf + 40) & 0xff
   \   000503   7B..         MOV     R3,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   000505   12....       LCALL   ??memcpy?relay
   \   000508   7402         MOV     A,#0x2
   \   00050A   12....       LCALL   ?DEALLOC_XSTACK8
    940          	memcpy(&SICSLOWPAN_UDP_BUF->destport, hc06_ptr + 3, 2);
   \   00050D                ; Setup parameters for call to function memcpy
   \   00050D   75..02       MOV     ?V0 + 4,#0x2
   \   000510   75..00       MOV     ?V0 + 5,#0x0
   \   000513   78..         MOV     R0,#?V0 + 4
   \   000515   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000518   90....       MOV     DPTR,#hc06_ptr
   \   00051B   E0           MOVX    A,@DPTR
   \   00051C   2403         ADD     A,#0x3
   \   00051E   FC           MOV     R4,A
   \   00051F   A3           INC     DPTR
   \   000520   E0           MOVX    A,@DPTR
   \   000521   3400         ADDC    A,#0x0
   \   000523   FD           MOV     R5,A
   \   000524   7A..         MOV     R2,#(uip_aligned_buf + 42) & 0xff
   \   000526   7B..         MOV     R3,#((uip_aligned_buf + 42) >> 8) & 0xff
   \   000528   12....       LCALL   ??memcpy?relay
   \   00052B   7402         MOV     A,#0x2
   \   00052D   12....       LCALL   ?DEALLOC_XSTACK8
    941          	PRINTF("IPHC: Uncompressed UDP ports (ptr+5): %x, %x\n",
    942          	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
    943          	hc06_ptr += 5;
   \   000530   90....       MOV     DPTR,#hc06_ptr
   \   000533   E0           MOVX    A,@DPTR
   \   000534   2405         ADD     A,#0x5
   \   000536   F8           MOV     R0,A
   \   000537   A3           INC     DPTR
   \   000538   E0           MOVX    A,@DPTR
   \   000539   3400         ADDC    A,#0x0
   \   00053B   F9           MOV     R1,A
   \   00053C   90....       MOV     DPTR,#hc06_ptr
   \   00053F   E8           MOV     A,R0
   \   000540   F0           MOVX    @DPTR,A
   \   000541   A3           INC     DPTR
   \   000542   E9           MOV     A,R1
   \   000543   F0           MOVX    @DPTR,A
    944          	break;
    945          
    946                case SICSLOWPAN_NHC_UDP_CS_P_01:
    947                  /* 1 byte for NHC + source 16bit inline, dest = 0xF0 + 8 bit inline */
    948          	PRINTF("IPHC: Decompressing destination\n");
    949          	memcpy(&SICSLOWPAN_UDP_BUF->srcport, hc06_ptr + 1, 2);
    950          	SICSLOWPAN_UDP_BUF->destport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN + (*(hc06_ptr + 3)));
    951          	PRINTF("IPHC: Uncompressed UDP ports (ptr+4): %x, %x\n",
    952          	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
    953          	hc06_ptr += 4;
    954          	break;
    955          
    956                case SICSLOWPAN_NHC_UDP_CS_P_10:
    957                  /* 1 byte for NHC + source = 0xF0 + 8bit inline, dest = 16 bit inline*/
    958          	PRINTF("IPHC: Decompressing source\n");
    959          	SICSLOWPAN_UDP_BUF->srcport = UIP_HTONS(SICSLOWPAN_UDP_8_BIT_PORT_MIN +
    960          					    (*(hc06_ptr + 1)));
    961          	memcpy(&SICSLOWPAN_UDP_BUF->destport, hc06_ptr + 2, 2);
    962          	PRINTF("IPHC: Uncompressed UDP ports (ptr+4): %x, %x\n",
    963          	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
    964          	hc06_ptr += 4;
    965          	break;
    966          
    967                case SICSLOWPAN_NHC_UDP_CS_P_11:
    968          	/* 1 byte for NHC, 1 byte for ports */
    969          	SICSLOWPAN_UDP_BUF->srcport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +
    970          					    (*(hc06_ptr + 1) >> 4));
    971          	SICSLOWPAN_UDP_BUF->destport = UIP_HTONS(SICSLOWPAN_UDP_4_BIT_PORT_MIN +
    972          					     ((*(hc06_ptr + 1)) & 0x0F));
    973          	PRINTF("IPHC: Uncompressed UDP ports (ptr+2): %x, %x\n",
    974          	       UIP_HTONS(SICSLOWPAN_UDP_BUF->srcport), UIP_HTONS(SICSLOWPAN_UDP_BUF->destport));
    975          	hc06_ptr += 2;
    976          	break;
    977          
    978                default:
    979          	PRINTF("sicslowpan uncompress_hdr: error unsupported UDP compression\n");
    980          	return;
    981                }
    982                if(!checksum_compressed) { /* has_checksum, default  */
   \                     ??uncompress_hdr_hc06_27:
   \   000544   E5..         MOV     A,?V0 + 1
   \   000546   7033         JNZ     ??uncompress_hdr_hc06_28
    983          	memcpy(&SICSLOWPAN_UDP_BUF->udpchksum, hc06_ptr, 2);
   \   000548                ; Setup parameters for call to function memcpy
   \   000548   75..02       MOV     ?V0 + 4,#0x2
   \   00054B   75..00       MOV     ?V0 + 5,#0x0
   \   00054E   78..         MOV     R0,#?V0 + 4
   \   000550   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000553   90....       MOV     DPTR,#hc06_ptr
   \   000556   E0           MOVX    A,@DPTR
   \   000557   FC           MOV     R4,A
   \   000558   A3           INC     DPTR
   \   000559   E0           MOVX    A,@DPTR
   \   00055A   FD           MOV     R5,A
   \   00055B   7A..         MOV     R2,#(uip_aligned_buf + 46) & 0xff
   \   00055D   7B..         MOV     R3,#((uip_aligned_buf + 46) >> 8) & 0xff
   \   00055F   12....       LCALL   ??memcpy?relay
   \   000562   7402         MOV     A,#0x2
   \   000564   12....       LCALL   ?DEALLOC_XSTACK8
    984          	hc06_ptr += 2;
   \   000567   90....       MOV     DPTR,#hc06_ptr
   \   00056A   E0           MOVX    A,@DPTR
   \   00056B   2402         ADD     A,#0x2
   \   00056D   F8           MOV     R0,A
   \   00056E   A3           INC     DPTR
   \   00056F   E0           MOVX    A,@DPTR
   \   000570   3400         ADDC    A,#0x0
   \   000572   F9           MOV     R1,A
   \   000573   90....       MOV     DPTR,#hc06_ptr
   \   000576   E8           MOV     A,R0
   \   000577   F0           MOVX    @DPTR,A
   \   000578   A3           INC     DPTR
   \   000579   E9           MOV     A,R1
   \   00057A   F0           MOVX    @DPTR,A
    985          	PRINTF("IPHC: sicslowpan uncompress_hdr: checksum included\n");
    986                } else {
    987          	PRINTF("IPHC: sicslowpan uncompress_hdr: checksum *NOT* included\n");
    988                }
    989                uncomp_hdr_len += UIP_UDPH_LEN;
   \                     ??uncompress_hdr_hc06_28:
   \   00057B   90....       MOV     DPTR,#uncomp_hdr_len
   \   00057E   E0           MOVX    A,@DPTR
   \   00057F   2408         ADD     A,#0x8
   \   000581   F0           MOVX    @DPTR,A
    990              }
    991          #ifdef SICSLOWPAN_NH_COMPRESSOR
    992              else {
    993                hc06_ptr += SICSLOWPAN_NH_COMPRESSOR.uncompress(hc06_ptr, sicslowpan_buf, &uncomp_hdr_len);
    994              }
    995          #endif
    996            }
    997          
    998            rime_hdr_len = hc06_ptr - rime_ptr;
   \                     ??uncompress_hdr_hc06_22:
   \   000582   90....       MOV     DPTR,#rime_ptr
   \   000585   E0           MOVX    A,@DPTR
   \   000586   F8           MOV     R0,A
   \   000587   A3           INC     DPTR
   \   000588   E0           MOVX    A,@DPTR
   \   000589   F9           MOV     R1,A
   \   00058A   90....       MOV     DPTR,#hc06_ptr
   \   00058D   E0           MOVX    A,@DPTR
   \   00058E   FA           MOV     R2,A
   \   00058F   A3           INC     DPTR
   \   000590   E0           MOVX    A,@DPTR
   \   000591   FB           MOV     R3,A
   \   000592   EA           MOV     A,R2
   \   000593   C3           CLR     C
   \   000594   98           SUBB    A,R0
   \   000595   90....       MOV     DPTR,#rime_hdr_len
   \   000598   F0           MOVX    @DPTR,A
    999            
   1000            /* IP length field. */
   1001            if(ip_len == 0) {
   \   000599   EE           MOV     A,R6
   \   00059A   4F           ORL     A,R7
   \   00059B   6003         JZ      $+5
   \   00059D   02....       LJMP    ??uncompress_hdr_hc06_29 & 0xFFFF
   1002              /* This is not a fragmented packet */
   1003              SICSLOWPAN_IP_BUF->len[0] = 0;
   \   0005A0   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   0005A3   7400         MOV     A,#0x0
   \   0005A5   F0           MOVX    @DPTR,A
   1004              SICSLOWPAN_IP_BUF->len[1] = packetbuf_datalen() - rime_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;
   \   0005A6                ; Setup parameters for call to function packetbuf_datalen
   \   0005A6   12....       LCALL   ??packetbuf_datalen?relay
   \   0005A9   8A..         MOV     ?V0 + 4,R2
   \   0005AB   8B..         MOV     ?V0 + 5,R3
   \   0005AD   A8..         MOV     R0,?V0 + 4
   \   0005AF   A9..         MOV     R1,?V0 + 5
   \   0005B1   90....       MOV     DPTR,#uncomp_hdr_len
   \   0005B4   E0           MOVX    A,@DPTR
   \   0005B5   FB           MOV     R3,A
   \   0005B6   90....       MOV     DPTR,#rime_hdr_len
   \   0005B9   E0           MOVX    A,@DPTR
   \   0005BA   FA           MOV     R2,A
   \   0005BB   E5..         MOV     A,?V0 + 4
   \   0005BD   C3           CLR     C
   \   0005BE   9A           SUBB    A,R2
   \   0005BF   2B           ADD     A,R3
   \   0005C0   24D8         ADD     A,#-0x28
   \   0005C2   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   0005C5   F0           MOVX    @DPTR,A
   \   0005C6   02....       LJMP    ??uncompress_hdr_hc06_30 & 0xFFFF
   1005            } else {
   \                     ??uncompress_hdr_hc06_24:
   \   0005C9                ; Setup parameters for call to function memcpy
   \   0005C9   75..02       MOV     ?V0 + 4,#0x2
   \   0005CC   75..00       MOV     ?V0 + 5,#0x0
   \   0005CF   78..         MOV     R0,#?V0 + 4
   \   0005D1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0005D4   90....       MOV     DPTR,#hc06_ptr
   \   0005D7   E0           MOVX    A,@DPTR
   \   0005D8   2401         ADD     A,#0x1
   \   0005DA   FC           MOV     R4,A
   \   0005DB   A3           INC     DPTR
   \   0005DC   E0           MOVX    A,@DPTR
   \   0005DD   3400         ADDC    A,#0x0
   \   0005DF   FD           MOV     R5,A
   \   0005E0   7A..         MOV     R2,#(uip_aligned_buf + 40) & 0xff
   \   0005E2   7B..         MOV     R3,#((uip_aligned_buf + 40) >> 8) & 0xff
   \   0005E4   12....       LCALL   ??memcpy?relay
   \   0005E7   7402         MOV     A,#0x2
   \   0005E9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0005EC   90....       MOV     DPTR,#hc06_ptr
   \   0005EF   E0           MOVX    A,@DPTR
   \   0005F0   F8           MOV     R0,A
   \   0005F1   A3           INC     DPTR
   \   0005F2   E0           MOVX    A,@DPTR
   \   0005F3   F583         MOV     DPH,A
   \   0005F5   8882         MOV     DPL,R0
   \   0005F7   A3           INC     DPTR
   \   0005F8   A3           INC     DPTR
   \   0005F9   A3           INC     DPTR
   \   0005FA   E0           MOVX    A,@DPTR
   \   0005FB   F8           MOV     R0,A
   \   0005FC   7900         MOV     R1,#0x0
   \   0005FE   E4           CLR     A
   \   0005FF   C8           XCH     A,R0
   \   000600   F9           MOV     R1,A
   \   000601   E8           MOV     A,R0
   \   000602   44F0         ORL     A,#0xf0
   \   000604   F8           MOV     R0,A
   \   000605   E9           MOV     A,R1
   \   000606   4400         ORL     A,#0x0
   \   000608   F9           MOV     R1,A
   \   000609   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   00060C   E8           MOV     A,R0
   \   00060D   F0           MOVX    @DPTR,A
   \   00060E   A3           INC     DPTR
   \   00060F   E9           MOV     A,R1
   \   000610   F0           MOVX    @DPTR,A
   \   000611   90....       MOV     DPTR,#hc06_ptr
   \   000614   E0           MOVX    A,@DPTR
   \   000615   2404         ADD     A,#0x4
   \   000617   F8           MOV     R0,A
   \   000618   A3           INC     DPTR
   \   000619   E0           MOVX    A,@DPTR
   \   00061A   3400         ADDC    A,#0x0
   \   00061C   F9           MOV     R1,A
   \   00061D   90....       MOV     DPTR,#hc06_ptr
   \   000620   E8           MOV     A,R0
   \   000621   F0           MOVX    @DPTR,A
   \   000622   A3           INC     DPTR
   \   000623   E9           MOV     A,R1
   \   000624   F0           MOVX    @DPTR,A
   \   000625   02....       LJMP    ??uncompress_hdr_hc06_27 & 0xFFFF
   \                     ??uncompress_hdr_hc06_25:
   \   000628   90....       MOV     DPTR,#hc06_ptr
   \   00062B   E0           MOVX    A,@DPTR
   \   00062C   F8           MOV     R0,A
   \   00062D   A3           INC     DPTR
   \   00062E   E0           MOVX    A,@DPTR
   \   00062F   F583         MOV     DPH,A
   \   000631   8882         MOV     DPL,R0
   \   000633   A3           INC     DPTR
   \   000634   E0           MOVX    A,@DPTR
   \   000635   F8           MOV     R0,A
   \   000636   7900         MOV     R1,#0x0
   \   000638   E4           CLR     A
   \   000639   C8           XCH     A,R0
   \   00063A   F9           MOV     R1,A
   \   00063B   E8           MOV     A,R0
   \   00063C   44F0         ORL     A,#0xf0
   \   00063E   F8           MOV     R0,A
   \   00063F   E9           MOV     A,R1
   \   000640   4400         ORL     A,#0x0
   \   000642   F9           MOV     R1,A
   \   000643   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   000646   E8           MOV     A,R0
   \   000647   F0           MOVX    @DPTR,A
   \   000648   A3           INC     DPTR
   \   000649   E9           MOV     A,R1
   \   00064A   F0           MOVX    @DPTR,A
   \   00064B                ; Setup parameters for call to function memcpy
   \   00064B   75..02       MOV     ?V0 + 4,#0x2
   \   00064E   75..00       MOV     ?V0 + 5,#0x0
   \   000651   78..         MOV     R0,#?V0 + 4
   \   000653   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000656   90....       MOV     DPTR,#hc06_ptr
   \   000659   E0           MOVX    A,@DPTR
   \   00065A   2402         ADD     A,#0x2
   \   00065C   FC           MOV     R4,A
   \   00065D   A3           INC     DPTR
   \   00065E   E0           MOVX    A,@DPTR
   \   00065F   3400         ADDC    A,#0x0
   \   000661   FD           MOV     R5,A
   \   000662   7A..         MOV     R2,#(uip_aligned_buf + 42) & 0xff
   \   000664   7B..         MOV     R3,#((uip_aligned_buf + 42) >> 8) & 0xff
   \   000666   12....       LCALL   ??memcpy?relay
   \   000669   7402         MOV     A,#0x2
   \   00066B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00066E   90....       MOV     DPTR,#hc06_ptr
   \   000671   E0           MOVX    A,@DPTR
   \   000672   2404         ADD     A,#0x4
   \   000674   F8           MOV     R0,A
   \   000675   A3           INC     DPTR
   \   000676   E0           MOVX    A,@DPTR
   \   000677   3400         ADDC    A,#0x0
   \   000679   F9           MOV     R1,A
   \   00067A   90....       MOV     DPTR,#hc06_ptr
   \   00067D   E8           MOV     A,R0
   \   00067E   F0           MOVX    @DPTR,A
   \   00067F   A3           INC     DPTR
   \   000680   E9           MOV     A,R1
   \   000681   F0           MOVX    @DPTR,A
   \   000682   02....       LJMP    ??uncompress_hdr_hc06_27 & 0xFFFF
   \                     ??uncompress_hdr_hc06_26:
   \   000685   90....       MOV     DPTR,#hc06_ptr
   \   000688   E0           MOVX    A,@DPTR
   \   000689   F8           MOV     R0,A
   \   00068A   A3           INC     DPTR
   \   00068B   E0           MOVX    A,@DPTR
   \   00068C   F583         MOV     DPH,A
   \   00068E   8882         MOV     DPL,R0
   \   000690   A3           INC     DPTR
   \   000691   E0           MOVX    A,@DPTR
   \   000692   C4           SWAP    A
   \   000693   540F         ANL     A,#0xf
   \   000695   F8           MOV     R0,A
   \   000696   7900         MOV     R1,#0x0
   \   000698   24B0         ADD     A,#-0x50
   \   00069A   F8           MOV     R0,A
   \   00069B   E9           MOV     A,R1
   \   00069C   34F0         ADDC    A,#-0x10
   \   00069E   F9           MOV     R1,A
   \   00069F   E4           CLR     A
   \   0006A0   C8           XCH     A,R0
   \   0006A1   F9           MOV     R1,A
   \   0006A2   E8           MOV     A,R0
   \   0006A3   44F0         ORL     A,#0xf0
   \   0006A5   F8           MOV     R0,A
   \   0006A6   E9           MOV     A,R1
   \   0006A7   4400         ORL     A,#0x0
   \   0006A9   F9           MOV     R1,A
   \   0006AA   90....       MOV     DPTR,#uip_aligned_buf + 40
   \   0006AD   E8           MOV     A,R0
   \   0006AE   F0           MOVX    @DPTR,A
   \   0006AF   A3           INC     DPTR
   \   0006B0   E9           MOV     A,R1
   \   0006B1   F0           MOVX    @DPTR,A
   \   0006B2   90....       MOV     DPTR,#hc06_ptr
   \   0006B5   E0           MOVX    A,@DPTR
   \   0006B6   F8           MOV     R0,A
   \   0006B7   A3           INC     DPTR
   \   0006B8   E0           MOVX    A,@DPTR
   \   0006B9   F583         MOV     DPH,A
   \   0006BB   8882         MOV     DPL,R0
   \   0006BD   A3           INC     DPTR
   \   0006BE   E0           MOVX    A,@DPTR
   \   0006BF   F8           MOV     R0,A
   \   0006C0   7900         MOV     R1,#0x0
   \   0006C2   540F         ANL     A,#0xf
   \   0006C4   F8           MOV     R0,A
   \   0006C5   E9           MOV     A,R1
   \   0006C6   5400         ANL     A,#0x0
   \   0006C8   F9           MOV     R1,A
   \   0006C9   E8           MOV     A,R0
   \   0006CA   24B0         ADD     A,#-0x50
   \   0006CC   F8           MOV     R0,A
   \   0006CD   E9           MOV     A,R1
   \   0006CE   34F0         ADDC    A,#-0x10
   \   0006D0   F9           MOV     R1,A
   \   0006D1   E4           CLR     A
   \   0006D2   C8           XCH     A,R0
   \   0006D3   F9           MOV     R1,A
   \   0006D4   E8           MOV     A,R0
   \   0006D5   44F0         ORL     A,#0xf0
   \   0006D7   F8           MOV     R0,A
   \   0006D8   E9           MOV     A,R1
   \   0006D9   4400         ORL     A,#0x0
   \   0006DB   F9           MOV     R1,A
   \   0006DC   90....       MOV     DPTR,#uip_aligned_buf + 42
   \   0006DF   E8           MOV     A,R0
   \   0006E0   F0           MOVX    @DPTR,A
   \   0006E1   A3           INC     DPTR
   \   0006E2   E9           MOV     A,R1
   \   0006E3   F0           MOVX    @DPTR,A
   \   0006E4   90....       MOV     DPTR,#hc06_ptr
   \   0006E7   E0           MOVX    A,@DPTR
   \   0006E8   2402         ADD     A,#0x2
   \   0006EA   F8           MOV     R0,A
   \   0006EB   A3           INC     DPTR
   \   0006EC   E0           MOVX    A,@DPTR
   \   0006ED   3400         ADDC    A,#0x0
   \   0006EF   F9           MOV     R1,A
   \   0006F0   90....       MOV     DPTR,#hc06_ptr
   \   0006F3   E8           MOV     A,R0
   \   0006F4   F0           MOVX    @DPTR,A
   \   0006F5   A3           INC     DPTR
   \   0006F6   E9           MOV     A,R1
   \   0006F7   F0           MOVX    @DPTR,A
   \   0006F8   02....       LJMP    ??uncompress_hdr_hc06_27 & 0xFFFF
   1006              /* This is a 1st fragment */
   1007              SICSLOWPAN_IP_BUF->len[0] = (ip_len - UIP_IPH_LEN) >> 8;
   \                     ??uncompress_hdr_hc06_29:
   \   0006FB   EE           MOV     A,R6
   \   0006FC   24D8         ADD     A,#-0x28
   \   0006FE   F8           MOV     R0,A
   \   0006FF   EF           MOV     A,R7
   \   000700   34FF         ADDC    A,#-0x1
   \   000702   F9           MOV     R1,A
   \   000703   E4           CLR     A
   \   000704   E9           MOV     A,R1
   \   000705   F8           MOV     R0,A
   \   000706   90....       MOV     DPTR,#uip_aligned_buf + 4
   \   000709   F0           MOVX    @DPTR,A
   1008              SICSLOWPAN_IP_BUF->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;
   \   00070A   EE           MOV     A,R6
   \   00070B   24D8         ADD     A,#-0x28
   \   00070D   90....       MOV     DPTR,#uip_aligned_buf + 5
   \   000710   F0           MOVX    @DPTR,A
   1009            }
   1010            
   1011            /* length field in UDP header */
   1012            if(SICSLOWPAN_IP_BUF->proto == UIP_PROTO_UDP) {
   \                     ??uncompress_hdr_hc06_30:
   \   000711   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000714   E0           MOVX    A,@DPTR
   \   000715   6411         XRL     A,#0x11
   \   000717   701B         JNZ     ??uncompress_hdr_hc06_12
   1013              memcpy(&SICSLOWPAN_UDP_BUF->udplen, &SICSLOWPAN_IP_BUF->len[0], 2);
   \   000719                ; Setup parameters for call to function memcpy
   \   000719   75..02       MOV     ?V0 + 4,#0x2
   \   00071C   75..00       MOV     ?V0 + 5,#0x0
   \   00071F   78..         MOV     R0,#?V0 + 4
   \   000721   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000724   7C..         MOV     R4,#(uip_aligned_buf + 4) & 0xff
   \   000726   7D..         MOV     R5,#((uip_aligned_buf + 4) >> 8) & 0xff
   \   000728   7A..         MOV     R2,#(uip_aligned_buf + 44) & 0xff
   \   00072A   7B..         MOV     R3,#((uip_aligned_buf + 44) >> 8) & 0xff
   \   00072C   12....       LCALL   ??memcpy?relay
   \   00072F   7402         MOV     A,#0x2
   \   000731   12....       LCALL   ?DEALLOC_XSTACK8
   1014            }
   1015          
   1016            return;
   \                     ??uncompress_hdr_hc06_12:
   \   000734   7402         MOV     A,#0x2
   \   000736   12....       LCALL   ?DEALLOC_XSTACK8
   \   000739   7F0A         MOV     R7,#0xa
   \   00073B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1017          }
   1018          /** @} */
   1019          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
   1020          
   1021          
   1022          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1
   1023          /*--------------------------------------------------------------------*/
   1024          /** \name HC1 compression and uncompression functions
   1025           *  @{                                                                */
   1026          /*--------------------------------------------------------------------*/
   1027          /**
   1028           * \brief Compress IP/UDP header using HC1 and HC_UDP
   1029           *
   1030           * This function is called by the 6lowpan code to create a compressed
   1031           * 6lowpan packet in the packetbuf buffer from a full IPv6 packet in the
   1032           * uip_buf buffer.
   1033           *
   1034           *
   1035           * If we can compress everything, we use HC1 dispatch, if not we use
   1036           * IPv6 dispatch.\n
   1037           * We can compress everything if:
   1038           *   - IP version is
   1039           *   - Flow label and traffic class are 0
   1040           *   - Both src and dest ip addresses are link local
   1041           *   - Both src and dest interface ID are recoverable from lower layer
   1042           *     header
   1043           *   - Next header is either ICMP, UDP or TCP
   1044           * Moreover, if next header is UDP, we try to compress it using HC_UDP.
   1045           * This is feasible is both ports are between F0B0 and F0B0 + 15\n\n
   1046           *
   1047           * Resulting header structure:
   1048           * - For ICMP, TCP, non compressed UDP\n
   1049           *   HC1 encoding = 11111010 (UDP) 11111110 (TCP) 11111100 (ICMP)\n
   1050           * \verbatim
   1051           *                      1                   2                   3
   1052           * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   1053           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1054           * | LoWPAN HC1 Dsp | HC1 encoding  | IPv6 Hop limit| L4 hdr + data|
   1055           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1056           * | ...
   1057           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1058           * \endverbatim
   1059           *
   1060           * - For compressed UDP
   1061           *   HC1 encoding = 11111011, HC_UDP encoding = 11100000\n
   1062           * \verbatim
   1063           *                      1                   2                   3
   1064           * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   1065           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1066           * | LoWPAN HC1 Dsp| HC1 encoding  |  HC_UDP encod.| IPv6 Hop limit|
   1067           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1068           * | src p.| dst p.| UDP checksum                  | L4 data...
   1069           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1070           * \endverbatim
   1071           *
   1072           * \param rime_destaddr L2 destination address, needed to compress the
   1073           * IP destination field
   1074           */
   1075          static void
   1076          compress_hdr_hc1(rimeaddr_t *rime_destaddr)
   1077          {
   1078            /*
   1079             * Check if all the assumptions for full compression
   1080             * are valid :
   1081             */
   1082            if(UIP_IP_BUF->vtc != 0x60 ||
   1083               UIP_IP_BUF->tcflow != 0 ||
   1084               UIP_IP_BUF->flow != 0 ||
   1085               !uip_is_addr_link_local(&UIP_IP_BUF->srcipaddr) ||
   1086               !uip_is_addr_mac_addr_based(&UIP_IP_BUF->srcipaddr, &uip_lladdr) ||
   1087               !uip_is_addr_link_local(&UIP_IP_BUF->destipaddr) ||
   1088               !uip_is_addr_mac_addr_based(&UIP_IP_BUF->destipaddr,
   1089                                           (uip_lladdr_t *)rime_destaddr) ||
   1090               (UIP_IP_BUF->proto != UIP_PROTO_ICMP6 &&
   1091                UIP_IP_BUF->proto != UIP_PROTO_UDP &&
   1092                UIP_IP_BUF->proto != UIP_PROTO_TCP))
   1093            {
   1094              /*
   1095               * IPV6 DISPATCH
   1096               * Something cannot be compressed, use IPV6 DISPATCH,
   1097               * compress nothing, copy IPv6 header in rime buffer
   1098               */
   1099              *rime_ptr = SICSLOWPAN_DISPATCH_IPV6;
   1100              rime_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
   1101              memcpy(rime_ptr + rime_hdr_len, UIP_IP_BUF, UIP_IPH_LEN);
   1102              rime_hdr_len += UIP_IPH_LEN;
   1103              uncomp_hdr_len += UIP_IPH_LEN;
   1104            } else {
   1105              /*
   1106               * HC1 DISPATCH
   1107               * maximum compresssion:
   1108               * All fields in the IP header but Hop Limit are elided
   1109               * If next header is UDP, we compress UDP header using HC2
   1110               */
   1111              RIME_HC1_PTR[RIME_HC1_DISPATCH] = SICSLOWPAN_DISPATCH_HC1;
   1112              uncomp_hdr_len += UIP_IPH_LEN;
   1113              switch(UIP_IP_BUF->proto) {
   1114                case UIP_PROTO_ICMP6:
   1115                  /* HC1 encoding and ttl */
   1116                  RIME_HC1_PTR[RIME_HC1_ENCODING] = 0xFC;
   1117                  RIME_HC1_PTR[RIME_HC1_TTL] = UIP_IP_BUF->ttl;
   1118                  rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
   1119                  break;
   1120          #if UIP_CONF_TCP
   1121                case UIP_PROTO_TCP:
   1122                  /* HC1 encoding and ttl */
   1123                  RIME_HC1_PTR[RIME_HC1_ENCODING] = 0xFE;
   1124                  RIME_HC1_PTR[RIME_HC1_TTL] = UIP_IP_BUF->ttl;
   1125                  rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
   1126                  break;
   1127          #endif /* UIP_CONF_TCP */
   1128          #if UIP_CONF_UDP
   1129                case UIP_PROTO_UDP:
   1130                  /*
   1131                   * try to compress UDP header (we do only full compression).
   1132                   * This is feasible if both src and dest ports are between
   1133                   * SICSLOWPAN_UDP_PORT_MIN and SICSLOWPAN_UDP_PORT_MIN + 15
   1134                   */
   1135                  PRINTF("local/remote port %u/%u\n",UIP_UDP_BUF->srcport,UIP_UDP_BUF->destport);
   1136                  if(UIP_HTONS(UIP_UDP_BUF->srcport)  >= SICSLOWPAN_UDP_PORT_MIN &&
   1137                     UIP_HTONS(UIP_UDP_BUF->srcport)  <  SICSLOWPAN_UDP_PORT_MAX &&
   1138                     UIP_HTONS(UIP_UDP_BUF->destport) >= SICSLOWPAN_UDP_PORT_MIN &&
   1139                     UIP_HTONS(UIP_UDP_BUF->destport) <  SICSLOWPAN_UDP_PORT_MAX) {
   1140                    /* HC1 encoding */
   1141                    RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_HC1_ENCODING] = 0xFB;
   1142                  
   1143                    /* HC_UDP encoding, ttl, src and dest ports, checksum */
   1144                    RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_UDP_ENCODING] = 0xE0;
   1145                    RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_TTL] = UIP_IP_BUF->ttl;
   1146          
   1147                    RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_PORTS] =
   1148                         (uint8_t)((UIP_HTONS(UIP_UDP_BUF->srcport) -
   1149                                 SICSLOWPAN_UDP_PORT_MIN) << 4) +
   1150                         (uint8_t)((UIP_HTONS(UIP_UDP_BUF->destport) - SICSLOWPAN_UDP_PORT_MIN));
   1151                    memcpy(&RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_CHKSUM], &UIP_UDP_BUF->udpchksum, 2);
   1152                    rime_hdr_len += SICSLOWPAN_HC1_HC_UDP_HDR_LEN;
   1153                    uncomp_hdr_len += UIP_UDPH_LEN;
   1154                  } else {
   1155                    /* HC1 encoding and ttl */
   1156                    RIME_HC1_PTR[RIME_HC1_ENCODING] = 0xFA;
   1157                    RIME_HC1_PTR[RIME_HC1_TTL] = UIP_IP_BUF->ttl;
   1158                    rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
   1159                  }
   1160                  break;
   1161          #endif /*UIP_CONF_UDP*/
   1162              }
   1163            }
   1164            return;
   1165          }
   1166          
   1167          /*--------------------------------------------------------------------*/
   1168          /**
   1169           * \brief Uncompress HC1 (and HC_UDP) headers and put them in
   1170           * sicslowpan_buf
   1171           *
   1172           * This function is called by the input function when the dispatch is
   1173           * HC1.
   1174           * We %process the packet in the rime buffer, uncompress the header
   1175           * fields, and copy the result in the sicslowpan buffer.
   1176           * At the end of the decompression, rime_hdr_len and uncompressed_hdr_len
   1177           * are set to the appropriate values
   1178           *
   1179           * \param ip_len Equal to 0 if the packet is not a fragment (IP length
   1180           * is then inferred from the L2 length), non 0 if the packet is a 1st
   1181           * fragment.
   1182           */
   1183          static void
   1184          uncompress_hdr_hc1(uint16_t ip_len)
   1185          {
   1186            /* version, traffic class, flow label */
   1187            SICSLOWPAN_IP_BUF->vtc = 0x60;
   1188            SICSLOWPAN_IP_BUF->tcflow = 0;
   1189            SICSLOWPAN_IP_BUF->flow = 0;
   1190            
   1191            /* src and dest ip addresses */
   1192            uip_ip6addr(&SICSLOWPAN_IP_BUF->srcipaddr, 0xfe80, 0, 0, 0, 0, 0, 0, 0);
   1193            uip_ds6_set_addr_iid(&SICSLOWPAN_IP_BUF->srcipaddr,
   1194          		       (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_SENDER));
   1195            uip_ip6addr(&SICSLOWPAN_IP_BUF->destipaddr, 0xfe80, 0, 0, 0, 0, 0, 0, 0);
   1196            uip_ds6_set_addr_iid(&SICSLOWPAN_IP_BUF->destipaddr,
   1197          		       (uip_lladdr_t *)packetbuf_addr(PACKETBUF_ADDR_RECEIVER));
   1198            
   1199            uncomp_hdr_len += UIP_IPH_LEN;
   1200            
   1201            /* Next header field */
   1202            switch(RIME_HC1_PTR[RIME_HC1_ENCODING] & 0x06) {
   1203              case SICSLOWPAN_HC1_NH_ICMP6:
   1204                SICSLOWPAN_IP_BUF->proto = UIP_PROTO_ICMP6;
   1205                SICSLOWPAN_IP_BUF->ttl = RIME_HC1_PTR[RIME_HC1_TTL];
   1206                rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
   1207                break;
   1208          #if UIP_CONF_TCP
   1209              case SICSLOWPAN_HC1_NH_TCP:
   1210                SICSLOWPAN_IP_BUF->proto = UIP_PROTO_TCP;
   1211                SICSLOWPAN_IP_BUF->ttl = RIME_HC1_PTR[RIME_HC1_TTL];
   1212                rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
   1213                break;
   1214          #endif/* UIP_CONF_TCP */
   1215          #if UIP_CONF_UDP
   1216              case SICSLOWPAN_HC1_NH_UDP:
   1217                SICSLOWPAN_IP_BUF->proto = UIP_PROTO_UDP;
   1218                if(RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_HC1_ENCODING] & 0x01) {
   1219                  /* UDP header is compressed with HC_UDP */
   1220                  if(RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_UDP_ENCODING] !=
   1221                     SICSLOWPAN_HC_UDP_ALL_C) {
   1222                    PRINTF("sicslowpan (uncompress_hdr), packet not supported");
   1223                    return;
   1224                  }
   1225                  /* IP TTL */
   1226                  SICSLOWPAN_IP_BUF->ttl = RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_TTL];
   1227                  /* UDP ports, len, checksum */
   1228                  SICSLOWPAN_UDP_BUF->srcport =
   1229                    UIP_HTONS(SICSLOWPAN_UDP_PORT_MIN +
   1230                          (RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_PORTS] >> 4));
   1231                  SICSLOWPAN_UDP_BUF->destport =
   1232                    UIP_HTONS(SICSLOWPAN_UDP_PORT_MIN +
   1233                          (RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_PORTS] & 0x0F));
   1234                  memcpy(&SICSLOWPAN_UDP_BUF->udpchksum, &RIME_HC1_HC_UDP_PTR[RIME_HC1_HC_UDP_CHKSUM], 2);
   1235                  uncomp_hdr_len += UIP_UDPH_LEN;
   1236                  rime_hdr_len += SICSLOWPAN_HC1_HC_UDP_HDR_LEN;
   1237                } else {
   1238                  rime_hdr_len += SICSLOWPAN_HC1_HDR_LEN;
   1239                }
   1240                break;
   1241          #endif/* UIP_CONF_UDP */
   1242              default:
   1243                /* this shouldn't happen, drop */
   1244                return;
   1245            }
   1246            
   1247            /* IP length field. */
   1248            if(ip_len == 0) {
   1249              /* This is not a fragmented packet */
   1250              SICSLOWPAN_IP_BUF->len[0] = 0;
   1251              SICSLOWPAN_IP_BUF->len[1] = packetbuf_datalen() - rime_hdr_len + uncomp_hdr_len - UIP_IPH_LEN;
   1252            } else {
   1253              /* This is a 1st fragment */
   1254              SICSLOWPAN_IP_BUF->len[0] = (ip_len - UIP_IPH_LEN) >> 8;
   1255              SICSLOWPAN_IP_BUF->len[1] = (ip_len - UIP_IPH_LEN) & 0x00FF;
   1256            }
   1257            /* length field in UDP header */
   1258            if(SICSLOWPAN_IP_BUF->proto == UIP_PROTO_UDP) {
   1259              memcpy(&SICSLOWPAN_UDP_BUF->udplen, &SICSLOWPAN_IP_BUF->len[0], 2);
   1260            }
   1261            return;
   1262          }
   1263          /** @} */
   1264          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1 */
   1265          
   1266          
   1267          
   1268          /*--------------------------------------------------------------------*/
   1269          /** \name IPv6 dispatch "compression" function
   1270           * @{                                                                 */
   1271          /*--------------------------------------------------------------------*/
   1272          /* \brief Packets "Compression" when only IPv6 dispatch is used
   1273           *
   1274           * There is no compression in this case, all fields are sent
   1275           * inline. We just add the IPv6 dispatch byte before the packet.
   1276           * \verbatim
   1277           * 0               1                   2                   3
   1278           * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   1279           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1280           * | IPv6 Dsp      | IPv6 header and payload ...
   1281           * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   1282           * \endverbatim
   1283           */
   1284          static void
   1285          compress_hdr_ipv6(rimeaddr_t *rime_destaddr)
   1286          {
   1287            *rime_ptr = SICSLOWPAN_DISPATCH_IPV6;
   1288            rime_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
   1289            memcpy(rime_ptr + rime_hdr_len, UIP_IP_BUF, UIP_IPH_LEN);
   1290            rime_hdr_len += UIP_IPH_LEN;
   1291            uncomp_hdr_len += UIP_IPH_LEN;
   1292            return;
   1293          }
   1294          /** @} */
   1295          
   1296          /*--------------------------------------------------------------------*/
   1297          /** \name Input/output functions common to all compression schemes
   1298           * @{                                                                 */
   1299          /*--------------------------------------------------------------------*/
   1300          /**
   1301           * Callback function for the MAC packet sent callback
   1302           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1303          static void
   1304          packet_sent(void *ptr, int status, int transmissions)
   \                     packet_sent:
   1305          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   FC           MOV     R4,A
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FD           MOV     R5,A
   1306            uip_ds6_link_neighbor_callback(status, transmissions);
   \   000013                ; Setup parameters for call to function uip_ds6_link_neighbor_callback
   \   000013   EE           MOV     A,R6
   \   000014   FA           MOV     R2,A
   \   000015   EF           MOV     A,R7
   \   000016   FB           MOV     R3,A
   \   000017   12....       LCALL   ??uip_ds6_link_neighbor_callback?relay
   1307          
   1308            if(callback != NULL) {
   \   00001A   90....       MOV     DPTR,#callback
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F8           MOV     R0,A
   \   00001F   A3           INC     DPTR
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   49           ORL     A,R1
   \   000024   601E         JZ      ??packet_sent_0
   1309              callback->output_callback(status);
   \   000026                ; Setup parameters for indirect call
   \   000026   EE           MOV     A,R6
   \   000027   FA           MOV     R2,A
   \   000028   EF           MOV     A,R7
   \   000029   FB           MOV     R3,A
   \   00002A   90....       MOV     DPTR,#callback
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F8           MOV     R0,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F583         MOV     DPH,A
   \   000033   8882         MOV     DPL,R0
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F583         MOV     DPH,A
   \   00003F   8882         MOV     DPL,R0
   \   000041   12....       LCALL   ?CALL_IND
   1310            }
   1311            last_tx_status = status;
   \                     ??packet_sent_0:
   \   000044   90....       MOV     DPTR,#last_tx_status
   \   000047   EE           MOV     A,R6
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   EF           MOV     A,R7
   \   00004B   F0           MOVX    @DPTR,A
   1312          }
   \   00004C   7F01         MOV     R7,#0x1
   \   00004E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1313          /*--------------------------------------------------------------------*/
   1314          /**
   1315           * \brief This function is called by the 6lowpan code to send out a
   1316           * packet.
   1317           * \param dest the link layer destination address of the packet
   1318           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1319          static void
   1320          send_packet(rimeaddr_t *dest)
   \                     send_packet:
   1321          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1322            /* Set the link layer destination address for the packet as a
   1323             * packetbuf attribute. The MAC layer can access the destination
   1324             * address with the function packetbuf_addr(PACKETBUF_ADDR_RECEIVER).
   1325             */
   1326            packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, dest);
   \   000004                ; Setup parameters for call to function packetbuf_set_addr
   \   000004   7919         MOV     R1,#0x19
   \   000006   12....       LCALL   ??packetbuf_set_addr?relay
   1327          
   1328          #if NETSTACK_CONF_BRIDGE_MODE
   1329            /* This needs to be explicitly set here for bridge mode to work */
   1330            packetbuf_set_addr(PACKETBUF_ADDR_SENDER,(void*)&uip_lladdr);
   1331          #endif
   1332          
   1333            /* Force acknowledge from sender (test hardware autoacks) */
   1334          #if SICSLOWPAN_CONF_ACK_ALL
   1335              packetbuf_set_attr(PACKETBUF_ATTR_RELIABLE, 1);
   1336          #endif
   1337          
   1338            /* Provide a callback function to receive the result of
   1339               a packet transmission. */
   1340            NETSTACK_MAC.send(&packet_sent, NULL);
   \   000009                ; Setup parameters for indirect call
   \   000009   7C00         MOV     R4,#0x0
   \   00000B   7D00         MOV     R5,#0x0
   \   00000D   7A..         MOV     R2,#??packet_sent?relay & 0xff
   \   00000F   7B..         MOV     R3,#(??packet_sent?relay >> 8) & 0xff
   \   000011   90....       MOV     DPTR,#nullmac_driver + 4
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F583         MOV     DPH,A
   \   00001A   8882         MOV     DPL,R0
   \   00001C   12....       LCALL   ?CALL_IND
   1341          
   1342            /* If we are sending multiple packets in a row, we need to let the
   1343               watchdog know that we are still alive. */
   1344            watchdog_periodic();
   \   00001F                ; Setup parameters for call to function watchdog_periodic
   \   00001F   12....       LCALL   ??watchdog_periodic?relay
   1345          }
   \   000022   D083         POP     DPH
   \   000024   D082         POP     DPL
   \   000026   02....       LJMP    ?BRET
   1346          /*--------------------------------------------------------------------*/
   1347          /** \brief Take an IP packet and format it to be sent on an 802.15.4
   1348           *  network using 6lowpan.
   1349           *  \param localdest The MAC address of the destination
   1350           *
   1351           *  The IP packet is initially in uip_buf. Its header is compressed
   1352           *  and if necessary it is fragmented. The resulting
   1353           *  packet/fragments are put in packetbuf and delivered to the 802.15.4
   1354           *  MAC.
   1355           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1356          static uint8_t
   1357          output(uip_lladdr_t *localdest)
   \                     output:
   1358          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1359            int framer_hdrlen;
   1360          
   1361            /* The MAC address of the destination of the packet */
   1362            rimeaddr_t dest;
   1363          
   1364            /* Number of bytes processed. */
   1365            uint16_t processed_ip_out_len;
   1366          
   1367            /* init */
   1368            uncomp_hdr_len = 0;
   \   00000E   90....       MOV     DPTR,#uncomp_hdr_len
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
   1369            rime_hdr_len = 0;
   \   000014   90....       MOV     DPTR,#rime_hdr_len
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   1370          
   1371            /* reset rime buffer */
   1372            packetbuf_clear();
   \   00001A                ; Setup parameters for call to function packetbuf_clear
   \   00001A   12....       LCALL   ??packetbuf_clear?relay
   1373            rime_ptr = packetbuf_dataptr();
   \   00001D                ; Setup parameters for call to function packetbuf_dataptr
   \   00001D   12....       LCALL   ??packetbuf_dataptr?relay
   \   000020   90....       MOV     DPTR,#rime_ptr
   \   000023   EA           MOV     A,R2
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EB           MOV     A,R3
   \   000027   F0           MOVX    @DPTR,A
   1374          
   1375            packetbuf_set_attr(PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS,
   1376                               SICSLOWPAN_MAX_MAC_TRANSMISSIONS);
   \   000028                ; Setup parameters for call to function packetbuf_set_attr
   \   000028   7A04         MOV     R2,#0x4
   \   00002A   7B00         MOV     R3,#0x0
   \   00002C   7909         MOV     R1,#0x9
   \   00002E   12....       LCALL   ??packetbuf_set_attr?relay
   1377          
   1378            if(callback) {
   \   000031   90....       MOV     DPTR,#callback
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F8           MOV     R0,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F9           MOV     R1,A
   \   000039   E8           MOV     A,R0
   \   00003A   49           ORL     A,R1
   \   00003B   6003         JZ      ??output_0
   1379              /* call the attribution when the callback comes, but set attributes
   1380                 here ! */
   1381              set_packet_attrs();
   \   00003D                ; Setup parameters for call to function set_packet_attrs
   \   00003D   12....       LCALL   ??set_packet_attrs?relay
   1382            }
   1383          
   1384          #define TCP_FIN 0x01
   1385          #define TCP_ACK 0x10
   1386          #define TCP_CTL 0x3f
   1387            /* Set stream mode for all TCP packets, except FIN packets. */
   1388            if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
   1389               (UIP_TCP_BUF->flags & TCP_FIN) == 0 &&
   1390               (UIP_TCP_BUF->flags & TCP_CTL) != TCP_ACK) {
   \                     ??output_0:
   \   000040   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000043   E0           MOVX    A,@DPTR
   \   000044   6406         XRL     A,#0x6
   \   000046   701D         JNZ     ??output_1
   \   000048   90....       MOV     DPTR,#uip_aligned_buf + 53
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   4015         JC      ??output_1
   \   000050   90....       MOV     DPTR,#uip_aligned_buf + 53
   \   000053   E0           MOVX    A,@DPTR
   \   000054   543F         ANL     A,#0x3f
   \   000056   6410         XRL     A,#0x10
   \   000058   600B         JZ      ??output_1
   1391              packetbuf_set_attr(PACKETBUF_ATTR_PACKET_TYPE,
   1392                                 PACKETBUF_ATTR_PACKET_TYPE_STREAM);
   \   00005A                ; Setup parameters for call to function packetbuf_set_attr
   \   00005A   7A02         MOV     R2,#0x2
   \   00005C   7B00         MOV     R3,#0x0
   \   00005E   790E         MOV     R1,#0xe
   \   000060   12....       LCALL   ??packetbuf_set_attr?relay
   \   000063   8019         SJMP    ??output_2
   1393            } else if(UIP_IP_BUF->proto == UIP_PROTO_TCP &&
   1394                      (UIP_TCP_BUF->flags & TCP_FIN) == TCP_FIN) {
   \                     ??output_1:
   \   000065   90....       MOV     DPTR,#uip_aligned_buf + 6
   \   000068   E0           MOVX    A,@DPTR
   \   000069   6406         XRL     A,#0x6
   \   00006B   7011         JNZ     ??output_2
   \   00006D   90....       MOV     DPTR,#uip_aligned_buf + 53
   \   000070   E0           MOVX    A,@DPTR
   \   000071   A2E0         MOV     C,0xE0 /* A   */.0
   \   000073   5009         JNC     ??output_2
   1395              packetbuf_set_attr(PACKETBUF_ATTR_PACKET_TYPE,
   1396                                 PACKETBUF_ATTR_PACKET_TYPE_STREAM_END);
   \   000075                ; Setup parameters for call to function packetbuf_set_attr
   \   000075   7A03         MOV     R2,#0x3
   \   000077   7B00         MOV     R3,#0x0
   \   000079   790E         MOV     R1,#0xe
   \   00007B   12....       LCALL   ??packetbuf_set_attr?relay
   1397            }
   1398          
   1399            /*
   1400             * The destination address will be tagged to each outbound
   1401             * packet. If the argument localdest is NULL, we are sending a
   1402             * broadcast packet.
   1403             */
   1404            if(localdest == NULL) {
   \                     ??output_2:
   \   00007E   EE           MOV     A,R6
   \   00007F   4F           ORL     A,R7
   \   000080   7013         JNZ     ??output_3
   1405              rimeaddr_copy(&dest, &rimeaddr_null);
   \   000082                ; Setup parameters for call to function rimeaddr_copy
   \   000082   7C..         MOV     R4,#rimeaddr_null & 0xff
   \   000084   7D..         MOV     R5,#(rimeaddr_null >> 8) & 0xff
   \   000086   85..82       MOV     DPL,?XSP + 0
   \   000089   85..83       MOV     DPH,?XSP + 1
   \   00008C   AA82         MOV     R2,DPL
   \   00008E   AB83         MOV     R3,DPH
   \   000090   12....       LCALL   ??rimeaddr_copy?relay
   \   000093   8011         SJMP    ??output_4
   1406            } else {
   1407              rimeaddr_copy(&dest, (const rimeaddr_t *)localdest);
   \                     ??output_3:
   \   000095                ; Setup parameters for call to function rimeaddr_copy
   \   000095   EE           MOV     A,R6
   \   000096   FC           MOV     R4,A
   \   000097   EF           MOV     A,R7
   \   000098   FD           MOV     R5,A
   \   000099   85..82       MOV     DPL,?XSP + 0
   \   00009C   85..83       MOV     DPH,?XSP + 1
   \   00009F   AA82         MOV     R2,DPL
   \   0000A1   AB83         MOV     R3,DPH
   \   0000A3   12....       LCALL   ??rimeaddr_copy?relay
   1408            }
   1409            
   1410            PRINTFO("sicslowpan output: sending packet len %d\n", uip_len);
   1411          
   1412            if(uip_len >= COMPRESSION_THRESHOLD) {
                              ^
Warning[Pe186]: pointless comparison of unsigned integer with zero

    uint16_t processed_ip_out_len;
             ^
"D:\myWork\myWork\core\net\sicslowpan.c",1365  Warning[Pe177]: variable
          "processed_ip_out_len" was declared but never referenced
   1413              /* Try to compress the headers */
   1414          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1
   1415              compress_hdr_hc1(&dest);
   1416          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1 */
   1417          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_IPV6
   1418              compress_hdr_ipv6(&dest);
   1419          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_IPV6 */
   1420          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
   1421              compress_hdr_hc06(&dest);
   \                     ??output_4:
   \   0000A6                ; Setup parameters for call to function compress_hdr_hc06
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   AA82         MOV     R2,DPL
   \   0000AE   AB83         MOV     R3,DPH
   \   0000B0   12....       LCALL   ??compress_hdr_hc06?relay
   1422          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
   1423            } else {
   1424              compress_hdr_ipv6(&dest);
   1425            }
   1426            PRINTFO("sicslowpan output: header of len %d\n", rime_hdr_len);
   1427          
   1428            /* Calculate NETSTACK_FRAMER's header length, that will be added in the NETSTACK_RDC.
   1429             * We calculate it here only to make a better decision of whether the outgoing packet
   1430             * needs to be fragmented or not. */
   1431          #define USE_FRAMER_HDRLEN 1
   1432          #if USE_FRAMER_HDRLEN
   1433            packetbuf_clear();
   \   0000B3                ; Setup parameters for call to function packetbuf_clear
   \   0000B3   12....       LCALL   ??packetbuf_clear?relay
   1434            packetbuf_set_addr(PACKETBUF_ADDR_RECEIVER, &dest);
   \   0000B6                ; Setup parameters for call to function packetbuf_set_addr
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   AA82         MOV     R2,DPL
   \   0000BE   AB83         MOV     R3,DPH
   \   0000C0   7919         MOV     R1,#0x19
   \   0000C2   12....       LCALL   ??packetbuf_set_addr?relay
   1435            framer_hdrlen = NETSTACK_FRAMER.create();
   \   0000C5                ; Setup parameters for indirect call
   \   0000C5   90....       MOV     DPTR,#framer_802154
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   F8           MOV     R0,A
   \   0000CA   A3           INC     DPTR
   \   0000CB   E0           MOVX    A,@DPTR
   \   0000CC   F583         MOV     DPH,A
   \   0000CE   8882         MOV     DPL,R0
   \   0000D0   12....       LCALL   ?CALL_IND
   \   0000D3   8A..         MOV     ?V0 + 0,R2
   \   0000D5   8B..         MOV     ?V0 + 1,R3
   \   0000D7   AE..         MOV     R6,?V0 + 0
   \   0000D9   AF..         MOV     R7,?V0 + 1
   1436            if(framer_hdrlen < 0) {
   \   0000DB   C3           CLR     C
   \   0000DC   EE           MOV     A,R6
   \   0000DD   9400         SUBB    A,#0x0
   \   0000DF   EF           MOV     A,R7
   \   0000E0   9400         SUBB    A,#0x0
   \   0000E2   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000E4   65D0         XRL     A,PSW
   \   0000E6   33           RLC     A
   \   0000E7   5004         JNC     ??output_5
   1437              /* Framing failed, we assume the maximum header length */
   1438              framer_hdrlen = 21;
   \   0000E9   7E15         MOV     R6,#0x15
   \   0000EB   7F00         MOV     R7,#0x0
   1439            }
   1440            packetbuf_clear();
   \                     ??output_5:
   \   0000ED                ; Setup parameters for call to function packetbuf_clear
   \   0000ED   12....       LCALL   ??packetbuf_clear?relay
   1441          
   1442            /* We must set the max transmissions attribute again after clearing
   1443               the buffer. */
   1444            packetbuf_set_attr(PACKETBUF_ATTR_MAX_MAC_TRANSMISSIONS,
   1445                               SICSLOWPAN_MAX_MAC_TRANSMISSIONS);
   \   0000F0                ; Setup parameters for call to function packetbuf_set_attr
   \   0000F0   7A04         MOV     R2,#0x4
   \   0000F2   7B00         MOV     R3,#0x0
   \   0000F4   7909         MOV     R1,#0x9
   \   0000F6   12....       LCALL   ??packetbuf_set_attr?relay
   1446          #else /* USE_FRAMER_HDRLEN */
   1447            framer_hdrlen = 21;
   1448          #endif /* USE_FRAMER_HDRLEN */
   1449          
   1450            if((int)uip_len - (int)uncomp_hdr_len > (int)MAC_MAX_PAYLOAD - framer_hdrlen - (int)rime_hdr_len) {
   \   0000F9   7466         MOV     A,#0x66
   \   0000FB   C3           CLR     C
   \   0000FC   9E           SUBB    A,R6
   \   0000FD   F8           MOV     R0,A
   \   0000FE   7400         MOV     A,#0x0
   \   000100   9F           SUBB    A,R7
   \   000101   F9           MOV     R1,A
   \   000102   90....       MOV     DPTR,#rime_hdr_len
   \   000105   E0           MOVX    A,@DPTR
   \   000106   FA           MOV     R2,A
   \   000107   7B00         MOV     R3,#0x0
   \   000109   E8           MOV     A,R0
   \   00010A   C3           CLR     C
   \   00010B   9A           SUBB    A,R2
   \   00010C   F8           MOV     R0,A
   \   00010D   E9           MOV     A,R1
   \   00010E   9B           SUBB    A,R3
   \   00010F   F9           MOV     R1,A
   \   000110   90....       MOV     DPTR,#uip_len
   \   000113   C082         PUSH    DPL
   \   000115   C083         PUSH    DPH
   \   000117   90....       MOV     DPTR,#uncomp_hdr_len
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   FA           MOV     R2,A
   \   00011C   7B00         MOV     R3,#0x0
   \   00011E   D083         POP     DPH
   \   000120   D082         POP     DPL
   \   000122   E0           MOVX    A,@DPTR
   \   000123   C3           CLR     C
   \   000124   9A           SUBB    A,R2
   \   000125   FA           MOV     R2,A
   \   000126   A3           INC     DPTR
   \   000127   E0           MOVX    A,@DPTR
   \   000128   9B           SUBB    A,R3
   \   000129   FB           MOV     R3,A
   \   00012A   C3           CLR     C
   \   00012B   E8           MOV     A,R0
   \   00012C   9A           SUBB    A,R2
   \   00012D   E9           MOV     A,R1
   \   00012E   9B           SUBB    A,R3
   \   00012F   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000131   65D0         XRL     A,PSW
   \   000133   33           RLC     A
   \   000134   5005         JNC     ??output_6
   1451          #if SICSLOWPAN_CONF_FRAG
   1452              struct queuebuf *q;
   1453              /*
   1454               * The outbound IPv6 packet is too large to fit into a single 15.4
   1455               * packet, so we fragment it into multiple packets and send them.
   1456               * The first fragment contains frag1 dispatch, then
   1457               * IPv6/HC1/HC06/HC_UDP dispatchs/headers.
   1458               * The following fragments contain only the fragn dispatch.
   1459               */
   1460          
   1461              PRINTFO("Fragmentation sending packet len %d\n", uip_len);
   1462          
   1463              /* Create 1st Fragment */
   1464              PRINTFO("sicslowpan output: 1rst fragment ");
   1465          
   1466              /* move HC1/HC06/IPv6 header */
   1467              memmove(rime_ptr + SICSLOWPAN_FRAG1_HDR_LEN, rime_ptr, rime_hdr_len);
   1468          
   1469              /*
   1470               * FRAG1 dispatch + header
   1471               * Note that the length is in units of 8 bytes
   1472               */
   1473          /*     RIME_FRAG_BUF->dispatch_size = */
   1474          /*       uip_htons((SICSLOWPAN_DISPATCH_FRAG1 << 8) | uip_len); */
   1475              SET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE,
   1476                    ((SICSLOWPAN_DISPATCH_FRAG1 << 8) | uip_len));
   1477          /*     RIME_FRAG_BUF->tag = uip_htons(my_tag); */
   1478              SET16(RIME_FRAG_PTR, RIME_FRAG_TAG, my_tag);
   1479              my_tag++;
   1480          
   1481              /* Copy payload and send */
   1482              rime_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;
   1483              rime_payload_len = (MAC_MAX_PAYLOAD - framer_hdrlen - rime_hdr_len) & 0xf8;
   1484              PRINTFO("(len %d, tag %d)\n", rime_payload_len, my_tag);
   1485              memcpy(rime_ptr + rime_hdr_len,
   1486                     (uint8_t *)UIP_IP_BUF + uncomp_hdr_len, rime_payload_len);
   1487              packetbuf_set_datalen(rime_payload_len + rime_hdr_len);
   1488              q = queuebuf_new_from_packetbuf();
   1489              if(q == NULL) {
   1490                PRINTFO("could not allocate queuebuf for first fragment, dropping packet\n");
   1491                return 0;
   1492              }
   1493              send_packet(&dest);
   1494              queuebuf_to_packetbuf(q);
   1495              queuebuf_free(q);
   1496              q = NULL;
   1497          
   1498              /* Check tx result. */
   1499              if((last_tx_status == MAC_TX_COLLISION) ||
   1500                 (last_tx_status == MAC_TX_ERR) ||
   1501                 (last_tx_status == MAC_TX_ERR_FATAL)) {
   1502                PRINTFO("error in fragment tx, dropping subsequent fragments.\n");
   1503                return 0;
   1504              }
   1505          
   1506              /* set processed_ip_out_len to what we already sent from the IP payload*/
   1507              processed_ip_out_len = rime_payload_len + uncomp_hdr_len;
   1508              
   1509              /*
   1510               * Create following fragments
   1511               * Datagram tag is already in the buffer, we need to set the
   1512               * FRAGN dispatch and for each fragment, the offset
   1513               */
   1514              rime_hdr_len = SICSLOWPAN_FRAGN_HDR_LEN;
   1515          /*     RIME_FRAG_BUF->dispatch_size = */
   1516          /*       uip_htons((SICSLOWPAN_DISPATCH_FRAGN << 8) | uip_len); */
   1517              SET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE,
   1518                    ((SICSLOWPAN_DISPATCH_FRAGN << 8) | uip_len));
   1519              rime_payload_len = (MAC_MAX_PAYLOAD - framer_hdrlen - rime_hdr_len) & 0xf8;
   1520              while(processed_ip_out_len < uip_len) {
   1521                PRINTFO("sicslowpan output: fragment ");
   1522                RIME_FRAG_PTR[RIME_FRAG_OFFSET] = processed_ip_out_len >> 3;
   1523                
   1524                /* Copy payload and send */
   1525                if(uip_len - processed_ip_out_len < rime_payload_len) {
   1526                  /* last fragment */
   1527                  rime_payload_len = uip_len - processed_ip_out_len;
   1528                }
   1529                PRINTFO("(offset %d, len %d, tag %d)\n",
   1530                       processed_ip_out_len >> 3, rime_payload_len, my_tag);
   1531                memcpy(rime_ptr + rime_hdr_len,
   1532                       (uint8_t *)UIP_IP_BUF + processed_ip_out_len, rime_payload_len);
   1533                packetbuf_set_datalen(rime_payload_len + rime_hdr_len);
   1534                q = queuebuf_new_from_packetbuf();
   1535                if(q == NULL) {
   1536                  PRINTFO("could not allocate queuebuf, dropping fragment\n");
   1537                  return 0;
   1538                }
   1539                send_packet(&dest);
   1540                queuebuf_to_packetbuf(q);
   1541                queuebuf_free(q);
   1542                q = NULL;
   1543                processed_ip_out_len += rime_payload_len;
   1544          
   1545                /* Check tx result. */
   1546                if((last_tx_status == MAC_TX_COLLISION) ||
   1547                   (last_tx_status == MAC_TX_ERR) ||
   1548                   (last_tx_status == MAC_TX_ERR_FATAL)) {
   1549                  PRINTFO("error in fragment tx, dropping subsequent fragments.\n");
   1550                  return 0;
   1551                }
   1552              }
   1553          #else /* SICSLOWPAN_CONF_FRAG */
   1554              PRINTFO("sicslowpan output: Packet too large to be sent without fragmentation support; dropping packet\n");
   1555              return 0;
   \   000136   7900         MOV     R1,#0x0
   \   000138   02....       LJMP    ??output_7 & 0xFFFF
   1556          #endif /* SICSLOWPAN_CONF_FRAG */
   1557            } else {
   1558          
   1559              /*
   1560               * The packet does not need to be fragmented
   1561               * copy "payload" and send
   1562               */
   1563              memcpy(rime_ptr + rime_hdr_len, (uint8_t *)UIP_IP_BUF + uncomp_hdr_len,
   1564                     uip_len - uncomp_hdr_len);
   \                     ??output_6:
   \   00013B                ; Setup parameters for call to function memcpy
   \   00013B   90....       MOV     DPTR,#uip_len
   \   00013E   C082         PUSH    DPL
   \   000140   C083         PUSH    DPH
   \   000142   90....       MOV     DPTR,#uncomp_hdr_len
   \   000145   E0           MOVX    A,@DPTR
   \   000146   F8           MOV     R0,A
   \   000147   7900         MOV     R1,#0x0
   \   000149   D083         POP     DPH
   \   00014B   D082         POP     DPL
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   C3           CLR     C
   \   00014F   98           SUBB    A,R0
   \   000150   F5..         MOV     ?V0 + 0,A
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   99           SUBB    A,R1
   \   000155   F5..         MOV     ?V0 + 1,A
   \   000157   78..         MOV     R0,#?V0 + 0
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015C   90....       MOV     DPTR,#uncomp_hdr_len
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   F8           MOV     R0,A
   \   000161   7900         MOV     R1,#0x0
   \   000163   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000165   28           ADD     A,R0
   \   000166   FC           MOV     R4,A
   \   000167   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   000169   39           ADDC    A,R1
   \   00016A   FD           MOV     R5,A
   \   00016B   90....       MOV     DPTR,#rime_hdr_len
   \   00016E   E0           MOVX    A,@DPTR
   \   00016F   F8           MOV     R0,A
   \   000170   7900         MOV     R1,#0x0
   \   000172   90....       MOV     DPTR,#rime_ptr
   \   000175   E0           MOVX    A,@DPTR
   \   000176   28           ADD     A,R0
   \   000177   FA           MOV     R2,A
   \   000178   A3           INC     DPTR
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   39           ADDC    A,R1
   \   00017B   FB           MOV     R3,A
   \   00017C   12....       LCALL   ??memcpy?relay
   \   00017F   7402         MOV     A,#0x2
   \   000181   12....       LCALL   ?DEALLOC_XSTACK8
   1565              packetbuf_set_datalen(uip_len - uncomp_hdr_len + rime_hdr_len);
   \   000184                ; Setup parameters for call to function packetbuf_set_datalen
   \   000184   90....       MOV     DPTR,#uip_len
   \   000187   C082         PUSH    DPL
   \   000189   C083         PUSH    DPH
   \   00018B   90....       MOV     DPTR,#uncomp_hdr_len
   \   00018E   E0           MOVX    A,@DPTR
   \   00018F   F8           MOV     R0,A
   \   000190   7900         MOV     R1,#0x0
   \   000192   D083         POP     DPH
   \   000194   D082         POP     DPL
   \   000196   E0           MOVX    A,@DPTR
   \   000197   C3           CLR     C
   \   000198   98           SUBB    A,R0
   \   000199   F8           MOV     R0,A
   \   00019A   A3           INC     DPTR
   \   00019B   E0           MOVX    A,@DPTR
   \   00019C   99           SUBB    A,R1
   \   00019D   F9           MOV     R1,A
   \   00019E   90....       MOV     DPTR,#rime_hdr_len
   \   0001A1   E0           MOVX    A,@DPTR
   \   0001A2   FA           MOV     R2,A
   \   0001A3   7B00         MOV     R3,#0x0
   \   0001A5   E8           MOV     A,R0
   \   0001A6   2A           ADD     A,R2
   \   0001A7   FA           MOV     R2,A
   \   0001A8   E9           MOV     A,R1
   \   0001A9   3B           ADDC    A,R3
   \   0001AA   FB           MOV     R3,A
   \   0001AB   12....       LCALL   ??packetbuf_set_datalen?relay
   1566              send_packet(&dest);
   \   0001AE                ; Setup parameters for call to function send_packet
   \   0001AE   85..82       MOV     DPL,?XSP + 0
   \   0001B1   85..83       MOV     DPH,?XSP + 1
   \   0001B4   AA82         MOV     R2,DPL
   \   0001B6   AB83         MOV     R3,DPH
   \   0001B8   12....       LCALL   ??send_packet?relay
   1567            }
   1568            return 1;
   \   0001BB   7901         MOV     R1,#0x1
   \                     ??output_7:
   \   0001BD   7402         MOV     A,#0x2
   \   0001BF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001C2   7F02         MOV     R7,#0x2
   \   0001C4   02....       LJMP    ?BANKED_LEAVE_XDATA
   1569          }
   1570          
   1571          /*--------------------------------------------------------------------*/
   1572          /** \brief Process a received 6lowpan packet.
   1573           *  \param r The MAC layer
   1574           *
   1575           *  The 6lowpan packet is put in packetbuf by the MAC. If its a frag1 or
   1576           *  a non-fragmented packet we first uncompress the IP header. The
   1577           *  6lowpan payload and possibly the uncompressed IP header are then
   1578           *  copied in siclowpan_buf. If the IP packet is complete it is copied
   1579           *  to uip_buf and the IP layer is called.
   1580           *
   1581           * \note We do not check for overlapping sicslowpan fragments
   1582           * (it is a SHALL in the RFC 4944 and should never happen)
   1583           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1584          static void
   1585          input(void)
   \                     input:
   1586          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1587            /* size of the IP packet (read from fragment) */
   1588            uint16_t frag_size = 0;
   \   000005   7E00         MOV     R6,#0x0
   \   000007   7F00         MOV     R7,#0x0
   1589            /* offset of the fragment in the IP packet */
   1590            uint8_t frag_offset = 0;
   \   000009   75..00       MOV     ?V0 + 1,#0x0
   1591            uint8_t is_fragment = 0;
                           ^
Warning[Pe177]: variable "is_fragment" was declared but never referenced
   \   00000C   75..00       MOV     ?V0 + 0,#0x0
   1592          #if SICSLOWPAN_CONF_FRAG
   1593            /* tag of the fragment */
   1594            uint16_t frag_tag = 0;
   1595            uint8_t first_fragment = 0, last_fragment = 0;
   1596          #endif /*SICSLOWPAN_CONF_FRAG*/
   1597          
   1598            /* init */
   1599            uncomp_hdr_len = 0;
   \   00000F   90....       MOV     DPTR,#uncomp_hdr_len
   \   000012   7400         MOV     A,#0x0
   \   000014   F0           MOVX    @DPTR,A
   1600            rime_hdr_len = 0;
   \   000015   90....       MOV     DPTR,#rime_hdr_len
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
   1601          
   1602            /* The MAC puts the 15.4 payload inside the RIME data buffer */
   1603            rime_ptr = packetbuf_dataptr();
   \   00001B                ; Setup parameters for call to function packetbuf_dataptr
   \   00001B   12....       LCALL   ??packetbuf_dataptr?relay
   \   00001E   90....       MOV     DPTR,#rime_ptr
   \   000021   EA           MOV     A,R2
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   EB           MOV     A,R3
   \   000025   F0           MOVX    @DPTR,A
   1604          
   1605          #if SICSLOWPAN_CONF_FRAG
   1606            /* if reassembly timed out, cancel it */
   1607            if(timer_expired(&reass_timer)) {
   1608              sicslowpan_len = 0;
   1609              processed_ip_in_len = 0;
   1610            }
   1611            /*
   1612             * Since we don't support the mesh and broadcast header, the first header
   1613             * we look for is the fragmentation header
   1614             */
   1615            switch((GET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE) & 0xf800) >> 8) {
   1616              case SICSLOWPAN_DISPATCH_FRAG1:
   1617                PRINTFI("sicslowpan input: FRAG1 ");
   1618                frag_offset = 0;
   1619          /*       frag_size = (uip_ntohs(RIME_FRAG_BUF->dispatch_size) & 0x07ff); */
   1620                frag_size = GET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE) & 0x07ff;
   1621          /*       frag_tag = uip_ntohs(RIME_FRAG_BUF->tag); */
   1622                frag_tag = GET16(RIME_FRAG_PTR, RIME_FRAG_TAG);
   1623                PRINTFI("size %d, tag %d, offset %d)\n",
   1624                       frag_size, frag_tag, frag_offset);
   1625                rime_hdr_len += SICSLOWPAN_FRAG1_HDR_LEN;
   1626                /*      printf("frag1 %d %d\n", reass_tag, frag_tag);*/
   1627                first_fragment = 1;
   1628                is_fragment = 1;
   1629                break;
   1630              case SICSLOWPAN_DISPATCH_FRAGN:
   1631                /*
   1632                 * set offset, tag, size
   1633                 * Offset is in units of 8 bytes
   1634                 */
   1635                PRINTFI("sicslowpan input: FRAGN ");
   1636                frag_offset = RIME_FRAG_PTR[RIME_FRAG_OFFSET];
   1637                frag_tag = GET16(RIME_FRAG_PTR, RIME_FRAG_TAG);
   1638                frag_size = GET16(RIME_FRAG_PTR, RIME_FRAG_DISPATCH_SIZE) & 0x07ff;
   1639                PRINTFI("size %d, tag %d, offset %d)\n",
   1640                       frag_size, frag_tag, frag_offset);
   1641                rime_hdr_len += SICSLOWPAN_FRAGN_HDR_LEN;
   1642          
   1643                /* If this is the last fragment, we may shave off any extrenous
   1644                   bytes at the end. We must be liberal in what we accept. */
   1645                PRINTFI("last_fragment?: processed_ip_in_len %d rime_payload_len %d frag_size %d\n",
   1646                        processed_ip_in_len, packetbuf_datalen() - rime_hdr_len, frag_size);
   1647          
   1648                if(processed_ip_in_len + packetbuf_datalen() - rime_hdr_len >= frag_size) {
   1649                  last_fragment = 1;
   1650                }
   1651                is_fragment = 1;
   1652                break;
   1653              default:
   1654                break;
   1655            }
   1656          
   1657            /* We are currently reassembling a packet, but have just received the first
   1658             * fragment of another packet. We can either ignore it and hope to receive
   1659             * the rest of the under-reassembly packet fragments, or we can discard the
   1660             * previous packet altogether, and start reassembling the new packet.
   1661             *
   1662             * We discard the previous packet, and start reassembling the new packet.
   1663             * This lessens the negative impacts of too high SICSLOWPAN_REASS_MAXAGE.
   1664             */
   1665          #define PRIORITIZE_NEW_PACKETS 1
   1666          #if PRIORITIZE_NEW_PACKETS
   1667            if(processed_ip_in_len > 0 && first_fragment
   1668                && !rimeaddr_cmp(&frag_sender, packetbuf_addr(PACKETBUF_ADDR_SENDER))) {
   1669              sicslowpan_len = 0;
   1670              processed_ip_in_len = 0;
   1671            }
   1672          #endif /* PRIORITIZE_NEW_PACKETS */
   1673          
   1674            if(processed_ip_in_len > 0) {
   1675              /* reassembly is ongoing */
   1676              /*    printf("frag %d %d\n", reass_tag, frag_tag);*/
   1677              if((frag_size > 0 &&
   1678                  (frag_size != sicslowpan_len ||
   1679                   reass_tag  != frag_tag ||
   1680                   !rimeaddr_cmp(&frag_sender, packetbuf_addr(PACKETBUF_ADDR_SENDER))))  ||
   1681                 frag_size == 0) {
   1682                /*
   1683                 * the packet is a fragment that does not belong to the packet
   1684                 * being reassembled or the packet is not a fragment.
   1685                 */
   1686                PRINTFI("sicslowpan input: Dropping 6lowpan packet that is not a fragment of the packet currently being reassembled\n");
   1687                return;
   1688              }
   1689            } else {
   1690              /*
   1691               * reassembly is off
   1692               * start it if we received a fragment
   1693               */
   1694              if((frag_size > 0) && (frag_size <= UIP_BUFSIZE)) {
   1695                /* We are currently not reassembling a packet, but have received a packet fragment
   1696                 * that is not the first one. */
   1697                if(is_fragment && !first_fragment) {
   1698                  return;
   1699                }
   1700          
   1701                sicslowpan_len = frag_size;
   1702                reass_tag = frag_tag;
   1703                timer_set(&reass_timer, SICSLOWPAN_REASS_MAXAGE * CLOCK_SECOND / 16);
   1704                PRINTFI("sicslowpan input: INIT FRAGMENTATION (len %d, tag %d)\n",
   1705                       sicslowpan_len, reass_tag);
   1706                rimeaddr_copy(&frag_sender, packetbuf_addr(PACKETBUF_ADDR_SENDER));
   1707              }
   1708            }
   1709          
   1710            if(rime_hdr_len == SICSLOWPAN_FRAGN_HDR_LEN) {
   1711              /* this is a FRAGN, skip the header compression dispatch section */
   1712              goto copypayload;
   1713            }
   1714          #endif /* SICSLOWPAN_CONF_FRAG */
   1715          
   1716            /* Process next dispatch and headers */
   1717          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
   1718            if((RIME_HC1_PTR[RIME_HC1_DISPATCH] & 0xe0) == SICSLOWPAN_DISPATCH_IPHC) {
   \   000026   90....       MOV     DPTR,#rime_hdr_len
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F8           MOV     R0,A
   \   00002B   7900         MOV     R1,#0x0
   \   00002D   90....       MOV     DPTR,#rime_ptr
   \   000030   E0           MOVX    A,@DPTR
   \   000031   28           ADD     A,R0
   \   000032   FA           MOV     R2,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   39           ADDC    A,R1
   \   000036   8A82         MOV     DPL,R2
   \   000038   F583         MOV     DPH,A
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   54E0         ANL     A,#0xe0
   \   00003D   6460         XRL     A,#0x60
   \   00003F   7025         JNZ     ??input_0
   1719              PRINTFI("sicslowpan input: IPHC\n");
   1720              uncompress_hdr_hc06(frag_size);
   \   000041                ; Setup parameters for call to function uncompress_hdr_hc06
   \   000041   EE           MOV     A,R6
   \   000042   FA           MOV     R2,A
   \   000043   EF           MOV     A,R7
   \   000044   FB           MOV     R3,A
   \   000045   12....       LCALL   ??uncompress_hdr_hc06?relay
   1721            } else
   1722          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
   1723              switch(RIME_HC1_PTR[RIME_HC1_DISPATCH]) {
   1724          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1
   1725              case SICSLOWPAN_DISPATCH_HC1:
   1726                PRINTFI("sicslowpan input: HC1\n");
   1727                uncompress_hdr_hc1(frag_size);
   1728                break;
   1729          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC1 */
   1730              case SICSLOWPAN_DISPATCH_IPV6:
   1731                PRINTFI("sicslowpan input: IPV6\n");
   1732                rime_hdr_len += SICSLOWPAN_IPV6_HDR_LEN;
   1733          
   1734                /* Put uncompressed IP header in sicslowpan_buf. */
   1735                memcpy(SICSLOWPAN_IP_BUF, rime_ptr + rime_hdr_len, UIP_IPH_LEN);
   1736          
   1737                /* Update uncomp_hdr_len and rime_hdr_len. */
   1738                rime_hdr_len += UIP_IPH_LEN;
   1739                uncomp_hdr_len += UIP_IPH_LEN;
   1740                break;
   1741              default:
   1742                /* unknown header */
   1743                PRINTFI("sicslowpan input: unknown dispatch: %u\n",
   1744                       RIME_HC1_PTR[RIME_HC1_DISPATCH]);
   1745                return;
   1746            }
   1747             
   1748              
   1749          #if SICSLOWPAN_CONF_FRAG
   1750           copypayload:
   1751          #endif /*SICSLOWPAN_CONF_FRAG*/
   1752            /*
   1753             * copy "payload" from the rime buffer to the sicslowpan_buf
   1754             * if this is a first fragment or not fragmented packet,
   1755             * we have already copied the compressed headers, uncomp_hdr_len
   1756             * and rime_hdr_len are non 0, frag_offset is.
   1757             * If this is a subsequent fragment, this is the contrary.
   1758             */
   1759            if(packetbuf_datalen() < rime_hdr_len) {
   \                     ??input_1:
   \   000048                ; Setup parameters for call to function packetbuf_datalen
   \   000048   12....       LCALL   ??packetbuf_datalen?relay
   \   00004B   8A..         MOV     ?V0 + 2,R2
   \   00004D   8B..         MOV     ?V0 + 3,R3
   \   00004F   A8..         MOV     R0,?V0 + 2
   \   000051   A9..         MOV     R1,?V0 + 3
   \   000053   90....       MOV     DPTR,#rime_hdr_len
   \   000056   E0           MOVX    A,@DPTR
   \   000057   FA           MOV     R2,A
   \   000058   7B00         MOV     R3,#0x0
   \   00005A   C3           CLR     C
   \   00005B   E5..         MOV     A,?V0 + 2
   \   00005D   9A           SUBB    A,R2
   \   00005E   E5..         MOV     A,?V0 + 3
   \   000060   9B           SUBB    A,R3
   \   000061   505E         JNC     ??input_2
   1760              PRINTF("SICSLOWPAN: packet dropped due to header > total packet\n");
   1761              return;
   \   000063   02....       LJMP    ??input_3 & 0xFFFF
   1762            }
   \                     ??input_0:
   \   000066   90....       MOV     DPTR,#rime_hdr_len
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   F8           MOV     R0,A
   \   00006B   7900         MOV     R1,#0x0
   \   00006D   90....       MOV     DPTR,#rime_ptr
   \   000070   E0           MOVX    A,@DPTR
   \   000071   28           ADD     A,R0
   \   000072   FA           MOV     R2,A
   \   000073   A3           INC     DPTR
   \   000074   E0           MOVX    A,@DPTR
   \   000075   39           ADDC    A,R1
   \   000076   8A82         MOV     DPL,R2
   \   000078   F583         MOV     DPH,A
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   6441         XRL     A,#0x41
   \   00007D   703F         JNZ     ??input_4
   \   00007F   90....       MOV     DPTR,#rime_hdr_len
   \   000082   E0           MOVX    A,@DPTR
   \   000083   2401         ADD     A,#0x1
   \   000085   F0           MOVX    @DPTR,A
   \   000086                ; Setup parameters for call to function memcpy
   \   000086   75..28       MOV     ?V0 + 2,#0x28
   \   000089   75..00       MOV     ?V0 + 3,#0x0
   \   00008C   78..         MOV     R0,#?V0 + 2
   \   00008E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000091   90....       MOV     DPTR,#rime_hdr_len
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F8           MOV     R0,A
   \   000096   7900         MOV     R1,#0x0
   \   000098   90....       MOV     DPTR,#rime_ptr
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   28           ADD     A,R0
   \   00009D   FC           MOV     R4,A
   \   00009E   A3           INC     DPTR
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   39           ADDC    A,R1
   \   0000A1   FD           MOV     R5,A
   \   0000A2   7A..         MOV     R2,#uip_aligned_buf & 0xff
   \   0000A4   7B..         MOV     R3,#(uip_aligned_buf >> 8) & 0xff
   \   0000A6   12....       LCALL   ??memcpy?relay
   \   0000A9   7402         MOV     A,#0x2
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   90....       MOV     DPTR,#rime_hdr_len
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   2428         ADD     A,#0x28
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   90....       MOV     DPTR,#uncomp_hdr_len
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   2428         ADD     A,#0x28
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   808A         SJMP    ??input_1
   \                     ??input_4:
   \   0000BE   02....       LJMP    ??input_3 & 0xFFFF
   1763            rime_payload_len = packetbuf_datalen() - rime_hdr_len;
   \                     ??input_2:
   \   0000C1                ; Setup parameters for call to function packetbuf_datalen
   \   0000C1   12....       LCALL   ??packetbuf_datalen?relay
   \   0000C4   8A..         MOV     ?V0 + 2,R2
   \   0000C6   8B..         MOV     ?V0 + 3,R3
   \   0000C8   A8..         MOV     R0,?V0 + 2
   \   0000CA   A9..         MOV     R1,?V0 + 3
   \   0000CC   90....       MOV     DPTR,#rime_hdr_len
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   FA           MOV     R2,A
   \   0000D1   E5..         MOV     A,?V0 + 2
   \   0000D3   C3           CLR     C
   \   0000D4   9A           SUBB    A,R2
   \   0000D5   90....       MOV     DPTR,#rime_payload_len
   \   0000D8   F0           MOVX    @DPTR,A
   1764          
   1765            /* Sanity-check size of incoming packet to avoid buffer overflow */
   1766            {
   1767              int req_size = UIP_LLH_LEN + uncomp_hdr_len + (uint16_t)(frag_offset << 3)
   1768                  + rime_payload_len;
   \   0000D9   90....       MOV     DPTR,#uncomp_hdr_len
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FA           MOV     R2,A
   \   0000DE   7B00         MOV     R3,#0x0
   \   0000E0   85....       MOV     ?V0 + 2,?V0 + 1
   \   0000E3   75..00       MOV     ?V0 + 3,#0x0
   \   0000E6   7403         MOV     A,#0x3
   \   0000E8   78..         MOV     R0,#?V0 + 2
   \   0000EA   12....       LCALL   ?S_SHL
   \   0000ED   EA           MOV     A,R2
   \   0000EE   25..         ADD     A,?V0 + 2
   \   0000F0   F8           MOV     R0,A
   \   0000F1   EB           MOV     A,R3
   \   0000F2   35..         ADDC    A,?V0 + 3
   \   0000F4   F9           MOV     R1,A
   \   0000F5   90....       MOV     DPTR,#rime_payload_len
   \   0000F8   E0           MOVX    A,@DPTR
   \   0000F9   FA           MOV     R2,A
   \   0000FA   7B00         MOV     R3,#0x0
   \   0000FC   E8           MOV     A,R0
   \   0000FD   2A           ADD     A,R2
   \   0000FE   F8           MOV     R0,A
   \   0000FF   E9           MOV     A,R1
   \   000100   3B           ADDC    A,R3
   \   000101   F9           MOV     R1,A
   1769              if(req_size > sizeof(sicslowpan_buf)) {
   \   000102   C3           CLR     C
   \   000103   E8           MOV     A,R0
   \   000104   94F1         SUBB    A,#-0xf
   \   000106   E9           MOV     A,R1
   \   000107   9400         SUBB    A,#0x0
   \   000109   4003         JC      $+5
   \   00010B   02....       LJMP    ??input_3 & 0xFFFF
   1770                PRINTF(
   1771                    "SICSLOWPAN: packet dropped, minimum required SICSLOWPAN_IP_BUF size: %d+%d+%d+%d=%d (current size: %d)\n",
   1772                    UIP_LLH_LEN, uncomp_hdr_len, (uint16_t)(frag_offset << 3),
   1773                    rime_payload_len, req_size, sizeof(sicslowpan_buf));
   1774                return;
   1775              }
   1776            }
   1777          
   1778            memcpy((uint8_t *)SICSLOWPAN_IP_BUF + uncomp_hdr_len + (uint16_t)(frag_offset << 3), rime_ptr + rime_hdr_len, rime_payload_len);
   \   00010E                ; Setup parameters for call to function memcpy
   \   00010E   90....       MOV     DPTR,#rime_payload_len
   \   000111   E0           MOVX    A,@DPTR
   \   000112   F5..         MOV     ?V0 + 0,A
   \   000114   85....       MOV     ?V0 + 2,?V0 + 0
   \   000117   75..00       MOV     ?V0 + 3,#0x0
   \   00011A   78..         MOV     R0,#?V0 + 2
   \   00011C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011F   90....       MOV     DPTR,#rime_hdr_len
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F8           MOV     R0,A
   \   000124   7900         MOV     R1,#0x0
   \   000126   90....       MOV     DPTR,#rime_ptr
   \   000129   E0           MOVX    A,@DPTR
   \   00012A   28           ADD     A,R0
   \   00012B   FC           MOV     R4,A
   \   00012C   A3           INC     DPTR
   \   00012D   E0           MOVX    A,@DPTR
   \   00012E   39           ADDC    A,R1
   \   00012F   FD           MOV     R5,A
   \   000130   85....       MOV     ?V0 + 0,?V0 + 1
   \   000133   75..00       MOV     ?V0 + 1,#0x0
   \   000136   7403         MOV     A,#0x3
   \   000138   78..         MOV     R0,#?V0 + 0
   \   00013A   12....       LCALL   ?S_SHL
   \   00013D   90....       MOV     DPTR,#uncomp_hdr_len
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F8           MOV     R0,A
   \   000142   7900         MOV     R1,#0x0
   \   000144   74..         MOV     A,#uip_aligned_buf & 0xff
   \   000146   28           ADD     A,R0
   \   000147   F8           MOV     R0,A
   \   000148   74..         MOV     A,#(uip_aligned_buf >> 8) & 0xff
   \   00014A   39           ADDC    A,R1
   \   00014B   F9           MOV     R1,A
   \   00014C   E8           MOV     A,R0
   \   00014D   25..         ADD     A,?V0 + 0
   \   00014F   FA           MOV     R2,A
   \   000150   E9           MOV     A,R1
   \   000151   35..         ADDC    A,?V0 + 1
   \   000153   FB           MOV     R3,A
   \   000154   12....       LCALL   ??memcpy?relay
   \   000157   7402         MOV     A,#0x2
   \   000159   12....       LCALL   ?DEALLOC_XSTACK8
   1779            
   1780            /* update processed_ip_in_len if fragment, sicslowpan_len otherwise */
   1781          
   1782          #if SICSLOWPAN_CONF_FRAG
   1783            if(frag_size > 0) {
   1784              /* Add the size of the header only for the first fragment. */
   1785              if(first_fragment != 0) {
   1786                processed_ip_in_len += uncomp_hdr_len;
   1787              }
   1788              /* For the last fragment, we are OK if there is extrenous bytes at
   1789                 the end of the packet. */
   1790              if(last_fragment != 0) {
   1791                processed_ip_in_len = frag_size;
   1792              } else {
   1793                processed_ip_in_len += rime_payload_len;
   1794              }
   1795              PRINTF("processed_ip_in_len %d, rime_payload_len %d\n", processed_ip_in_len, rime_payload_len);
   1796          
   1797            } else {
   1798          #endif /* SICSLOWPAN_CONF_FRAG */
   1799              sicslowpan_len = rime_payload_len + uncomp_hdr_len;
   \   00015C   90....       MOV     DPTR,#rime_payload_len
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   F8           MOV     R0,A
   \   000161   7900         MOV     R1,#0x0
   \   000163   90....       MOV     DPTR,#uncomp_hdr_len
   \   000166   E0           MOVX    A,@DPTR
   \   000167   FA           MOV     R2,A
   \   000168   7B00         MOV     R3,#0x0
   \   00016A   E8           MOV     A,R0
   \   00016B   2A           ADD     A,R2
   \   00016C   F8           MOV     R0,A
   \   00016D   E9           MOV     A,R1
   \   00016E   3B           ADDC    A,R3
   \   00016F   F9           MOV     R1,A
   \   000170   90....       MOV     DPTR,#uip_len
   \   000173   E8           MOV     A,R0
   \   000174   F0           MOVX    @DPTR,A
   \   000175   A3           INC     DPTR
   \   000176   E9           MOV     A,R1
   \   000177   F0           MOVX    @DPTR,A
   1800          #if SICSLOWPAN_CONF_FRAG
   1801            }
   1802          
   1803            /*
   1804             * If we have a full IP packet in sicslowpan_buf, deliver it to
   1805             * the IP stack
   1806             */
   1807            PRINTF("sicslowpan_init processed_ip_in_len %d, sicslowpan_len %d\n",
   1808                   processed_ip_in_len, sicslowpan_len);
   1809            if(processed_ip_in_len == 0 || (processed_ip_in_len == sicslowpan_len)) {
   1810              PRINTFI("sicslowpan input: IP packet ready (length %d)\n",
   1811                     sicslowpan_len);
   1812              memcpy((uint8_t *)UIP_IP_BUF, (uint8_t *)SICSLOWPAN_IP_BUF, sicslowpan_len);
   1813              uip_len = sicslowpan_len;
   1814              sicslowpan_len = 0;
   1815              processed_ip_in_len = 0;
   1816          #endif /* SICSLOWPAN_CONF_FRAG */
   1817          
   1818          #if DEBUG
   1819              {
   1820                uint16_t ndx;
   1821                PRINTF("after decompression %u:", SICSLOWPAN_IP_BUF->len[1]);
   1822                for (ndx = 0; ndx < SICSLOWPAN_IP_BUF->len[1] + 40; ndx++) {
   1823                  uint8_t data = ((uint8_t *) (SICSLOWPAN_IP_BUF))[ndx];
   1824                  PRINTF("%02x", data);
   1825                }
   1826                PRINTF("\n");
   1827              }
   1828          #endif
   1829          
   1830              /* if callback is set then set attributes and call */
   1831              if(callback) {
   \   000178   90....       MOV     DPTR,#callback
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   F8           MOV     R0,A
   \   00017D   A3           INC     DPTR
   \   00017E   E0           MOVX    A,@DPTR
   \   00017F   F9           MOV     R1,A
   \   000180   E8           MOV     A,R0
   \   000181   49           ORL     A,R1
   \   000182   601B         JZ      ??input_5
   1832                set_packet_attrs();
   \   000184                ; Setup parameters for call to function set_packet_attrs
   \   000184   12....       LCALL   ??set_packet_attrs?relay
   1833                callback->input_callback();
   \   000187                ; Setup parameters for indirect call
   \   000187   90....       MOV     DPTR,#callback
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   F8           MOV     R0,A
   \   00018C   A3           INC     DPTR
   \   00018D   E0           MOVX    A,@DPTR
   \   00018E   F583         MOV     DPH,A
   \   000190   8882         MOV     DPL,R0
   \   000192   A3           INC     DPTR
   \   000193   A3           INC     DPTR
   \   000194   E0           MOVX    A,@DPTR
   \   000195   F8           MOV     R0,A
   \   000196   A3           INC     DPTR
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F583         MOV     DPH,A
   \   00019A   8882         MOV     DPL,R0
   \   00019C   12....       LCALL   ?CALL_IND
   1834              }
   1835          
   1836              tcpip_input();
   \                     ??input_5:
   \   00019F                ; Setup parameters for call to function tcpip_input
   \   00019F   12....       LCALL   ??tcpip_input?relay
   1837          #if SICSLOWPAN_CONF_FRAG
   1838            }
   1839          #endif /* SICSLOWPAN_CONF_FRAG */
   1840          }
   \                     ??input_3:
   \   0001A2   7F04         MOV     R7,#0x4
   \   0001A4   02....       LJMP    ?BANKED_LEAVE_XDATA
   1841          /** @} */
   1842          
   1843          /*--------------------------------------------------------------------*/
   1844          /* \brief 6lowpan init function (called by the MAC layer)             */
   1845          /*--------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1846          void
   1847          sicslowpan_init(void)
   \                     sicslowpan_init:
   1848          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1849            /*
   1850             * Set out output function as the function to be called from uIP to
   1851             * send a packet.
   1852             */
   1853            tcpip_set_outputfunc(output);
   \   000004                ; Setup parameters for call to function tcpip_set_outputfunc
   \   000004   7A..         MOV     R2,#??output?relay & 0xff
   \   000006   7B..         MOV     R3,#(??output?relay >> 8) & 0xff
   \   000008   12....       LCALL   ??tcpip_set_outputfunc?relay
   1854          
   1855          #if SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06
   1856          /* Preinitialize any address contexts for better header compression
   1857           * (Saves up to 13 bytes per 6lowpan packet)
   1858           * The platform contiki-conf.h file can override this using e.g.
   1859           * #define SICSLOWPAN_CONF_ADDR_CONTEXT_0 {addr_contexts[0].prefix[0]=0xbb;addr_contexts[0].prefix[1]=0xbb;}
   1860           */
   1861          #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 
   1862            addr_contexts[0].used   = 1;
   \   00000B   90....       MOV     DPTR,#addr_contexts
   \   00000E   7401         MOV     A,#0x1
   \   000010   F0           MOVX    @DPTR,A
   1863            addr_contexts[0].number = 0;
   \   000011   90....       MOV     DPTR,#addr_contexts + 1
   \   000014   7400         MOV     A,#0x0
   \   000016   F0           MOVX    @DPTR,A
   1864          #ifdef SICSLOWPAN_CONF_ADDR_CONTEXT_0
   1865          	SICSLOWPAN_CONF_ADDR_CONTEXT_0;
   \   000017   90....       MOV     DPTR,#addr_contexts + 2
   \   00001A   74AA         MOV     A,#-0x56
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   90....       MOV     DPTR,#addr_contexts + 3
   \   000020   74AA         MOV     A,#-0x56
   \   000022   F0           MOVX    @DPTR,A
   1866          #else
   1867            addr_contexts[0].prefix[0] = 0xaa; 
   1868            addr_contexts[0].prefix[1] = 0xaa;
   1869          #endif
   1870          #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 0 */
   1871          
   1872          #if SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 1
   1873            {
   1874              int i;
   1875              for(i = 1; i < SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS; i++) {
   1876          #ifdef SICSLOWPAN_CONF_ADDR_CONTEXT_1
   1877          	  if (i==1) {
   1878          	    addr_contexts[1].used   = 1;
   1879          		addr_contexts[1].number = 1;
   1880          		SICSLOWPAN_CONF_ADDR_CONTEXT_1;
   1881          #ifdef SICSLOWPAN_CONF_ADDR_CONTEXT_2
   1882                } else if (i==2) {
   1883          	  	addr_contexts[2].used   = 1;
   1884          		addr_contexts[2].number = 2;
   1885          		SICSLOWPAN_CONF_ADDR_CONTEXT_2;
   1886          #endif
   1887                } else {
   1888                  addr_contexts[i].used = 0;
   1889                }	  
   1890          #else
   1891                addr_contexts[i].used = 0;
   1892          #endif /* SICSLOWPAN_CONF_ADDR_CONTEXT_1 */
   1893          
   1894              }
   1895            }
   1896          #endif /* SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS > 1 */
   1897          
   1898          #endif /* SICSLOWPAN_COMPRESSION == SICSLOWPAN_COMPRESSION_HC06 */
   1899          }
   \   000023   D083         POP     DPH
   \   000025   D082         POP     DPL
   \   000027   02....       LJMP    ?BRET
   1900          /*--------------------------------------------------------------------*/

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1901          const struct network_driver sicslowpan_driver = {
   \                     sicslowpan_driver:
   \   000000                DS 6
   \   000006                REQUIRE `?<Initializer for sicslowpan_driver>`
   \   000006                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant "sicslowpan">>`:
   \   000000   73696373     DB "sicslowpan"
   \            6C6F7770
   \            616E00  

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for <Constant {255, 2}>>`:
   \   000000   FF           DB 255
   \   000001   02           DB 2

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for unc_llconf>`:
   \   000000   0F           DB 15
   \   000001   28           DB 40
   \   000002   22           DB 34
   \   000003   20           DB 32

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for unc_ctxconf>`:
   \   000000   00           DB 0
   \   000001   88           DB 136
   \   000002   82           DB 130
   \   000003   80           DB 128

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for unc_mxconf>`:
   \   000000   0F           DB 15
   \   000001   25           DB 37
   \   000002   23           DB 35
   \   000003   21           DB 33

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for llprefix>`:
   \   000000   FE           DB 254
   \   000001   80           DB 128

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ttl_values>`:
   \   000000   00           DB 0
   \   000001   01           DB 1
   \   000002   40           DB 64
   \   000003   FF           DB 255

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for sicslowpan_driver>`:
   \   000000   ....         DW `?<Constant "sicslowpan">`
   \   000002   ....         DW ??sicslowpan_init?relay
   \   000004   ....         DW ??input?relay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??rime_sniffer_add?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    rime_sniffer_add

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??rime_sniffer_remove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    rime_sniffer_remove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_packet_attrs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_packet_attrs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??addr_context_lookup_by_prefix?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    addr_context_lookup_by_prefix

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??addr_context_lookup_by_number?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    addr_context_lookup_by_number

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??compress_addr_64?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    compress_addr_64

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uncompress_addr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uncompress_addr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??compress_hdr_hc06?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    compress_hdr_hc06

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??uncompress_hdr_hc06?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    uncompress_hdr_hc06

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??packet_sent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    packet_sent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??send_packet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    send_packet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??output?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    output

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??input?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    input

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??sicslowpan_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    sicslowpan_init

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant "sicslowpan">`:
   \   000000                DS 11
   \   00000B                REQUIRE `?<Initializer for <Constant "sicslowpan">>`
   \   00000B                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     `?<Constant {255, 2}>`:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for <Constant {255, 2}>>`
   \   000002                REQUIRE __INIT_XDATA_I
   1902            "sicslowpan",
   1903            sicslowpan_init,
   1904            input
   1905          };
   1906          /*--------------------------------------------------------------------*/
   1907          /** @} */
   1908          #endif /* UIP_CONF_IPV6 */

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0     20  addr_context_lookup_by_number
       0      0     28  addr_context_lookup_by_prefix
                          0 0 14 -> memcmp
       0      0     26  compress_addr_64
                          0 0 12 -> memcpy
       1      0     28  compress_hdr_hc06
                          0 0 14 -> addr_context_lookup_by_prefix
                          0 0 14 -> compress_addr_64
                          0 0 16 -> memcpy
       0      0     14  input
                          0 0 14 -> memcpy
                          0 0 12 -> packetbuf_datalen
                          0 0 12 -> packetbuf_dataptr
                          0 0 12 -> set_packet_attrs
                          0 0 12 -> tcpip_input
                          0 0 12 -> uncompress_hdr_hc06
       2      0     14  output
                          0 0 12 -> compress_hdr_hc06
                          0 0 14 -> memcpy
                          0 0 12 -> packetbuf_clear
                          0 0 12 -> packetbuf_dataptr
                          0 0 12 -> packetbuf_set_addr
                          0 0 12 -> packetbuf_set_attr
                          0 0 12 -> packetbuf_set_datalen
                          0 0 12 -> rimeaddr_copy
                          0 0 12 -> send_packet
                          0 0 12 -> set_packet_attrs
       0      0     11  packet_sent
                          0 0  9 -> uip_ds6_link_neighbor_callback
       2      0      0  rime_sniffer_add
       2      0      0  rime_sniffer_remove
       2      0     12  send_packet
                          2 0  0 -> packetbuf_set_addr
                          2 0  0 -> watchdog_periodic
       0      0     21  set_packet_attrs
                          0 0  9 -> packetbuf_set_attr
       2      0      0  sicslowpan_init
                          2 0  0 -> tcpip_set_outputfunc
       0      0     44  uncompress_addr
                          0 0 22 -> memcpy
                          0 0 22 -> memset
                          0 0 20 -> uip_ds6_set_addr_iid
       2      0     34  uncompress_hdr_hc06
                          0 0 20 -> addr_context_lookup_by_number
                          0 0 22 -> memcpy
                          0 0 20 -> packetbuf_addr
                          0 0 20 -> packetbuf_datalen
                          0 0 22 -> uncompress_addr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "sicslowpan">
       2  ?<Constant {255, 2}>
      11  ?<Initializer for <Constant "sicslowpan">>
       2  ?<Initializer for <Constant {255, 2}>>
       2  ?<Initializer for llprefix>
       6  ?<Initializer for sicslowpan_driver>
       4  ?<Initializer for ttl_values>
       4  ?<Initializer for unc_ctxconf>
       4  ?<Initializer for unc_llconf>
       4  ?<Initializer for unc_mxconf>
       6  ??addr_context_lookup_by_number?relay
       6  ??addr_context_lookup_by_prefix?relay
       6  ??compress_addr_64?relay
       6  ??compress_hdr_hc06?relay
       6  ??input?relay
       6  ??output?relay
       6  ??packet_sent?relay
       6  ??rime_sniffer_add?relay
       6  ??rime_sniffer_remove?relay
       6  ??send_packet?relay
       6  ??set_packet_attrs?relay
       6  ??sicslowpan_init?relay
       6  ??uncompress_addr?relay
       6  ??uncompress_hdr_hc06?relay
     153  addr_context_lookup_by_number
     205  addr_context_lookup_by_prefix
      10  addr_contexts
       2  callback
     461  compress_addr_64
    2262  compress_hdr_hc06
       2  context
       2  hc06_ptr
     423  input
       2  last_tx_status
       2  llprefix
     455  output
      81  packet_sent
       1  rime_hdr_len
       1  rime_payload_len
       2  rime_ptr
      19  rime_sniffer_add
      21  rime_sniffer_remove
      41  send_packet
     140  set_packet_attrs
       6  sicslowpan_driver
      42  sicslowpan_init
       4  ttl_values
       4  unc_ctxconf
       4  unc_llconf
       4  unc_mxconf
       1  uncomp_hdr_len
     350  uncompress_addr
    1854  uncompress_hdr_hc06

 
 6 507 bytes in segment BANKED_CODE
    84 bytes in segment BANK_RELAYS
    37 bytes in segment XDATA_I
    37 bytes in segment XDATA_ID
    23 bytes in segment XDATA_Z
 
 6 628 bytes of CODE  memory
    60 bytes of XDATA memory

Errors: none
Warnings: 3
