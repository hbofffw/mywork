###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             03/Apr/2014  10:45:46 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data                                               #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  D:\myWork\myWork\cpu\cc253x\dev\clock.c            #
#    Command line       =  D:\myWork\myWork\cpu\cc253x\dev\clock.c -D         #
#                          AUTOSTART_ENABLE -D PROJECT_CONF_H -lC             #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\ -lA D:\myWork\myWork\examples\wsn2530dk\my #
#                          Project\coord\List\ --diag_suppress                #
#                          Pa050,Pa082,Pe550 --diag_warning Pe144 -o          #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\ -e --no_cse --no_unroll --no_inline         #
#                          --no_code_motion --no_tbaa --debug --core=plain    #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data --nr_virtual_regs    #
#                          16 --preinclude D:\myWork\myWork\examples\wsn2530d #
#                          k\myProject\..\..\..\cpu\cc253x\cc253x.h -I        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\cpu\cc253x\ -I D:\myWork\myWork\examples\wsn2 #
#                          530dk\myProject\..\..\..\platform\wsn2530dk\ -I    #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\..\. #
#                          .\..\core\ -I D:\myWork\myWork\examples\wsn2530dk\ #
#                          myProject\..\..\..\apps\ -I                        #
#                          D:\myWork\myWork\examples\wsn2530dk\myProject\ -Ol #
#    List file          =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\List\clock.lst                                   #
#    Object file        =  D:\myWork\myWork\examples\wsn2530dk\myProject\coor #
#                          d\Obj\clock.r51                                    #
#                                                                             #
#                                                                             #
###############################################################################


   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe2
   \   unsigned char volatile __sfr T1CNTL
   \                     T1CNTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe3
   \   unsigned char volatile __sfr T1CNTH
   \                     T1CNTH:
   \   000000                DS 1
D:\myWork\myWork\cpu\cc253x\dev\clock.c
      1          /*
      2           * Copyright (c) 2009, Swedish Institute of Computer Science.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without
      6           * modification, are permitted provided that the following conditions
      7           * are met:
      8           * 1. Redistributions of source code must retain the above copyright
      9           *    notice, this list of conditions and the following disclaimer.
     10           * 2. Redistributions in binary form must reproduce the above copyright
     11           *    notice, this list of conditions and the following disclaimer in the
     12           *    documentation and/or other materials provided with the distribution.
     13           * 3. Neither the name of the Institute nor the names of its contributors
     14           *    may be used to endorse or promote products derived from this software
     15           *    without specific prior written permission.
     16           *
     17           * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
     18           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     19           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     20           * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
     21           * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     22           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     23           * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     24           * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     25           * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     26           * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     27           * SUCH DAMAGE.
     28           *
     29           * This file is part of the Contiki operating system.
     30           */
     31          
     32          /**
     33           * \file
     34           *         Implementation of the clock functions for the cc253x.
     35           *         Ported over from the cc243x original.
     36           * \author
     37           *         Zach Shelby (zach@sensinode.com) - original (cc243x)
     38           *         George Oikonomou - <oikonomou@users.sourceforge.net> - cc2530 port
     39           */
     40          #include "sfr-bits.h"
     41          #include "sys/clock.h"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \   static int sleeping
   \                     sleeping:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     42          #include "sys/etimer.h"
     43          #include "cc253x.h"
     44          #include "sys/energest.h"
     45          
     46          /* Sleep timer runs on the 32k RC osc. */
     47          /* One clock tick is 7.8 ms */
     48          #define TICK_VAL (32768/128)  /* 256 */
     49          #define TICK_VAL_MY (32768*3)
     50          /*---------------------------------------------------------------------------*/
     51          #if CLOCK_CONF_STACK_FRIENDLY

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     52          volatile uint8_t sleep_flag;
   \                     sleep_flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     53          #endif
     54          
     55          /*---------------------------------------------------------------------------*/
     56          /* Do NOT remove the absolute address and do NOT remove the initialiser here */
     57          //__xdata __at(0x0000) static unsigned long timer_value = 0;

   \                                 In  segment DATA_Z, align 1, keep-with-next
     58          static CC_AT_DATA unsigned long timer_value = 0;
   \                     timer_value:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_DATA_Z

   \                                 In  segment DATA_Z, align 1, keep-with-next
     59          static CC_AT_DATA unsigned long sleeptimer = 0;
   \                     sleeptimer:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_DATA_Z

   \                                 In  segment DATA_Z, align 1, keep-with-next
     60          static volatile CC_AT_DATA clock_time_t count = 0; /* Uptime in ticks */
   \                     count:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_DATA_Z

   \                                 In  segment DATA_Z, align 1, keep-with-next
     61          static volatile CC_AT_DATA clock_time_t seconds = 0; /* Uptime in secs */
   \                     seconds:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_DATA_Z
     62          /*---------------------------------------------------------------------------*/
     63          /**
     64           * Each iteration is ~1.0xy usec, so this function delays for roughly len usec
     65           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     66              void
     67          clock_delay_usec(uint16_t len)
   \                     clock_delay_usec:
     68          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     69              DISABLE_INTERRUPTS();
   \   000000   C2AF         CLR     0xa8.7
   \   000002   8001         SJMP    ??clock_delay_usec_0
     70              while(len--) {
     71                  asm("nop");
   \                     ??clock_delay_usec_1:
   \   000004   00           nop
     72              }
   \                     ??clock_delay_usec_0:
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   \   000009   E8           MOV     A,R0
   \   00000A   24FF         ADD     A,#-0x1
   \   00000C   FA           MOV     R2,A
   \   00000D   E9           MOV     A,R1
   \   00000E   34FF         ADDC    A,#-0x1
   \   000010   FB           MOV     R3,A
   \   000011   E8           MOV     A,R0
   \   000012   49           ORL     A,R1
   \   000013   70EF         JNZ     ??clock_delay_usec_1
     73              ENABLE_INTERRUPTS();
   \   000015   D2AF         SETB    0xa8.7
     74          }
   \   000017   02....       LJMP    ?BRET
   \   00001A                REQUIRE _A_IEN0
     75          /*---------------------------------------------------------------------------*/
     76          /**
     77           * Wait for a multiple of ~8 ms (a tick)
     78           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     79              void
     80          clock_wait(clock_time_t i)
   \                     clock_wait:
     81          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
     82              clock_time_t start;
     83          
     84              start = clock_time();
   \   000009                ; Setup parameters for call to function clock_time
   \   000009   12....       LCALL   ??clock_time?relay
   \   00000C   8A..         MOV     ?V0 + 2,R2
   \   00000E   8B..         MOV     ?V0 + 3,R3
   \   000010   AE..         MOV     R6,?V0 + 2
   \   000012   AF..         MOV     R7,?V0 + 3
     85              while(clock_time() - start < (clock_time_t)i);
   \                     ??clock_wait_0:
   \   000014                ; Setup parameters for call to function clock_time
   \   000014   12....       LCALL   ??clock_time?relay
   \   000017   8A..         MOV     ?V0 + 2,R2
   \   000019   8B..         MOV     ?V0 + 3,R3
   \   00001B   E5..         MOV     A,?V0 + 2
   \   00001D   C3           CLR     C
   \   00001E   9E           SUBB    A,R6
   \   00001F   F8           MOV     R0,A
   \   000020   E5..         MOV     A,?V0 + 3
   \   000022   9F           SUBB    A,R7
   \   000023   F9           MOV     R1,A
   \   000024   C3           CLR     C
   \   000025   E8           MOV     A,R0
   \   000026   95..         SUBB    A,?V0 + 0
   \   000028   E9           MOV     A,R1
   \   000029   95..         SUBB    A,?V0 + 1
   \   00002B   40E7         JC      ??clock_wait_0
     86          }
   \   00002D   7F04         MOV     R7,#0x4
   \   00002F   02....       LJMP    ?BANKED_LEAVE_XDATA
     87          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     88              CCIF clock_time_t
     89          clock_time(void)
   \                     clock_time:
     90          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     91              return count;
   \   000000   AA..         MOV     R2,count+0x0
   \   000002   AB..         MOV     R3,count+0x1
   \   000004   02....       LJMP    ?BRET
     92          }
     93          /*---------------------------------------------------------------------------*/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     94              CCIF unsigned long
     95          clock_seconds(void)
   \                     clock_seconds:
     96          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
     97              return seconds;
   \   000004   85....       MOV     ?V0 + 0,seconds+0x0
   \   000007   85....       MOV     ?V0 + 1,seconds+0x1
   \   00000A   AA..         MOV     R2,?V0 + 0
   \   00000C   AB..         MOV     R3,?V0 + 1
   \   00000E   E4           CLR     A
   \   00000F   FC           MOV     R4,A
   \   000010   FD           MOV     R5,A
   \   000011   D0..         POP     ?V0 + 1
   \   000013   D0..         POP     ?V0 + 0
   \   000015   02....       LJMP    ?BRET
     98          }
     99          /*---------------------------------------------------------------------------*/
    100          /*
    101           * There is some ambiguity between TI cc2530 software examples and information
    102           * in the datasheet.
    103           *
    104           * TI examples appear to be writing to SLEEPCMD, initialising hardware in a
    105           * fashion semi-similar to cc2430
    106           *
    107           * However, the datasheet claims that those bits in SLEEPCMD are reserved
    108           *
    109           * The code here goes by the datasheet (ignore TI examples) and seems to work.
    110           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    111              void
    112          clock_init(void)
   \                     clock_init:
    113          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    114              /* Make sure we know where we stand */
    115              CLKCONCMD = CLKCONCMD_OSC32K | CLKCONCMD_OSC;
   \   000005   75C6C0       MOV     0xc6,#-0x40
    116          
    117              /* Stay with 32 KHz RC OSC, Chance System Clock to 32 MHz */
    118              CLKCONCMD &= ~CLKCONCMD_OSC;
   \   000008   53C6BF       ANL     0xc6,#0xbf
    119              while(CLKCONSTA & CLKCONCMD_OSC);
   \                     ??clock_init_0:
   \   00000B   E59E         MOV     A,0x9e
   \   00000D   A2E6         MOV     C,0xE0 /* A   */.6
   \   00000F   40FA         JC      ??clock_init_0
    120          
    121              /* Tickspeed 500 kHz for timers[1-4] */
    122              CLKCONCMD |= CLKCONCMD_TICKSPD2 | CLKCONCMD_TICKSPD1;
   \   000011   43C630       ORL     0xc6,#0x30
    123              while(CLKCONSTA != CLKCONCMD);
   \                     ??clock_init_1:
   \   000014   E5C6         MOV     A,0xc6
   \   000016   659E         XRL     A,0x9e
   \   000018   70FA         JNZ     ??clock_init_1
    124          
    125              /* Initialize tick value */
    126              timer_value = ST0;
   \   00001A   E595         MOV     A,0x95
   \   00001C   F8           MOV     R0,A
   \   00001D   E4           CLR     A
   \   00001E   F9           MOV     R1,A
   \   00001F   FA           MOV     R2,A
   \   000020   FB           MOV     R3,A
   \   000021   88..         MOV     timer_value+0x0,R0
   \   000023   89..         MOV     timer_value+0x1,R1
   \   000025   8A..         MOV     timer_value+0x2,R2
   \   000027   8B..         MOV     timer_value+0x3,R3
    127              timer_value += ((unsigned long int)ST1) << 8;
   \   000029   E596         MOV     A,0x96
   \   00002B   F5..         MOV     ?V0 + 0,A
   \   00002D   E4           CLR     A
   \   00002E   F5..         MOV     ?V0 + 1,A
   \   000030   F5..         MOV     ?V0 + 2,A
   \   000032   F5..         MOV     ?V0 + 3,A
   \   000034   7408         MOV     A,#0x8
   \   000036   78..         MOV     R0,#?V0 + 0
   \   000038   12....       LCALL   ?L_SHL
   \   00003B   78..         MOV     R0,#timer_value
   \   00003D   79..         MOV     R1,#?V0 + 0
   \   00003F   12....       LCALL   ?L_ADD
    128              timer_value += ((unsigned long int)ST2) << 16;
   \   000042   E597         MOV     A,0x97
   \   000044   F5..         MOV     ?V0 + 0,A
   \   000046   E4           CLR     A
   \   000047   F5..         MOV     ?V0 + 1,A
   \   000049   F5..         MOV     ?V0 + 2,A
   \   00004B   F5..         MOV     ?V0 + 3,A
   \   00004D   7410         MOV     A,#0x10
   \   00004F   78..         MOV     R0,#?V0 + 0
   \   000051   12....       LCALL   ?L_SHL
   \   000054   78..         MOV     R0,#timer_value
   \   000056   79..         MOV     R1,#?V0 + 0
   \   000058   12....       LCALL   ?L_ADD
    129              timer_value += TICK_VAL;
   \   00005B   90....       MOV     DPTR,#__Constant_100
   \   00005E   78..         MOV     R0,#timer_value
   \   000060   12....       LCALL   ?L_ADD_X
    130              ST2 = (unsigned char)(timer_value >> 16);
   \   000063   79..         MOV     R1,#timer_value
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?L_MOV
   \   00006A   7410         MOV     A,#0x10
   \   00006C   78..         MOV     R0,#?V0 + 0
   \   00006E   12....       LCALL   ?UL_SHR
   \   000071   E5..         MOV     A,?V0 + 0
   \   000073   F597         MOV     0x97,A
    131              ST1 = (unsigned char)(timer_value >> 8);
   \   000075   85....       MOV     ?V0 + 0,timer_value+0x0
   \   000078   85....       MOV     ?V0 + 1,timer_value+0x1
   \   00007B   85....       MOV     ?V0 + 2,timer_value+0x2
   \   00007E   85....       MOV     ?V0 + 3,timer_value+0x3
   \   000081   E4           CLR     A
   \   000082   E5..         MOV     A,?V0 + 1
   \   000084   F5..         MOV     ?V0 + 0,A
   \   000086   E5..         MOV     A,?V0 + 0
   \   000088   F596         MOV     0x96,A
    132              ST0 = (unsigned char)timer_value;
   \   00008A   E5..         MOV     A,timer_value+0x0
   \   00008C   85....       MOV     ?V0 + 1,timer_value+0x1
   \   00008F   85....       MOV     ?V0 + 2,timer_value+0x2
   \   000092   85....       MOV     ?V0 + 3,timer_value+0x3
   \   000095   F595         MOV     0x95,A
    133          
    134              STIE = 1; /* IEN0.STIE interrupt enable */
   \   000097   D2AD         SETB    0xa8.5
    135          
    136          }
   \   000099   7F04         MOV     R7,#0x4
   \   00009B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00009E                REQUIRE CLKCONCMD
   \   00009E                REQUIRE CLKCONSTA
   \   00009E                REQUIRE ST0
   \   00009E                REQUIRE ST1
   \   00009E                REQUIRE ST2
   \   00009E                REQUIRE _A_IEN0
    137          /*---------------------------------------------------------------------------*/
    138          /* avoid referencing bits, we don't call code which use them */
    139          #pragma save
                         ^
Warning[Pe161]: unrecognized #pragma
    140          #if CC_CONF_OPTIMIZE_STACK_SIZE
    141          #pragma exclude bits
    142          #endif
    143          #pragma vector = ST_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    144          __interrupt void clock_isr(void)
   \                     clock_isr:
    145          {
   \   000000   C0E0         PUSH    A
   \   000002   74EF         MOV     A,#-0x11
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 17
   \   000007                ; Auto size: 0
    146              DISABLE_INTERRUPTS();
   \   000007   C2AF         CLR     0xa8.7
    147              ENERGEST_ON(ENERGEST_TYPE_IRQ);
   \   000009   E5E2         MOV     A,0xe2
   \   00000B   FA           MOV     R2,A
   \   00000C   7B00         MOV     R3,#0x0
   \   00000E   E5E3         MOV     A,0xe3
   \   000010   F8           MOV     R0,A
   \   000011   7900         MOV     R1,#0x0
   \   000013   E4           CLR     A
   \   000014   C8           XCH     A,R0
   \   000015   F9           MOV     R1,A
   \   000016   EA           MOV     A,R2
   \   000017   28           ADD     A,R0
   \   000018   F8           MOV     R0,A
   \   000019   EB           MOV     A,R3
   \   00001A   39           ADDC    A,R1
   \   00001B   F9           MOV     R1,A
   \   00001C   90....       MOV     DPTR,#energest_current_time + 4
   \   00001F   E8           MOV     A,R0
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   E9           MOV     A,R1
   \   000023   F0           MOVX    @DPTR,A
   \   000024   90....       MOV     DPTR,#energest_current_mode + 2
   \   000027   7401         MOV     A,#0x1
   \   000029   F0           MOVX    @DPTR,A
    148          
    149              /*
    150               * Read value of the ST0:ST1:ST2, add TICK_VAL and write it back.
    151               * Next interrupt occurs after the current time + TICK_VAL
    152               */
    153          
    154              if(sleeping == 0)
   \   00002A   90....       MOV     DPTR,#sleeping
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F8           MOV     R0,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   E8           MOV     A,R0
   \   000033   49           ORL     A,R1
   \   000034   707F         JNZ     ??clock_isr_0
    155              {
    156                  timer_value = ST0;
   \   000036   E595         MOV     A,0x95
   \   000038   F8           MOV     R0,A
   \   000039   E4           CLR     A
   \   00003A   F9           MOV     R1,A
   \   00003B   FA           MOV     R2,A
   \   00003C   FB           MOV     R3,A
   \   00003D   88..         MOV     timer_value+0x0,R0
   \   00003F   89..         MOV     timer_value+0x1,R1
   \   000041   8A..         MOV     timer_value+0x2,R2
   \   000043   8B..         MOV     timer_value+0x3,R3
    157                  timer_value += ((unsigned long int)ST1) << 8;
   \   000045   E596         MOV     A,0x96
   \   000047   F5..         MOV     ?V0 + 0,A
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V0 + 1,A
   \   00004C   F5..         MOV     ?V0 + 2,A
   \   00004E   F5..         MOV     ?V0 + 3,A
   \   000050   7408         MOV     A,#0x8
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   12....       LCALL   ?L_SHL
   \   000057   78..         MOV     R0,#timer_value
   \   000059   79..         MOV     R1,#?V0 + 0
   \   00005B   12....       LCALL   ?L_ADD
    158                  timer_value += ((unsigned long int)ST2) << 16;
   \   00005E   E597         MOV     A,0x97
   \   000060   F5..         MOV     ?V0 + 0,A
   \   000062   E4           CLR     A
   \   000063   F5..         MOV     ?V0 + 1,A
   \   000065   F5..         MOV     ?V0 + 2,A
   \   000067   F5..         MOV     ?V0 + 3,A
   \   000069   7410         MOV     A,#0x10
   \   00006B   78..         MOV     R0,#?V0 + 0
   \   00006D   12....       LCALL   ?L_SHL
   \   000070   78..         MOV     R0,#timer_value
   \   000072   79..         MOV     R1,#?V0 + 0
   \   000074   12....       LCALL   ?L_ADD
    159                  timer_value += TICK_VAL;  //default: TICK_VAL, mine: TICK_VAL_MY
   \   000077   90....       MOV     DPTR,#__Constant_100
   \   00007A   78..         MOV     R0,#timer_value
   \   00007C   12....       LCALL   ?L_ADD_X
    160                  ST2 = (unsigned char)(timer_value >> 16);
   \   00007F   79..         MOV     R1,#timer_value
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   12....       LCALL   ?L_MOV
   \   000086   7410         MOV     A,#0x10
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?UL_SHR
   \   00008D   E5..         MOV     A,?V0 + 0
   \   00008F   F597         MOV     0x97,A
    161                  ST1 = (unsigned char)(timer_value >> 8);
   \   000091   85....       MOV     ?V0 + 0,timer_value+0x0
   \   000094   85....       MOV     ?V0 + 1,timer_value+0x1
   \   000097   85....       MOV     ?V0 + 2,timer_value+0x2
   \   00009A   85....       MOV     ?V0 + 3,timer_value+0x3
   \   00009D   E4           CLR     A
   \   00009E   E5..         MOV     A,?V0 + 1
   \   0000A0   F5..         MOV     ?V0 + 0,A
   \   0000A2   E5..         MOV     A,?V0 + 0
   \   0000A4   F596         MOV     0x96,A
    162                  ST0 = (unsigned char)timer_value;
   \   0000A6   E5..         MOV     A,timer_value+0x0
   \   0000A8   85....       MOV     ?V0 + 1,timer_value+0x1
   \   0000AB   85....       MOV     ?V0 + 2,timer_value+0x2
   \   0000AE   85....       MOV     ?V0 + 3,timer_value+0x3
   \   0000B1   F595         MOV     0x95,A
   \   0000B3   807D         SJMP    ??clock_isr_1
    163              }
    164              else
    165              {
    166                  sleeptimer = ST0;
   \                     ??clock_isr_0:
   \   0000B5   E595         MOV     A,0x95
   \   0000B7   F8           MOV     R0,A
   \   0000B8   E4           CLR     A
   \   0000B9   F9           MOV     R1,A
   \   0000BA   FA           MOV     R2,A
   \   0000BB   FB           MOV     R3,A
   \   0000BC   88..         MOV     sleeptimer+0x0,R0
   \   0000BE   89..         MOV     sleeptimer+0x1,R1
   \   0000C0   8A..         MOV     sleeptimer+0x2,R2
   \   0000C2   8B..         MOV     sleeptimer+0x3,R3
    167                  sleeptimer += ((unsigned long int)ST1) << 8;
   \   0000C4   E596         MOV     A,0x96
   \   0000C6   F5..         MOV     ?V0 + 0,A
   \   0000C8   E4           CLR     A
   \   0000C9   F5..         MOV     ?V0 + 1,A
   \   0000CB   F5..         MOV     ?V0 + 2,A
   \   0000CD   F5..         MOV     ?V0 + 3,A
   \   0000CF   7408         MOV     A,#0x8
   \   0000D1   78..         MOV     R0,#?V0 + 0
   \   0000D3   12....       LCALL   ?L_SHL
   \   0000D6   78..         MOV     R0,#sleeptimer
   \   0000D8   79..         MOV     R1,#?V0 + 0
   \   0000DA   12....       LCALL   ?L_ADD
    168                  sleeptimer += ((unsigned long int)ST2) << 16;
   \   0000DD   E597         MOV     A,0x97
   \   0000DF   F5..         MOV     ?V0 + 0,A
   \   0000E1   E4           CLR     A
   \   0000E2   F5..         MOV     ?V0 + 1,A
   \   0000E4   F5..         MOV     ?V0 + 2,A
   \   0000E6   F5..         MOV     ?V0 + 3,A
   \   0000E8   7410         MOV     A,#0x10
   \   0000EA   78..         MOV     R0,#?V0 + 0
   \   0000EC   12....       LCALL   ?L_SHL
   \   0000EF   78..         MOV     R0,#sleeptimer
   \   0000F1   79..         MOV     R1,#?V0 + 0
   \   0000F3   12....       LCALL   ?L_ADD
    169                  sleeptimer += TICK_VAL_MY;  //default: TICK_VAL, mine: TICK_VAL_MY
   \   0000F6   90....       MOV     DPTR,#__Constant_18000
   \   0000F9   78..         MOV     R0,#sleeptimer
   \   0000FB   12....       LCALL   ?L_ADD_X
    170                  ST2 = (unsigned char)(sleeptimer >> 16);
   \   0000FE   79..         MOV     R1,#sleeptimer
   \   000100   78..         MOV     R0,#?V0 + 0
   \   000102   12....       LCALL   ?L_MOV
   \   000105   7410         MOV     A,#0x10
   \   000107   78..         MOV     R0,#?V0 + 0
   \   000109   12....       LCALL   ?UL_SHR
   \   00010C   E5..         MOV     A,?V0 + 0
   \   00010E   F597         MOV     0x97,A
    171                  ST1 = (unsigned char)(sleeptimer >> 8);
   \   000110   85....       MOV     ?V0 + 0,sleeptimer+0x0
   \   000113   85....       MOV     ?V0 + 1,sleeptimer+0x1
   \   000116   85....       MOV     ?V0 + 2,sleeptimer+0x2
   \   000119   85....       MOV     ?V0 + 3,sleeptimer+0x3
   \   00011C   E4           CLR     A
   \   00011D   E5..         MOV     A,?V0 + 1
   \   00011F   F5..         MOV     ?V0 + 0,A
   \   000121   E5..         MOV     A,?V0 + 0
   \   000123   F596         MOV     0x96,A
    172                  ST0 = (unsigned char)sleeptimer;
   \   000125   E5..         MOV     A,sleeptimer+0x0
   \   000127   85....       MOV     ?V0 + 1,sleeptimer+0x1
   \   00012A   85....       MOV     ?V0 + 2,sleeptimer+0x2
   \   00012D   85....       MOV     ?V0 + 3,sleeptimer+0x3
   \   000130   F595         MOV     0x95,A
    173              }
    174          
    175          
    176              ++count;
   \                     ??clock_isr_1:
   \   000132   78..         MOV     R0,#count
   \   000134   E6           MOV     A,@R0
   \   000135   2401         ADD     A,#0x1
   \   000137   F6           MOV     @R0,A
   \   000138   08           INC     R0
   \   000139   E6           MOV     A,@R0
   \   00013A   3400         ADDC    A,#0x0
   \   00013C   F6           MOV     @R0,A
   \   00013D   18           DEC     R0
    177          
    178              /* Make sure the CLOCK_CONF_SECOND is a power of two, to ensure
    179                 that the modulo operation below becomes a logical and and not
    180                 an expensive divide. Algorithm from Wikipedia:
    181          http://en.wikipedia.org/wiki/Power_of_two */
    182          #if (CLOCK_CONF_SECOND & (CLOCK_CONF_SECOND - 1)) != 0
    183          #pragma error CLOCK_CONF_SECOND must be a power of two (i.e., 1, 2, 4, 8, 16, 32, 64, ...).
    184          #pragma error Change CLOCK_CONF_SECOND in contiki-conf.h.
    185          #endif
    186              if(count % CLOCK_CONF_SECOND == 0) {
   \   00013E   A8..         MOV     R0,count+0x0
   \   000140   A9..         MOV     R1,count+0x1
   \   000142   7A80         MOV     R2,#-0x80
   \   000144   7B00         MOV     R3,#0x0
   \   000146   12....       LCALL   ?US_DIV_MOD
   \   000149   8A..         MOV     ?V0 + 0,R2
   \   00014B   8B..         MOV     ?V0 + 1,R3
   \   00014D   E5..         MOV     A,?V0 + 0
   \   00014F   45..         ORL     A,?V0 + 1
   \   000151   700C         JNZ     ??clock_isr_2
    187                  ++seconds;
   \   000153   78..         MOV     R0,#seconds
   \   000155   E6           MOV     A,@R0
   \   000156   2401         ADD     A,#0x1
   \   000158   F6           MOV     @R0,A
   \   000159   08           INC     R0
   \   00015A   E6           MOV     A,@R0
   \   00015B   3400         ADDC    A,#0x0
   \   00015D   F6           MOV     @R0,A
   \   00015E   18           DEC     R0
    188              }
    189          
    190          #if CLOCK_CONF_STACK_FRIENDLY
    191              sleep_flag = 1;
   \                     ??clock_isr_2:
   \   00015F   90....       MOV     DPTR,#sleep_flag
   \   000162   7401         MOV     A,#0x1
   \   000164   F0           MOVX    @DPTR,A
    192          #else
    193              if(etimer_pending()
    194                      && (etimer_next_expiration_time() - count - 1) > MAX_TICKS) {
    195                  etimer_request_poll();
    196              }
    197          #endif
    198          
    199              STIF = 0; /* IRCON.STIF */
   \   000165   C2C7         CLR     0xc0.7
    200              ENERGEST_OFF(ENERGEST_TYPE_IRQ);
   \   000167   90....       MOV     DPTR,#energest_current_mode + 2
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   6037         JZ      ??clock_isr_3
   \   00016D   E5E2         MOV     A,0xe2
   \   00016F   FA           MOV     R2,A
   \   000170   7B00         MOV     R3,#0x0
   \   000172   E5E3         MOV     A,0xe3
   \   000174   F8           MOV     R0,A
   \   000175   7900         MOV     R1,#0x0
   \   000177   E4           CLR     A
   \   000178   C8           XCH     A,R0
   \   000179   F9           MOV     R1,A
   \   00017A   EA           MOV     A,R2
   \   00017B   28           ADD     A,R0
   \   00017C   FA           MOV     R2,A
   \   00017D   EB           MOV     A,R3
   \   00017E   39           ADDC    A,R1
   \   00017F   FB           MOV     R3,A
   \   000180   90....       MOV     DPTR,#energest_current_time + 4
   \   000183   E0           MOVX    A,@DPTR
   \   000184   F8           MOV     R0,A
   \   000185   A3           INC     DPTR
   \   000186   E0           MOVX    A,@DPTR
   \   000187   F9           MOV     R1,A
   \   000188   EA           MOV     A,R2
   \   000189   C3           CLR     C
   \   00018A   98           SUBB    A,R0
   \   00018B   F5..         MOV     ?V0 + 0,A
   \   00018D   EB           MOV     A,R3
   \   00018E   99           SUBB    A,R1
   \   00018F   F5..         MOV     ?V0 + 1,A
   \   000191   E4           CLR     A
   \   000192   F5..         MOV     ?V0 + 2,A
   \   000194   F5..         MOV     ?V0 + 3,A
   \   000196   90....       MOV     DPTR,#energest_total_time + 8
   \   000199   78..         MOV     R0,#?V0 + 0
   \   00019B   12....       LCALL   ?L_ADD_TO_X
   \   00019E   90....       MOV     DPTR,#energest_current_mode + 2
   \   0001A1   7400         MOV     A,#0x0
   \   0001A3   F0           MOVX    @DPTR,A
    201              ENABLE_INTERRUPTS();
   \                     ??clock_isr_3:
   \   0001A4   D2AF         SETB    0xa8.7
    202          }
   \   0001A6   7F04         MOV     R7,#0x4
   \   0001A8   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   0001AB                REQUIRE _A_IEN0
   \   0001AB                REQUIRE T1CNTL
   \   0001AB                REQUIRE T1CNTH
   \   0001AB                REQUIRE ST0
   \   0001AB                REQUIRE ST1
   \   0001AB                REQUIRE ST2
   \   0001AB                REQUIRE _A_IRCON
    203          #pragma restore
                         ^
Warning[Pe161]: unrecognized #pragma
    204          /*---------------------------------------------------------------------------*/
    205          
    206          //---------------------added by dongbo huang---------------------------

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    207          int clock_getSleepState()
   \                     clock_getSleepState:
    208          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    209              return sleeping;
   \   000004   90....       MOV     DPTR,#sleeping
   \   000007   E0           MOVX    A,@DPTR
   \   000008   FA           MOV     R2,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FB           MOV     R3,A
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET
    210          }
    211          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    212          void clock_setSleepState(int state)
   \                     clock_setSleepState:
    213          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    214              sleeping = state;
   \   000004   90....       MOV     DPTR,#sleeping
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    215          }
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET

   \                                 In  segment INTVEC, offset 0x2b, root
   \                     `??clock_isr??INTVEC 43`:
   \   00002B   02....       LJMP       (clock_isr)

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_100:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_100>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_100>`:
   \   000000   00010000     DD 256

   \                                 In  segment XDATA_I, align 1, keep-with-next
   \                     __Constant_18000:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for __Constant_18000>`
   \   000004                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for __Constant_18000>`:
   \   000000   00800100     DD 98304

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_delay_usec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_delay_usec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_wait?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_wait

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_time?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_time

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_seconds?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_seconds

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_getSleepState?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_getSleepState

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??clock_setSleepState?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    clock_setSleepState
    216          //-------------------------------------------------------------------

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      0  clock_delay_usec
       2      0      0  clock_getSleepState
       0      0     12  clock_init
       0      0     17  clock_isr
       2      0      0  clock_seconds
       2      0      0  clock_setSleepState
       0      0     12  clock_time
       0      0     12  clock_wait
                          0 0 12 -> clock_time


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Initializer for __Constant_100>
       4  ?<Initializer for __Constant_18000>
       6  ??clock_delay_usec?relay
       6  ??clock_getSleepState?relay
       6  ??clock_init?relay
       3  ??clock_isr??INTVEC 43
       6  ??clock_seconds?relay
       6  ??clock_setSleepState?relay
       6  ??clock_time?relay
       6  ??clock_wait?relay
       1  CLKCONCMD
       1  CLKCONSTA
       1  ST0
       1  ST1
       1  ST2
       1  T1CNTH
       1  T1CNTL
       1  _A_IEN0
       1  _A_IRCON
       4  __Constant_100
       4  __Constant_18000
      26  clock_delay_usec
      19  clock_getSleepState
     158  clock_init
     427  clock_isr
      24  clock_seconds
      19  clock_setSleepState
       7  clock_time
      50  clock_wait
       2  count
       2  seconds
       1  sleep_flag
       2  sleeping
       4  sleeptimer
       4  timer_value

 
 303 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
  12 bytes in segment DATA_Z
   3 bytes in segment INTVEC
 427 bytes in segment NEAR_CODE
   9 bytes in segment SFR_AN
   8 bytes in segment XDATA_I
   8 bytes in segment XDATA_ID
   3 bytes in segment XDATA_Z
 
 772 bytes of CODE  memory (+ 11 bytes shared)
  12 bytes of DATA  memory (+  9 bytes shared)
   3 bytes of XDATA memory (+  8 bytes shared)

Errors: none
Warnings: 2
